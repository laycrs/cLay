<html>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<head>
<style>
@font-face{ font-family: mplus-1p-thin;
  src: url('./font/mplus-1p-thin.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1p-light;
  src: url('./font/mplus-1p-light.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1p-regular;
  src: url('./font/mplus-1p-regular.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1p-medium;
  src: url('./font/mplus-1p-medium.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1p-bold;
  src: url('./font/mplus-1p-bold.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1p-heavy;
  src: url('./font/mplus-1p-heavy.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1p-black;
  src: url('./font/mplus-1p-black.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2p-thin;
  src: url('./font/mplus-2p-thin.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2p-light;
  src: url('./font/mplus-2p-light.ttf')
       format("truetype");
}

@font-face
{
font-family: mplus-2p-regular;
src: url('./font/mplus-2p-regular.ttf')
     format("truetype");
}

@font-face{
  font-family: mplus-2p-medium;
  src: url('./font/mplus-2p-medium.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2p-bold;
  src: url('./font/mplus-2p-bold.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2p-heavy;
  src: url('./font/mplus-2p-heavy.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2p-black;
  src: url('./font/mplus-2p-black.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1c-thin;
  src: url('./font/mplus-1c-thin.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1c-light;
  src: url('./font/mplus-1c-light.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1c-regular;
  src: url('./font/mplus-1c-regular.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1c-medium;
  src: url('./font/mplus-1c-medium.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1c-bold;
  src: url('./font/mplus-1c-bold.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1c-heavy;
  src: url('./font/mplus-1c-heavy.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1c-black;
  src: url('./font/mplus-1c-black.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2c-thin;
  src: url('./font/mplus-2c-thin.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2c-light;
  src: url('./font/mplus-2c-light.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2c-regular;
  src: url('./font/mplus-2c-regular.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2c-medium;
  src: url('./font/mplus-2c-medium.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2c-bold;
  src: url('./font/mplus-2c-bold.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2c-heavy;
  src: url('./font/mplus-2c-heavy.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2c-black;
  src: url('./font/mplus-2c-black.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1m-thin;
  src: url('./font/mplus-1m-thin.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1m-light;
  src: url('./font/mplus-1m-light.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1m-regular;
  src: url('./font/mplus-1m-regular.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1m-medium;
  src: url('./font/mplus-1m-medium.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1m-bold;
  src: url('./font/mplus-1m-bold.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2m-thin;
  src: url('./font/mplus-2m-thin.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2m-light;
  src: url('./font/mplus-2m-light.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2m-regular;
  src: url('./font/mplus-2m-regular.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2m-medium;
  src: url('./font/mplus-2m-medium.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-2m-bold;
  src: url('./font/mplus-2m-bold.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1mn-thin;
  src: url('./font/mplus-1mn-thin.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1mn-light;
  src: url('./font/mplus-1mn-light.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1mn-regular;
  src: url('./font/mplus-1mn-regular.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1mn-medium;
  src: url('./font/mplus-1mn-medium.ttf')
       format("truetype");
}

@font-face{
  font-family: mplus-1mn-bold;
  src: url('./font/mplus-1mn-bold.ttf')
       format("truetype");
}


h1, h2, h3, h4, address, blockquote, center, dir, div, dl, fieldset, form, hr, isindex, menu, noframes, ol, p, pre, table, code {
  display : block;
}
a, abbr, acronym, applet, b, basefont, bdo, big, button, cite, code, dfn, em, font, i, iframe, img, input, kbd, label, map, object, q, ruby, s, samp, select, small, span, strike, strong, sub, sup, textarea, tt, u, var {
  display : inline;
}

* {
  margin : 0;
  padding : 0;
}

body{
  font-family: mplus-1p-light;
  font-size: 14pt;
  color : #655c53;
  font-weight : normal;
  background : #ded7ce;
  text-shadow: 0 0 1px #999, 0 0 2px #ccc, 0 0 3px #ddd;
  -webkit-text-stroke: 0.2px #655c53;
}

p {
  margin : 0.5em;
  padding : 0.2em;
  line-height : 180%;
}

ol {
  margin  : 0.5em 0.5em 0.5em 1em;
  padding : 0.0em 0.0em 0.0em 1em;
}

ul {
  margin  : 0.5em 0.5em 0.5em 1em;
  padding : 0.0em 0.0em 0.0em 1em;
  list-style-type: circle;
}

li {
  margin : 0.5em 0.2em 0.5em 0.2em;
}

h1 {
  font-family: mplus-1p-heavy;
  font-weight : normal;
  padding-left: 10px;
  border-width: 2px 20px 2px 20px;
  border-style: solid;
  border-color: #beb7ae;
  font-size : 120%;
  margin : 40px 10px 0 0;
  text-align : center;
}
h2 {
  font-family: mplus-1p-bold;
  font-weight : normal;
  padding-left: 10px;
  border-width: 0px 0px 2px 20px;
  border-style: solid;
  border-color: #beb7ae;
  margin : 30px 15px 0 0;
  font-size : 100%;
}
h3 {
  font-family: mplus-1p-regular;
  font-weight : normal;
  border-left-color: #beb7ae;
  padding: 3px 0px 0px 6px;
  border-style: solid;
  border-width: 0px 0px 0px 10px;
  font-size : 100%;
}
pre {
  font-family: mplus-1m-light;
  font-weight : normal;
  width : auto;
  margin : 2px 10px;
  padding : 5px 0 5px 10px;
  background-color : #d4cdc3;
  border : 1px solid #afa8a1;
  overflow : auto;
}
span#code {
  font-family: mplus-1m-light;
  font-weight : normal;
  padding : 2px 5px 2px 5px;
  background-color : #d4cdc3;
  border : 1px solid #afa8a1;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script type="text/x-mathjax-config"></script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
<title>cLay ドキュメント（version 20241019-1） - ゲームにっき（仮）別館（仮）</title>


<h1>cLay ドキュメント（version 20241019-1）</h1>

<h2 id="i3auf90a7">目次（全然未完成，整理中です…すみません）</h2>
<p><a href="#iahifoaf89">概要など</a><br></p>
<ul><li><a href="#ja908asad">概要</a> | <a href="#kjfoda0">未対応なもの</a> | <a href="#aiufa897">制限</a> | <a href="#iaoufiau">色々</a> | <a href="#lkajfoa7">フラグ</a></li>
</ul>
<p><a href="#alkjfoapf978">型と変数宣言</a><br></p>
<ul><li><a href="#akljfa89083">型の省略形</a> | <a href="#akjfopauifa097">modint型など</a> | <a href="#afjaopfa078">配列の変数宣言</a></li>
</ul>
<p><a href="#akjfaf0001">入出力</a><br></p>
<ul><li><a href="#akdjfoaif73">入力</a> | <a href="#akdjfoaif74">出力</a> | <a href="#aadkjfa87">細かい注意</a> | <a href="#akdjfoaif79">ファイル入出力</a> | <a href="#akdjfoaif76">変数宣言時の入力</a> | <a href="#akdjfoaif75">チェック付き入力</a></li>
</ul>
<p><a href="#akjfaf0002">ループ</a><br><a href="#akjfaf0003">演算子</a><br><a href="#akjfaf0004">グラフ</a><br><a href="#akjfaf0005">データ構造</a><br></p>
<ul><li><a href="#afkapf890">UnionFind (UF, Disjoint Set Union, DSU)</a></li>
</ul>
<p><a href="#akjfaf0006">整数</a><br></p>
<ul><li><a href="#akddj8712">桁・n進数</a></li>
<li><a href="#akjfaf1231">ルートとk乗根</a> | <a href="#akjfaf1235">log2</a> | <a href="#akjgbf1235">ビット</a></li>
</ul>
<p><a href="#akjfaf0007">幾何</a><br><a href="#akjfaf0008">行列</a><br><a href="#akjfaf0009">配列</a><br></p>
<ul><li><a href="#ayjfafddaa">ソート（配列）</a> | <a href="#ayjfafddab">ソート（変数）</a> | <a href="#ayjfaf001a">主に1つの配列に関する処理</a> | <a href="#ayjfaf001b">主に1つの配列に関する計算</a> | <a href="#ayjfaf002a">主に2つの配列に関する処理</a> | <a href="#ayjfaf002b">主に2つの配列に関する計算</a> | <a href="#ayjfaf003a">主に複数の配列に関する処理</a> | <a href="#ayjfaf003b">主に複数の配列に関する計算</a></li>
</ul>
<p><a href="#akjfaf0011">文字列</a><br><a href="#akjfaf8371h">典型手法</a><br></p>
<ul><li><a href="#ayjfoiujd87">尺取法（TwoPointers）</a></li>
</ul>
<p><a href="#akjfaf0010">典型問題</a><br><a href="#akjfaf0">その他（未整理）</a><br><a href="#joig980">更新履歴</a><br></p>



<h1 id="iahifoaf89">概要など</a></h1>

<h2 id="ja908asad">概要</h2>
<p>C++っぽい言語をC++言語に変換します．<br>無駄にライブラリを張るのがめんどくさい，鬱陶しい，ライブラリを整備していても綺麗に書けない処理があるなどを解消したいというのが目的．目的の達成はそのうち…．<br>blogにコード載せる時にライブラリとかincludeとかが長ったらしい，のをなんとかしたいというのも動機の1つです．<br></p>
<p>C++っぽいコードを標準入力から食わせるとC++のコードが標準出力から出てきます．<br></p>
<p>#include&lt;bits/stdc++.h&gt;およびgetchar_unlocked，putchar_unlockedなどを使用しているので，それが動かない環境だと動かないし，動かないコードが出てきます．<br>（その場合は，フラグの欄を見て下さい）<br></p>
<p>cLayの概要のページは<a href="http://rsujskf.s602.xrea.com/?cLay">こちら</a>．<br>最新のバージョンへのリンク：<a href="http://rsujskf.s602.xrea.com/files/clay.zip">コードとドキュメントを含むzipファイル</a>／<a href="http://rsujskf.s602.xrea.com/files/clay.cpp">プログラムのコード</a>／<a href="http://rsujskf.s602.xrea.com/files/clay.html">ドキュメント</a>．<br>過去のバージョンを含むコードの公開ページは<a href="http://rsujskf.s602.xrea.com/?cLay_zip">こちら</a>（不定期更新）．<br></p>
<p>ローカルでこのドキュメントを見る場合は，このhtmlファイルと同じフォルダにfontフォルダを作成し，その中にM+ FONTS（mplus-1p-light.ttfなどのmplus-*.ttfファイル）を入れるとオンライン版と同じように表示されると思います．<br>実際に使用しているのは mplus-1p-light, mplus-1p-heavy, mplus-1p-bold, mplus-1p-regular, mplus-1m-light の5種類だと思います．<br></p>


<h2 id="kjfoda0">未対応なもの</h2>
<p>重要度が高い順に，<u><b>下線付き太字</b></u>，<b>太字</b>，普通です．重要度が低いものはそもそも対応させる気がないものが多いです．<br>この欄ではC++ではできるけど…というもの主にリストアップ．<br></p>
<ul><li>共用体・enum</li>
<li>typedef，defineなどで型を定義するとやばい．他にも括弧使わないと表せない複雑な型（int (*hoge)[10];とか）はダメ</li>
<li>キャストとかもやばいかも</li>
<li>関数を含む式の計算結果の型の推定がうまくいかないはず</li>
<li>最近のC言語/C++の仕様</li>
<li><b>invalidなコードを食わせると多分落ちる</b></li>
<li>validだけど不自然な書き方とか，他にも色々．書ききれない</li>
</ul>


<h2 id="aiufa897">制限</h2>
<p>以下の単語は変数名などで使うとやばい．<br>基本的にバージョンアップするときは互換性を保ちたいけど，此処の欄は普通に増やす．<br></p>

<pre><span style="color:#444444">色々書いてたけどめんどくさくなったので省略．
</span></pre>
<p><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span></span></span> は32bit，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">long</span></span></span> は32bitか64bit，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">long</span> <span style="color:#0000FF;">long</span></span></span> は64bitだと思って実装しています．違うとまずい場合があるかも．<br></p>


<h2 id="iaoufiau">色々</h2>
<p>最初に<br></p>

<pre><span style="color:#444444"><span style="color:#FF0000;">#include</span><span style="color:#BB8888;">&lt;</span><span style="color:#BB8888;">bits</span><span style="color:#BB8888;">/</span><span style="color:#BB8888;">stdc</span><span style="color:#BB8888;">+</span><span style="color:#BB8888;">+</span><span style="color:#BB8888;">.</span><span style="color:#BB8888;">h</span><span style="color:#BB8888;">&gt;</span>
<span style="color:#AA2222;">using</span> <span style="color:#AA2222;">namespace</span> <span style="color:#000000;font-weight:bold;">std</span><span style="color:#000000;">;</span>
</span></pre>
<p>が強制的に挿入されます．<br>#includeを書く必要はないですが，GCC以外で動かなくなる．<br></p>
<p>int main()は省略可能です．<br>いきなり関数の中じゃなくて{で始まるブロックが最初に出てきたときにint main()が補われます．<br>int main()で補われたブロック内の最後がreturn文でない場合は，<span id="code"><span style="color:#444444"><span style="color:#0088FF;">return</span> <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span></span></span> が最後に補われます．<br>main関数がなく，if文やfor文などがつかないブロックもない場合，プログラムの最初に int main(){ が，最後に } が補われます．<br></p>
<p>変数宣言や三項演算子 ? : を使っていない部分での,は（適切に{}を補った上で）;に置き換えられます．<br>その結果，<span id="code"><span style="color:#444444"><span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#000000;">;</span><span style="color:#000000;">;</span><span style="color:#662222;">)</span> i++, <span style="color:#0088FF;">break</span><span style="color:#000000;">;</span></span></span> などと書くと <span id="code"><span style="color:#444444"><span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#000000;">;</span><span style="color:#000000;">;</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span> i++<span style="color:#000000;">;</span> <span style="color:#0088FF;">break</span><span style="color:#000000;">;</span> <span style="color:#440000;font-weight:bold;">}</span></span></span> に展開されます．<br></p>
<p>cpp_int が出てくると，boostの多倍長整数を利用できるように<br></p>

<pre><span style="color:#444444"><span style="color:#FF0000;">#include</span><span style="color:#BB8888;"> </span><span style="color:#BB8888;">&lt;</span><span style="color:#BB8888;">boost</span><span style="color:#BB8888;">/</span><span style="color:#BB8888;">multiprecision</span><span style="color:#BB8888;">/</span><span style="color:#BB8888;">cpp_int</span><span style="color:#BB8888;">.</span><span style="color:#BB8888;">hpp</span><span style="color:#BB8888;">&gt;</span>
<span style="color:#AA2222;">using</span> <span style="color:#AA2222;">namespace</span> boost::multiprecision<span style="color:#000000;">;</span>
</span></pre>
<p>が挿入されます．<br></p>


<h2 id="lkajfoa7">フラグ</h2>
<p>途中で（プログラムの先頭が推奨）<br>//hogehoge<br>という形式でフラグを立てておくと色々な環境に対応させるために出力されるコードが変更されます．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#888888;">//no-unlocked</span></span></span> : fread_unlocked, fwrite_unlocked, getchar_unlocked, putchar_unlocked が fread, fwrite, getchar, putchar に置き換わります．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#888888;">//no-fread</span></span></span> : rd() において，fread_unlocked() を使わず getchar_unlocked() を使用します．scanf, cin などが現れたら自動的にこのフラグが指定されます．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#888888;">//no-fwrite</span></span></span> : wt() において，fwrite_unlocked() を使わず putchar_unlocked() を使用します．printf, cout, puts が現れたら自動的にこのフラグを指定されます．このフラグを指定しないと，まとめて出力されるので，デバッグ等の理由で逐次出力したい場合は，このフラグを指定してください．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#888888;">//interactive</span></span></span> : インタラクティブ形式の問題に対応するもの（現在codeforcesのみで動くことを確認）．fread() や fwrite() を使うのをやめ，unlockedでない getchar(), putchar() を使って入出力するようにします．また，改行を出力したとき自動的に fflush(stdout) します．readerFile(), writerFile() は使用できなくなります．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#888888;">//working_memory=500m</span></span></span> : ワーキングメモリのサイズを変更します（詳細はワーキングメモリのところを見てください）</li>
<li><span id="code"><span style="color:#444444"><span style="color:#888888;">//no-gcd()</span></span></span>, <span id="code"><span style="color:#444444"><span style="color:#888888;">//no-GCD()</span></span></span> : それぞれ gcd(), GCD() の機能を無効化します</li>
<li>//no-lcm(), //no-LCM() : それぞれ lcm(), LCM() の機能を無効化します</li>
<li>//no-min(), //no-MIN() : それぞれ min(), MIN() の機能を無効化します（min[]()の機能は有効のままです）</li>
<li>//no-max(), //no-MAX() : それぞれ max(), MAX() の機能を無効化します（max[]()の機能は有効のままです）</li>
<li>//no-sum(), //no-SUM() : それぞれ sum(), SUM() の機能を無効化します</li>
<li>//no-mul(), //no-MUL() : それぞれ mul(), MUL() の機能を無効化します</li>
</ul>
<p>またmint構造体など使用すると挿入される関数や構造体を挿入されなくするフラグは以下の通りです．<br>例えば，//no-insert-mintを指定するとmint型が使えなくなる代わりに，mintという変数や関数などを自由に宣言することができるようになります．<br></p>
<ul><li>//no-insert-stdc : #include&lt;bits/stdc++.h&gt;</li>
<li>//no-insert-namespace : using namespace std;</li>
<li>//no-insert-define_MD : #define MD 1000000007</li>
<li>//no-insert-define_PI : #define PI 3.14159265358979323846</li>
<li>//no-insert-workmemory</li>
<li>//no-insert-workmemory_init</li>
<li>//no-insert-walloc1d</li>
<li>…</li>
</ul>


<h1 id="alkjfoapf978">型と変数宣言</h1>

<h2 id="akljfa89083">型の省略形</h2>
<p><span id="code"><span style="color:#444444"><span style="color:#0000FF;">ll</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">long</span> <span style="color:#0000FF;">long</span></span></span> に，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">ull</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">unsigned</span> <span style="color:#0000FF;">long</span> <span style="color:#0000FF;">long</span></span></span> に置き換えられます．<br><span id="code"><span style="color:#444444"><span style="color:#0000FF;">VI</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">int</span>&gt;</span></span> に，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">VVI</span></span></span>/<span id="code"><span style="color:#444444"><span style="color:#0000FF;">VII</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">int</span>&gt;&gt;</span></span> に，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">VVVI</span></span></span>/<span id="code"><span style="color:#444444"><span style="color:#0000FF;">VIII</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">int</span>&gt;&gt;&gt;</span></span> に置き換えられます．<br><span id="code"><span style="color:#444444"><span style="color:#0000FF;">VLL</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">long</span> <span style="color:#0000FF;">long</span>&gt;</span></span> に，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">VVLL</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">long</span> <span style="color:#0000FF;">long</span>&gt;&gt;</span></span> に，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">VVVLL</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">long</span> <span style="color:#0000FF;">long</span>&gt;&gt;&gt;</span></span> に置き換えられます．<br><span id="code"><span style="color:#444444"><span style="color:#0000FF;">VS</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">string</span>&gt;</span></span> に置き換えられます．<br></p>


<h2 id="akjfopauifa097">modint型など</h2>
<p>mint型が使えます．<br>mod MDで計算します（MDは#define MD hogeで定義しなければデフォルトでは10^9+7が使用されます．MDは奇素数でなければ上手く動かない可能性があります．定数の項も参照のこと）．<br>四則演算（割り算も）は使えます．int型やll型などと計算すると結果はmint型になります．<br>mint型の法の設定などはmain関数の変数宣言後に行うので，変数宣言時に代入などすると上手く動かないので，変数宣言時に代入するのは避けたほうが良いです．<br><span id="code"><span style="color:#444444"><span style="color:#0000FF;">mint</span> x<span style="color:#000000;">;</span> x = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span> x /= <span style="color:#AA00AA;">2</span><span style="color:#000000;">;</span> wt<span style="color:#662222;">(</span>x<span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> で 500000004 が表示されます．<br>また，べき乗 pw が使えます．<br><span id="code"><span style="color:#444444"><span style="color:#0000FF;">mint</span> x, p<span style="color:#000000;">;</span> x = <span style="color:#AA00AA;">2</span><span style="color:#000000;">;</span> p = x.pw<span style="color:#662222;">(</span><span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> で p に $2^{100} \bmod (10^9+7)$ が代入されます．<br><span id="code"><span style="color:#444444"><span style="color:#0000FF;">mint</span> x<span style="color:#000000;">;</span> x.setmod<span style="color:#662222;">(</span><span style="color:#AA00AA;">1000000009</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> とすることで，途中で mod の値を変えることができます．<br>mintの詳しい仕様はそのうち書きます．<br></p>
<p>モンゴメリ乗算を使用しないmodint型もあります．<br>MDが素数でなくても，割り算をしなければmodint型は動くと思います．<br>mint型とmodint型はほぼ同じ使用方法です．<br></p>
<p>途中で mod を変更できないバージョンとして1文字目を大文字にした Mint, Modint があります．<br>こっちのほうが高速なはず．初期化も必要ないので，変数宣言時に代入しても大丈夫なはず．<br>mint, modint, Mint, Modint はコンストラクタで 0 に設定されるはずです．<br></p>



<h2 id="afjaopfa078">配列の変数宣言</h2>
<p>配列のサイズを省略し，初期化もしていない場合，直前に確保した同じ次元の配列の対応する次元サイズになります．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">1d5</span><span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, m<span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span>, C<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> x<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#441111;">]</span>, y<span style="color:#441111;">[</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> s<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#441111;">]</span>, t<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
</span></pre>
<p>は以下のようになります．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">100000</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> B<span style="color:#441111;">[</span><span style="color:#AA00AA;">100000</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> m<span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> C<span style="color:#441111;">[</span><span style="color:#AA00AA;">100000</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> x<span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> y<span style="color:#441111;">[</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> s<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> t<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
</span></pre>
<p>配列の初期化は，現状 = を明示的に書いている場合のみ初期化しているとみなします．<br>以下の例で，int y[]{1,2} と書いた場合は，int y[1d5]{1,2} と 1d5 が配列サイズとして設定されます．<br>将来的に変更される可能性があります．一般的な用途としては，一応この場合は配列サイズを省略しないのを推奨とさせてください．<br></p>



<h1 id="akjfaf0001">入出力</h1>

<h2 id="akdjfoaif73">入力</h2>
<p><strong>unlocked シリーズが使えない場合は，//no-unlocked フラグを指定してください．</strong>unlocked じゃないものを利用します．<br></p>
<p><span id="code"><span style="color:#444444">rd<span style="color:#662222;">(</span>i, j, k<span style="color:#662222;">)</span></span></span> で標準入力からi,j,kが読み込まれます．<span id="code"><span style="color:#444444"><span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d%d%d&quot;</span>,&amp;i,&amp;j,&amp;k<span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> などと似た感じですが，スペース区切りじゃなく，数字以外で区切られます．<br>rd(i, j(n), k)はrd(i, j[0], j[1], ..., j[n-1], k)に置き換わります（左から処理するのでrd(n, A(n))とか可能です）．<br>また，rd(N, (A,B)(N)) は rd(N, A[0], B[0], A[1], B[1], ..., A[N-1], B[N-1]) に置き換わります．グラフのエッジの入力とかに．<br>2次元の入力は rd(arr(3,3)) で rd(arr[0][0], arr[0][1], arr[0][2], arr[1][0], arr[1][1], arr[1][2], arr[2][0], arr[2][1], arr[2][2]) になります．3次元以上も同様．<br>rdの代わりにreaderでもOK．<br>rdは今のところint型，unsigned型，ll型，ull型，double型（指数表記は対応していない），mint型，char型（1文字），char型の配列（文字列），string型，vector&lt;T&gt;，Matrix&lt;T&gt;，Permutation，IntMap，Grid1d&lt;T&gt;，Grid2d&lt;T&gt;にのみに対応．ただし，Tは対応している型でなければならない．<b>他の型もそのうち対応</b>．<br>また，char S[1000]; int N; rd(S@N);で文字列 S を読み込むと同時に文字列の長さを N に代入します．複数の文字列の場合は char S[10][1000]; int N[10]; rd(S@N(10)); とS@Nはひとかたまりで扱います．<br>char型1文字の入力の場合も，空白などは読み飛ばして，次の空白でない文字を読み込みます．<br></p>
<p><span id="code"><span style="color:#444444">rd<span style="color:#662222;">(</span>i--<span style="color:#662222;">)</span></span></span> は <span id="code"><span style="color:#444444">rd<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span> i--<span style="color:#000000;">;</span></span></span> になります．++もできます．2減らすなら rd(i----) です．<br>rd((A--)(N)) は配列AのN個の要素すべてが1減ります．カッコは必須です．rd(A--(N)) は書けません．<br>rd((A--,B--,C)(N)) は配列A，Bの要素は1減り，Cの要素はそのままです．<br>1-originから0-originに直しながら入力するときなど．<br></p>
<p>A[2], B[4], A[3], B[5], A[4], B[6] に読み込みたい場合は rd(((A+2),(B+4))(3)); で可能です．<br>A[2], A[3], A[4] に読み込む場合は rd(((A+2))(3)); で可能です（かっこが多すぎる気がしますが，現状これだけ必要です…：(A+2)[0], (A+2)[1], (A+2)[2]でアクセスします）．<br></p>
<p>int len; char buf[100];<br>len = rdLine(buf); で1行の読み込みを行います．<br>正確には，\n か EOF に出くわすまでbufに入れていきます（\nは入らない）が，\rだけは無視されます．<br>lenには基本的に読み込んだ文字数を返しますが，1文字も読み込まずEOFに出くわした場合のみ-1を返します．<br>bufの最後の文字の次に \0 を入れて返します．<br></p>
<p>変数に代入しないものとして，以下の関数は次の入力をその型の値として戻り値で返します．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> rd_int<span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> rd_ll<span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">string</span> rd_string<span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span></span></span></li>
</ul>



<h2 id="akdjfoaif74">出力</h2>
<p>wt(i, j, k)でスペース区切りでi, j, kを標準出力に吐き出し，改行します．<br>wt(i, j(n), k)はwt(i, j[0], j[1], ..., j[n-1], k)に置き換わります．<br>また，wt(N, (A,B)(N)) は wt(N, A[0], B[0], A[1], B[1], ..., A[N-1], B[N-1]) に置き換わります．式の一部がこの形でも同様に置き換わります（以下の例を参照）．<br>最後に改行する代わりにスペースを出力する場合はwtの代わりにwtSpを，改行区切りで出力する場合はwtLnを使います．また区切りに何も出力しない場合はwtNを使います．<br>wtの代わりにwriter，wtSpの代わりにwriterSp，wtLnの代わりにwriterLnでもOK．<br>wtは今のところint型，ll型，double型，mint型，char型の配列（文字列），string型と，vector, set, multiset, pairの組合せのみに対応．<b>他の型もそのうち対応</b>．<br>wtF は引数に "" で囲まれた文字列をそのままの形でわたし（式を書けない），その文字列を出力しますが，変数名を{}で囲むと，その変数の値に置換されて出力されます．文字列中で{または}を出力したい場合はエスケープして\{または\}と書きます．<br></p>
<p>関数 wt(f(a)) は，fが変数として認識されてないと f(0), f(1), ..., f(a-1) に展開されませんが，fが変数として認識されていると展開してしまいます（特に構造体を作ってその変数fを定義している場合）．<br>配列の展開しない場合，Wt(f(a)) や Writer(f(a)) のように W を大文字にしてください．<br></p>
<p>double型の変数を wt() で出力する場合，デフォルトでは小数点以下15桁表示します．<br>10桁表示したい場合は，事前に writerDigit_double(10); としてください．<br>また，現在の表示桁数を取得する場合は，writerDigit_double(); で取得できます．<br>中身が NaN, Inf などの変数を表示させた場合，現状は Err と表示されます．<br></p>
<p>2次元以上の配列の出力は，wtLn など区切り文字を明示的に指定したものを使うと各要素がそれで区切られます．<br>wt を使った場合，配列単体を出力する場合，および，出力の最後が配列の場合は，配列の最後のインデックスに対して1行に出力されます．<br><span id="code"><span style="color:#444444">wt<span style="color:#662222;">(</span>arr<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span></span></span> の場合は，<br></p>

<pre>
arr[0][0] arr[0][1] arr[0][2]
arr[1][0] arr[1][1] arr[1][2]
</pre>
<p>となり<br><span id="code"><span style="color:#444444">wt<span style="color:#662222;">(</span>arr<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span></span></span> の場合は<br></p>

<pre>
arr[0][0][0] arr[0][0][1] arr[0][0][2]
arr[0][1][0] arr[0][1][1] arr[0][1][2]
arr[1][0][0] arr[1][0][1] arr[1][0][2]
arr[1][1][0] arr[1][1][1] arr[1][1][2]
</pre>
<p>と出力されます．最後の要素でない場合は，1行に出力されます．<br><span id="code"><span style="color:#444444">wt<span style="color:#662222;">(</span>arr<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span>, <span style="color:#00AA22;">&quot;hoge&quot;</span>, <span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span></span></span> の場合は<br></p>

<pre>
arr[0][0] arr[0][1] arr[0][2] arr[1][0] arr[1][1] arr[1][2] hoge 100
</pre>
<p>です．<br></p>
<p>また，出力に関してオプションで B=n と指定すると整数系のものは n 進数で出力されます．<br>例えば，wt[B=3]("hello", 10); は hello 101 と出力されます（文字列に関しては基数は無視されます）．<br>62進数まで指定可能で，文字は 01...9ABC...Zabc...z の順番です．<br></p>
<p>例:<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> N, A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, res<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
rd<span style="color:#662222;">(</span>N, <span style="color:#662222;">(</span>A,B<span style="color:#662222;">)</span><span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>N, <span style="color:#AA00AA;">2</span>*res<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span>+<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は以下と同じ意味になります．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> i, N, A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, res<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d&quot;</span>, &amp;N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;N<span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d%d&quot;</span>, A+i, B+i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d &quot;</span>, N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;N<span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d%c&quot;</span>, <span style="color:#AA00AA;">2</span>*res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>+<span style="color:#AA00AA;">1</span>, i==N-<span style="color:#AA00AA;">1</span>?<span style="color:#00AA22;">'\n'</span>:<span style="color:#00AA22;">' '</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>

<p>また<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> T = <span style="color:#AA00AA;">0</span>, res = <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;\{Case {++T}: {res}\}\n&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は以下と同じ意味になります．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> T = <span style="color:#AA00AA;">0</span>, res = <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
<span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;{Case %d: %d}\n&quot;</span>, ++T, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>

<p>また<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> N, L<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">char</span> S<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1000</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
rd<span style="color:#662222;">(</span>N, S@L<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は以下と同じ意味になります．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> i, N, L<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">char</span> S<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1000</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d&quot;</span>,&amp;N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;N<span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%s&quot;</span>,S<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  L<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = strlen<span style="color:#662222;">(</span>S<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>


<p>vector, set, multiset, pair については，中身の要素をスペース区切りで1行にまとめたものがひとかたまりとみなされます．<br><strong>中身が整数であっても [B=2] などで進数を指定しないでください．現状は指定しても10進数で表示し，将来的に仕様は変わる可能性があります．</strong><br>例えば，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> a = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">VI</span> b<span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> c = <span style="color:#AA00AA;">5</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>a,b,c<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;---&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wtLn<span style="color:#662222;">(</span>a,b,c<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;---&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wtLn<span style="color:#662222;">(</span>a,b<span style="color:#662222;">(</span>b.<span style="color:#000000;font-weight:bold;">size</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span>,c<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>に対する出力は<br></p>

<pre>
1 2 3 4 5
---
1
2 3 4
5
---
1
2
3
4
5
</pre>
<p>となり，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">set</span>&lt;<span style="color:#0000FF;">VS</span>&gt; s<span style="color:#000000;">;</span>
s.<span style="color:#000000;font-weight:bold;">insert</span><span style="color:#662222;">(</span><span style="color:#0000FF;">VS</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#00AA22;">&quot;hoge&quot;</span>, <span style="color:#00AA22;">&quot;piyo&quot;</span>, <span style="color:#00AA22;">&quot;hoge&quot;</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
s.<span style="color:#000000;font-weight:bold;">insert</span><span style="color:#662222;">(</span><span style="color:#0000FF;">VS</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#00AA22;">&quot;a&quot;</span>, <span style="color:#00AA22;">&quot;z&quot;</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
s.<span style="color:#000000;font-weight:bold;">insert</span><span style="color:#662222;">(</span><span style="color:#0000FF;">VS</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#00AA22;">&quot;hoge&quot;</span>, <span style="color:#00AA22;">&quot;piyo&quot;</span>, <span style="color:#00AA22;">&quot;hoge&quot;</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wtLn<span style="color:#662222;">(</span>s<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>に対する出力は<br></p>

<pre>
a z hoge piyo hoge
</pre>
<p>となり，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">multiset</span>&lt;<span style="color:#0000FF;">VS</span>&gt; s<span style="color:#000000;">;</span>
s.<span style="color:#000000;font-weight:bold;">insert</span><span style="color:#662222;">(</span><span style="color:#0000FF;">VS</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#00AA22;">&quot;hoge&quot;</span>, <span style="color:#00AA22;">&quot;piyo&quot;</span>, <span style="color:#00AA22;">&quot;hoge&quot;</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
s.<span style="color:#000000;font-weight:bold;">insert</span><span style="color:#662222;">(</span><span style="color:#0000FF;">VS</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#00AA22;">&quot;a&quot;</span>, <span style="color:#00AA22;">&quot;z&quot;</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
s.<span style="color:#000000;font-weight:bold;">insert</span><span style="color:#662222;">(</span><span style="color:#0000FF;">VS</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#00AA22;">&quot;hoge&quot;</span>, <span style="color:#00AA22;">&quot;piyo&quot;</span>, <span style="color:#00AA22;">&quot;hoge&quot;</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wtLn<span style="color:#662222;">(</span>s<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>に対する出力は<br></p>

<pre>
a z hoge piyo hoge hoge piyo hoge
</pre>
<p>となり，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">pair</span>&lt;<span style="color:#0000FF;">int</span>,<span style="color:#0000FF;">pair</span>&lt;<span style="color:#0000FF;">double</span>,<span style="color:#0000FF;">string</span>&gt;&gt; p = make_pair<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>, make_pair<span style="color:#662222;">(</span><span style="color:#AA00AA;">20.0</span>, <span style="color:#00AA22;">&quot;abc&quot;</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>p<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>に対する出力は<br></p>

<pre>
10 20.000000000000000 abc
</pre>
<p>となります．<br></p>



<h2 id="aadkjfa87">細かい注意</h2>
<p>reader(), writer() は複数の文に分割されることがあります．<br>1文に reader(), writer() が単独でなくなる場合に現状うまく動きません．<br>（とりあえずは ; で区切って単独の文にしてもらえると助かります）<br></p>

<pre><span style="color:#444444">wt<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>?<span style="color:#AA00AA;">1</span>:<span style="color:#AA00AA;">0</span><span style="color:#662222;">)</span>,wt<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>          <span style="color:#888888;">// うまく動かない
</span><span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>cond<span style="color:#662222;">)</span> a=a?a:b, wt<span style="color:#662222;">(</span>a<span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// うまく動かない
</span>wt<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span>,wt<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>              <span style="color:#888888;">// 三項演算子がないので wt(1); wt(2); となりwt単独になるので問題なく動く
</span></span></pre>



<h2 id="akdjfoaif79">ファイル入出力</h2>
<p>標準入出力ではない場合は，readerFile()，writerFile()を利用して入出力先を指定します．<br>ファイル名（勝手にfopen, fcloseされる）かファイルポインタを引数に指定します．<br></p>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i, j, k<span style="color:#000000;">;</span>

  rd<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// stdinから読み込み
</span>  readerFile<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;input.txt&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  rd<span style="color:#662222;">(</span>j<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// input.txtから読み込み
</span>  readerFile<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  rd<span style="color:#662222;">(</span>k<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// stdinから読み込み
</span>
  wt<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// stdoutに書き込み
</span>  writerFile<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;output.txt&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>j<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// output.txtに書き込み
</span>  writerFile<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;log.txt&quot;</span>, <span style="color:#00AA22;">&quot;a&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>k<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// log.txtに追加で書き込み &quot;a&quot;モードで開く
</span>  writerFile<span style="color:#662222;">(</span><span style="color:#000000;font-weight:bold;">stderr</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;hoge&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// stderrに書き込み
</span></span></pre>
<p>という感じです．<br></p>



<h2 id="akdjfoaif76">変数宣言時の入力</h2>
<p>変数を宣言した際に変数名の前に@をつけると，その時点でrd()を利用して入力します．<br>@と変数名の間，または変数名の後に++や--を書くと，読み込んだ瞬間インクリメント，デクリメントをします．<br>（<span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @++A<span style="color:#000000;">;</span></span></span> でも <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @A++<span style="color:#000000;">;</span></span></span> でも <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @++A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span></span></span> でも <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @A++<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span></span></span> でも <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>++<span style="color:#000000;">;</span></span></span> でも良いですが，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> ++@A<span style="color:#000000;">;</span></span></span> や <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @A<span style="color:#441111;">[</span>++<span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span></span></span> はやめて下さい．通常の意味の <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @A<span style="color:#441111;">[</span>N++<span style="color:#441111;">]</span><span style="color:#000000;">;</span></span></span> も避けて下さい）<br>配列の場合は，配列サイズだけ読み込みます（2次元以上の配列でも大丈夫です）．<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> @A, @B, res = <span style="color:#000000;font-weight:bold;">abs</span><span style="color:#662222;">(</span>A-B<span style="color:#662222;">)</span>/+<span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> A<span style="color:#000000;">;</span>
  rd<span style="color:#662222;">(</span>A<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> B<span style="color:#000000;">;</span>
  rd<span style="color:#662222;">(</span>B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> res = <span style="color:#000000;font-weight:bold;">abs</span><span style="color:#662222;">(</span>A-B<span style="color:#662222;">)</span>/+<span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>となります．<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> @N, @A++<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>mul<span style="color:#662222;">(</span>A<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> N<span style="color:#000000;">;</span>
  <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d&quot;</span>,&amp;N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> i<span style="color:#000000;">;</span>
  <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;N<span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d&quot;</span>,&amp;A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;N<span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>++<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> res = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;N<span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> res *= A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d\n&quot;</span>, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>の意味です．<br></p>
<p><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> @<span style="color:#662222;">(</span>A,B<span style="color:#662222;">)</span><span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span></span></span> で A[0], B[0], A[1], B[1], ... の順番で読み込みます．<br>（この書き方は @ が必須です．int (A,B)[N]; で入力を読み込まずに変数宣言だけ行うことはできません）<br>また，変数名の前に，型を書くと，その変数だけその型になります．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> @N, @<span style="color:#662222;">(</span>A,B++<span style="color:#662222;">)</span><span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> N<span style="color:#000000;">;</span>
<span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d&quot;</span>,&amp;N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> i = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span> i &lt; N<span style="color:#000000;">;</span> i++<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d%d\n&quot;</span>,A+i,B+i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  B<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>++<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>の意味となり，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> @N, @<span style="color:#662222;">(</span>A,B,<span style="color:#0000FF;">ll</span> C,D<span style="color:#662222;">)</span><span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> N<span style="color:#000000;">;</span>
<span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d&quot;</span>,&amp;N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span> <span style="color:#0000FF;">ll</span> C<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span> <span style="color:#0000FF;">int</span> D<span style="color:#441111;">[</span>N<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> i = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span> i &lt; N<span style="color:#000000;">;</span> i++<span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d%d%lld%d\n&quot;</span>,A+i,B+i,C+i,D+i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>の意味になります．<br></p>
<p>また，vector に関しては，@変数名(要素数) という形で宣言した場合に，標準入力より読み込みます．<br>例えば，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> @N<span style="color:#000000;">;</span>
<span style="color:#0000FF;">VLL</span> @<span style="color:#662222;">(</span>A,B<span style="color:#662222;">)</span><span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">VI</span> @C<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> N<span style="color:#000000;">;</span>
<span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d&quot;</span>,&amp;N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">long</span> <span style="color:#0000FF;">long</span>&gt; A<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span>, B<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> i = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span> i &lt; N<span style="color:#000000;">;</span> i++<span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%lld%lld\n&quot;</span>,&amp;A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>,&amp;B<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">int</span>&gt; C<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> i = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span> i &lt; N<span style="color:#000000;">;</span> i++<span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">scanf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d\n&quot;</span>,&amp;C<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>の意味になります．<br></p>




<h2 id="akdjfoaif75">チェック付き入力</h2>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">ll</span> cReader_ll<span style="color:#662222;">(</span><span style="color:#0000FF;">ll</span> mn, <span style="color:#0000FF;">ll</span> mx, <span style="color:#0000FF;">char</span> nx<span style="color:#662222;">)</span></span></span> : ll を読み込みます．</li>
</ul>
<p>読み込んだ値がmn以上mx以下でない場合は assert() により落ちてREになります．<br>また，値の前に余分なスペースや文字などがある場合も assert() により落ちてREになります．<br>読み込んだ直後の文字が nx でない場合も assert() により落ちてREになります（nxまで読み込んだことになり，次はnxの次の文字から読み込みます）．<br>先頭に余分な0がある場合（0038, -01，00 など），「-0」と0の前にマイナス記号が存在する場合も落ちます．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> cReader_eof<span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> : これ以上入力が続かないことを確認します．次の文字を確認してEOFでなければ assert() により落ちてREになります．</li>
</ul>
<p>入力形式が<br></p>

<pre>
N
A B C
</pre>
<p>で制約が $1 \leq N \leq 100$，$0 \leq A \leq B \leq C \leq 10^9$ の場合は<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">ll</span> N, A, B, C<span style="color:#000000;">;</span>
N = cReader_ll<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">100</span>, <span style="color:#00AA22;">'\n'</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
A = cReader_ll<span style="color:#662222;">(</span><span style="color:#AA00AA;">0</span>, <span style="color:#AA00AA;">1d9</span>, <span style="color:#00AA22;">' '</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
B = cReader_ll<span style="color:#662222;">(</span>A, <span style="color:#AA00AA;">1d9</span>, <span style="color:#00AA22;">' '</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
C = cReader_ll<span style="color:#662222;">(</span>B, <span style="color:#AA00AA;">1d9</span>, <span style="color:#00AA22;">'\n'</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
cReader_eof<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>などで入力形式等が正しいかチェックしながら読み込むことができます．<br></p>




<h1 id="akjfaf0002">ループ</h1>


<h1 id="akjfaf0003">演算子</h1>


<h1 id="akjfaf0004">グラフ</h1>



<h1 id="akjfaf0005">データ構造</h1>

<h2 id="afkapf890">UnionFind (UF, Disjoint Set Union, USU)</h2>

<p>unionFind構造体．<span id="code"><span style="color:#444444"><span style="color:#0000FF;">unionFind</span> uf<span style="color:#000000;">;</span></span></span> で宣言したとして以下の通り．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">unionFind</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> : コンストラクタ．何もしない．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">unionFind</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">char</span> mode, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n, <span style="color:#0000FF;">void</span> **mem = &amp;wmem<span style="color:#662222;">)</span></span></span> : コンストラクタ．mode='m'の場合は以下の malloc(n) を，mode='w'の場合は以下の walloc(n, mem) を呼び出します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">unionFind</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">char</span> mode, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> fg, <span style="color:#0000FF;">void</span> **mem = &amp;wmem<span style="color:#662222;">)</span></span></span> : コンストラクタ．mode='m'の場合は以下の malloc(n, fg) を，mode='w'の場合は以下の walloc(n, fg, mem) を呼び出します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.<span style="color:#000000;font-weight:bold;">malloc</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n<span style="color:#662222;">)</span></span></span>: メモリ確保</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.<span style="color:#000000;font-weight:bold;">malloc</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> fg<span style="color:#662222;">)</span></span></span>: メモリ確保．fgが0でなければnノードで初期化する</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.<span style="color:#000000;font-weight:bold;">free</span><span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span></span></span>: mallocで確保したメモリの解放</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.walloc<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n, <span style="color:#0000FF;">void</span> **mem=&amp;wmem<span style="color:#662222;">)</span></span></span>: メモリ確保</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.walloc<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> fg, <span style="color:#0000FF;">void</span> **mem=&amp;wmem<span style="color:#662222;">)</span></span></span>: メモリ確保．fgが0でなければnノードで初期化する</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.init<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n<span style="color:#662222;">)</span></span></span>: 初期化</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.init<span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span></span></span>: 確保したメモリの要素数で初期化</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.get<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a<span style="color:#662222;">)</span></span></span>: ノードaの一番親のノードを返す（uf.get(a)==uf.get(b)ならa,bは同じグループに属す）</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.connect<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a, <span style="color:#0000FF;">int</span> b<span style="color:#662222;">)</span></span></span>: aとbを同じグループにまとめる．aとbが既に同じグループなら0を返し，そうでなければ1を返す</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.operator<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a<span style="color:#662222;">)</span></span></span>: get(a)と同じ</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.operator<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a, <span style="color:#0000FF;">int</span> b<span style="color:#662222;">)</span></span></span>: connect(a,b)と同じ</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.<span style="color:#000000;font-weight:bold;">size</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a<span style="color:#662222;">)</span></span></span>: ノードaが属すグループのノード数を返す</li>
</ul>
<p>以下あまり使わないやつ<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span>&amp; uf.operator<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> a<span style="color:#662222;">)</span></span></span>: 内部の配列の値</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.sizeList<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> res<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span></span></span>: 各グループのサイズからなる配列を返す．返り値はグループ数．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.comp<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> res<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span>: 属すグループの配列 arr[i] = uf(i) を座標圧縮した結果の配列 res を求めます．グループ数の数 = max(res)+1 を返します．</li>
</ul>

<HR>

<p>weightedUnionFind 構造体．いわゆる重み付きUnionFind．<br><span id="code"><span style="color:#444444"><span style="color:#0000FF;">weightedUnionFind</span>&lt;T&gt; uf<span style="color:#000000;">;</span></span></span> で宣言したとして以下の通り．<br>unionFindとの差分のみを記述．connectの使い方が違うのと，diffが追加されています．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.connect<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a, <span style="color:#0000FF;">int</span> b, T c<span style="color:#662222;">)</span></span></span>: aとbを同じグループにまとめ weight[b]-weight[a]=cと設定します．aとbが既に同じグループなら何も処理せず0を返し，そうでなければ1を返す</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.operator<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a, <span style="color:#0000FF;">int</span> b, T c<span style="color:#662222;">)</span></span></span>: connect(a,b,c)と同じ</li>
<li><span id="code"><span style="color:#444444">T uf.diff<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a, <span style="color:#0000FF;">int</span> b<span style="color:#662222;">)</span></span></span>: weight[b]-weight[a]を返す．ただし，a,bが同じグループでなければ何を返すか不定です．</li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">weightedUnionFind</span>&lt;<span style="color:#0000FF;">ll</span>&gt; uf<span style="color:#662222;">(</span><span style="color:#00AA22;">'w'</span>,<span style="color:#AA00AA;">100</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
uf<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">70</span>,<span style="color:#AA00AA;">1000LL</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
uf<span style="color:#662222;">(</span><span style="color:#AA00AA;">70</span>,<span style="color:#AA00AA;">90</span>,<span style="color:#AA00AA;">2000LL</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>uf<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span>==uf<span style="color:#662222;">(</span><span style="color:#AA00AA;">90</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;connected&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>uf.diff<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">90</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 3000
</span><span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<HR>

<p>rollbackUnionFind 構造体．<span id="code"><span style="color:#444444"><span style="color:#0000FF;">rollbackUnionFind</span> uf<span style="color:#000000;">;</span></span></span> で宣言したとして以下の通り．<br>ただし，unionFindで使えるものは全てそのまま使える．<br>経路圧縮をしないので，一部の計算量はアッカーマン逆関数からlogになっている．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.snapshot<span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> : スナップショットを撮る（1回もスナップショットを撮ってなければスナップショットは初期値の状況）</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> uf.rollback<span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> : 最後にスナップショットを撮ったところまで巻き戻す</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> uf.undo<span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> : connectなどで最後に非連結で繋げた枝を消す（connectの戻り値が0のものはカウントしない）．スナップショットを撮ったより過去に戻った場合はスナップショットは壊れるかもしれない（現時点では，戻ったときの状態が新しくスナップショットになる）．</li>
</ul>





<h1 id="akjfaf0006">整数</h1>


<h2 id="akddj8712">桁・n進数</h2>

<p>配列の最初の要素が一番小さい桁に対応します（i番目の要素が10^iに対応，など）．<br>最後に_rがついている関数に関しては，逆に配列の最初の要素が一番大きい桁に対応します（数値を文字列として読み込んだ場合に対応，など）．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> Digit<span style="color:#662222;">(</span>T n<span style="color:#662222;">)</span></span></span> : 正の整数nを10進数で書いたときの桁数を返す（0に対しては現状0を返す）</li>
<li>template&lt;class T, class S&gt; inline int Digit(T n, S b) : 正の整数nをb進数で書いたときの桁数を返す</li>
<li>template&lt;class T, class S&gt; inline int Digit(T n, S res[]) : 戻り値として正の整数nを10進数で書いたときの桁数を返し，res[i]に10^iの桁の数値を代入する</li>
<li>template&lt;class T, class S, class U&gt; inline int Digit(T n, S res[], U b) : 戻り値として正の整数nをb進数で書いたときの桁数を返し，res[i]にb^iの桁の数値を代入する</li>
<li>template&lt;class T, class S&gt; inline void DigitF(T n, int sz, S res[]) : nを10進数で書いたときの下sz桁を返す．sz桁未満の場合は0で埋める．</li>
<li>template&lt;class T, class S, class U&gt; inline void DigitF(T n, int sz, S res[], U b) : nをb進数で書いたときの下sz桁を返す．sz桁未満の場合は0で埋める．</li>
<li>template&lt;class T&gt; inline T invDigit(int sz, T d[]) : sz桁の10進数d[]の値を返します．sz=4, d[]={4,6,1,0}のとき164を返す．</li>
<li>template&lt;class T&gt; inline T invDigit_r(int sz, T d[]) : sz桁の10進数d[]の値を返します．sz=4, d[]={4,6,1,0}のとき4610を返す．</li>
<li>template&lt;class T, class S&gt; inline T invDigit(int sz, T d[], S b) : sz桁のb進数d[]の値を返します．</li>
<li>template&lt;class T&gt; inline int sod(T n) : nを10進数で書いたときの各桁の和を返す</li>
<li>template&lt;class T, class S&gt; inline S sod(T n, S b) : nをb進数で書いたときの各桁の和を返す</li>
<li>b[t](a,b,c)：t進数でabcの値を表す．これは (((a)*(t)+(b))*(t)+(c)) に展開されます．</li>
<li>b[x,y](a,b,c,d)：((a*x+b)*x+c)*y+d を表す．[]および()の中の引数の数は任意．下の桁から y,x,x,x,... パターンの数を取るような進数を考えている感じ．</li>
<li>template&lt;class T&gt; inline T prodDigits(T n) : nを10進数で書いたときの各桁の積を返す．n=0のときは0を返す．</li>
<li>template&lt;class T, class S&gt; inline int DigitHist(T n, S res[]) : 正の整数nを10進数で書いたときの桁数を返し，「res[i] = 数字iが登場する回数（i=0,1,...,9）」を代入する．</li>
</ul>

<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> isPalindromicNumber<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n<span style="color:#662222;">)</span></span></span> : nが回文数なら1を，そうでないなら0を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> isPalindromicNumber<span style="color:#662222;">(</span><span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : nが回文数なら1を，そうでないなら0を返す．</li>
<li><span id="code"><span style="color:#444444">__int128_t kthPalindromicNumber64<span style="color:#662222;">(</span><span style="color:#0000FF;">ll</span> k<span style="color:#662222;">)</span></span></span> : k番目の回文数を返す．0番目は0，1番目は1，7番目は7，10番目は11，11番目は22．$O(\log k)$ 時間程度．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">ll</span> reverseNumber<span style="color:#662222;">(</span><span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : 桁をひっくり返した数を返す．613なら316を，780なら87を返す．</li>
</ul>

<HR>

<ul><li>inline int STR2int(string s, const int b) : s が表す文字列をb進数の値と見て，その値を int 型で返す．文字は0..9A..Za..zの順で62進数まで．マイナスもOKだけど普通の書き方以外は対応してない．</li>
<li>inline int STR2int(string s) : s が表す文字列を10進数の値と見て，その値を int 型で返す．</li>
<li>inline ll STR2ll(string s, const int b) : s が表す文字列をb進数の値と見て，その値を ll 型で返す．文字は0..9A..Za..zの順で62進数まで．</li>
<li>inline ll STR2ll(string s) : s が表す文字列を10進数の値と見て，その値を ll 型で返す．</li>
</ul>




<h2 id="akjfaf1231">ルートとk乗根</h2>

<p>どれもllの最大値に近いとうまく動かない可能性がある（4*10^18ぐらいまでを目安に）．<br>整数の平方根．（ただし n として ll でオーバーフロー直前みたいなのを引数に与えると動かない可能性が高い）<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Isqrt_f<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$\lfloor \sqrt{n} \rfloor$ の値（$n$の平方根，小数点以下切り捨て）を返す．f は floor のつもり．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Isqrt_c<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$\lceil \sqrt{n} \rceil$ の値（$n$の平方根，小数点以下切り上げ）を返す．c は ceil のつもり．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Isqrt_s<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$x^2 = n$ なる非負整数 x の値を返す．ただし，存在しないなら -1 を返す．s は strict のつもり．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Isqrt<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : Isqrt_f と同じ．</li>
</ul>
<p>整数の立方根．<br>現在は非負整数のみに対応だが，将来的に負の整数に対応する可能性がある．その場合，Icbrt_s(-8) などは答えが変わる可能性があるので注意．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Icbrt_f<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$\lfloor \sqrt[3]{n} \rfloor$ の値（$n$の平方根，小数点以下切り捨て）を返す．f は floor のつもり．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Icbrt_c<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$\lceil \sqrt[3]{n} \rceil$ の値（$n$の平方根，小数点以下切り上げ）を返す．c は ceil のつもり．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Icbrt_s<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$x^3 = n$ なる非負整数 x の値を返す．ただし，存在しないなら -1 を返す．s は strict のつもり．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Icbrt<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : Icbrt_f と同じ．</li>
</ul>
<p>整数のk乗根．<br>現在は非負整数のみに対応だが，将来的に負の整数に対応する可能性がある．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Iroot_f<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> k<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$\lfloor \sqrt[k]{n} \rfloor$ の値を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Iroot_c<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> k<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$\lceil \sqrt[k]{n} \rceil$ の値を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Iroot_s<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> k<span style="color:#662222;">)</span></span></span> : 非負整数 n に対して，$x^k = n$ なる非負整数 x の値を返す．ただし，存在しないなら -1 を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">ll</span> Iroot<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> k<span style="color:#662222;">)</span></span></span> : Iroot_f と同じ．</li>
</ul>


<h2 id="akjfaf1235">log2</h2>

<p>整数のlog2．<br>内部で __builtin_clz や __builtin_ffs 系列の関数を使用しています．GCC系以外では動かないかもしれません．<br>入力が 0 以下なら -1 を返します．<br>Ilog2の最初の文字は大文字のアイ，2文字目は小文字のエルです．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> Ilog2_f<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n<span style="color:#662222;">)</span></span></span> : $\lfloor \log_2 n \rfloor$ を返します．最も1の上の桁の場所を返す（一番下の桁を0桁目のカウントして）．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> Ilog2_f<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : $\lfloor \log_2 n \rfloor$ を返します．最も1の上の桁の場所を返す（一番下の桁を0桁目のカウントして）．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> Ilog2_c<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n<span style="color:#662222;">)</span></span></span> : $\lceil \log_2 n \rceil$ を返します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> Ilog2_c<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : $\lceil \log_2 n \rceil$ を返します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> Ilog2_s<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> n<span style="color:#662222;">)</span></span></span> : $\log_2 n$ が整数ならその値を返します．整数でないなら -1 を返します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span> Ilog2_s<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> n<span style="color:#662222;">)</span></span></span> : $\log_2 n$ が整数ならその値を返します．整数でないなら -1 を返します．</li>
</ul>



<h2 id="akjgbf1235">ビット</h2>

<p>ビットに関すること．<br></p>
<ul><li><span id="code"><span style="color:#444444">BIT_Ith<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span></span></span> : (1LL&lt;&lt;(i)) に展開されます．</li>
<li><span id="code"><span style="color:#444444">BIT_Ith<span style="color:#662222;">(</span>i,j<span style="color:#662222;">)</span></span></span> : (((i)>>(j))&1) に展開されます．j ビット目が立ってれば 1，そうでなければ 0．</li>
<li><span id="code"><span style="color:#444444">BIT_ith<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span></span></span> : (1&lt;&lt;(i)) に展開されます．ただし，iが（変数ではなくベタな）整数で31以上の場合は (1LL&lt;&lt;(i)) に展開します．</li>
<li><span id="code"><span style="color:#444444">BIT_ith<span style="color:#662222;">(</span>i,j<span style="color:#662222;">)</span></span></span> : ((i)&amp;(1&lt;&lt;(j))) に展開されます．ただし，jが（変数ではなくベタな）整数で31以上の場合は ((i)&amp;(1LL&lt;&lt;(j))) に展開します．iのjビット目を取り出す．</li>
<li>BIT_lowest(i) : (-(i) &amp; (i)) に展開されます．一番下のビットのみ残ります．i=22=2+4+16 なら BIT_lowest(i) は 2 になります．</li>
<li>BIT_nonlowest(i) : ((i) &amp; ((i)-1)) に展開されます．一番下のビットのみ消えます．i=22=2+4+16 なら BIT_nonlowest(i) は 20 (4+16) になります．</li>
<li>inline int BIT_popcount(const int x) : __builtin_popcount(x) の値を返します．1のビットの個数．現状，gcc以外のコンパイラだと多分動かないので注意．</li>
<li>inline int BIT_popcount(const ll x) : __builtin_popcountll(x) の値を返します．1のビットの個数．現状，gcc以外のコンパイラだと多分動かないので注意．</li>
<li>inline int BIT_ctz(const int x) : __builtin_ctz(x) の値を返します．下何桁のビットが0なのか．現状，gcc以外のコンパイラだと多分動かないので注意．</li>
<li>inline int BIT_ctz(const ll x) : __builtin_ctzll(x) の値を返します．下何桁のビットが0なのか．現状，gcc以外のコンパイラだと多分動かないので注意．</li>
<li>inline int BIT_parity(const int x) : __builtin_parity(x)</li>
<li>inline int BIT_parity(const ll x) : __builtin_parityll(x)</li>
<li>inline int BIT_parity_pm(const int x) : 1 - 2 * __builtin_parity(x)．1のビットの個数が偶数個なら1，奇数個なら-1を返します．</li>
<li>inline int BIT_parity_pm(const ll x) : 1 - 2 * __builtin_parityll(x)．</li>
</ul>


<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> arr2bit_int<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> T base = <span style="color:#AA00AA;">0</span><span style="color:#662222;">)</span></span></span> : (A[i] - base) ビット目が全部立ってる int 型の整数を返します．(1 << (A[0] - base)) | (1 << (A[1] - base)) | ... | (1 << (A[N-1] - base))．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> arr2bit_int<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> S, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">char</span> base = <span style="color:#AA00AA;">0</span><span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">ll</span> arr2bit_ll<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> T base = <span style="color:#AA00AA;">0</span><span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">ll</span> arr2bit_ll<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> S, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">char</span> base = <span style="color:#AA00AA;">0</span><span style="color:#662222;">)</span></span></span></li>
</ul>


<h1 id="akjfaf0007">幾何</h1>


<h1 id="akjfaf0008">行列</h1>


<h1 id="akjfaf0009">配列</h1>


<h2 id="ayjfafddaa">ソート（配列）</h2>

<p>配列に関するソート．<br>状況に応じてバケツソート・基数ソート・イントロソートなどを使い分けます．<br>変な不都合が出る場合などは，単純にイントロソート（srd::sortを使う）をする sortI() を使ってください．<br>現状は，配列の数が3以上になると，イントロソートのみを試します．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortA<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, S A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, T B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, ..., <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 要素数Nの1個～4個の配列を (A[i], B[i], ...) が辞書式順序で小さい順にソートします．ワーキングメモリを使用します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortA_index<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, S A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, T B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, ..., <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : sortAのどの要素がどこに移動したかも求めるバージョン．一番最後に指定した配列に対して z[i]=i を代入してから sortA を行います．配列数（zも含む）は2～4．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> rsortA<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, S A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, T B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, ..., <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 要素数Nの1個～4個の配列を (A[i], B[i], ...) が辞書式順序で大きい順にソートします．ワーキングメモリを使用します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortV<span style="color:#662222;">(</span><span style="color:#0000FF;">vector</span>&lt;S&gt; &amp;A, <span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;B, ..., <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 同じ要素数の1個～4個のvectorを (A[i], B[i], ...) が辞書式順序で小さい順にソートします．ワーキングメモリを使用します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> rsortV<span style="color:#662222;">(</span><span style="color:#0000FF;">vector</span>&lt;S&gt; &amp;A, <span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;B, ..., <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 同じ要素数の1個～4個のvectorを (A[i], B[i], ...) が辞書式順序で大きい順にソートします．ワーキングメモリを使用します．</li>
</ul>
<p>以下は古いもの・あまり使わないもの．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortI<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, S A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, T B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, ..., <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 要素数Nの1個～4個の配列を (A[i], B[i], ...) が辞書式順序で小さい順にソートします．ワーキングメモリを使用します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortF<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">unsigned</span> A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 基数ソートする．ただしNが256未満ならばstd::sortでソートする．こっちの方が速い気がするけど，環境・入力依存．配列の要素が大幅偏っているとstd::sortに負けるかも．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortF<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 基数ソートする．ただしNが256未満ならばstd::sortでソートする．こっちの方が速い気がするけど，環境・入力依存．配列の要素が大幅偏っているとstd::sortに負けるかも．大体大丈夫だと思うけどもしかしたら正常に動かない環境があるかも．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortF<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">ull</span> A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 基数ソートする．ただしNが512未満ならばstd::sortでソートする．こっちの方が速い気がするけど，環境・入力依存．配列の要素が大幅偏っているとstd::sortに負けるかも．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> sortF<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">ll</span> A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 基数ソートする．ただしNが512未満ならばstd::sortでソートする．こっちの方が速い気がするけど，環境・入力依存．配列の要素が大幅偏っているとstd::sortに負けるかも．大体大丈夫だと思うけどもしかしたら正常に動かない環境があるかも．</li>
</ul>
<p>ここまで（以下は古いもの・あまり使わないもの）<br></p>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i<span style="color:#000000;">;</span>                               <span style="color:#888888;">// (1,2)      ←出力結果
</span>  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">5</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">2</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>              <span style="color:#888888;">// (2,5)
</span>  <span style="color:#0000FF;">int</span> B<span style="color:#441111;">[</span><span style="color:#AA00AA;">5</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">5</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>              <span style="color:#888888;">// (3,1)
</span>  sortA<span style="color:#662222;">(</span><span style="color:#AA00AA;">5</span>,A,B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>                        <span style="color:#888888;">// (3,3)
</span>  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span> wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;({A[i]},{B[i]})\n&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// (5,4)
</span></span></pre>


<h2 id="ayjfafddab">ソート（変数）</h2>
<ul><li>sortE(a, b, c, ...) : バブルソートで昇順にするコードに展開します．現状 a, b, c, ... は全て同じ型でないと動きません．</li>
<li>rsortE(a, b, c, ...) : バブルソートで降順にするコードに展開します．現状 a, b, c, ... は全て同じ型でないと動きません．</li>
</ul>



<h2 id="ayjfaf001a">主に1つの配列に関する処理</h2>
<p>スライス<br>添字が bg から ed まで step 飛ばしで 配列 A の要素を拾ってできる配列を返す求める．<br>A[bg], A[bg + step], A[bg + 2*step], A[bg + 3*step], ..., A[bg + (len-1)*step] みたいなのを返す．<br>step が正なら，bg 以上 ed 未満の添字からなる<br>step が負なら，bg 以下 ed より大きい添字からなる<br>N を配列Aの長さとして，添字が 0 以上 N 未満でなければ，A は循環していると思って A[ind] = A[ind mod N] みたいに思う<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> Slice<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> bg, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> ed, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> step, S res<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span></span></span> : 結果は配列 res に格納．戻り値は res の長さ</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">vector</span>&lt;T&gt; Slice<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;A, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> bg, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> ed, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> step<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">string</span> Slice<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;A, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> bg, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> ed, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">ll</span> step<span style="color:#662222;">)</span></span></span></li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> N = <span style="color:#AA00AA;">10</span>, A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">6</span>,<span style="color:#AA00AA;">7</span>,<span style="color:#AA00AA;">8</span>,<span style="color:#AA00AA;">9</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> len, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">20</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>

len = Slice<span style="color:#662222;">(</span>N,A,<span style="color:#AA00AA;">0</span>,2N,<span style="color:#AA00AA;">1</span>,B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>len, <span style="color:#00AA22;">&quot;:&quot;</span>, B<span style="color:#662222;">(</span>len<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

len = Slice<span style="color:#662222;">(</span>N,A,<span style="color:#AA00AA;">10000000000005LL</span>,<span style="color:#AA00AA;">10000000000010LL</span>,<span style="color:#AA00AA;">2</span>,B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>len, <span style="color:#00AA22;">&quot;:&quot;</span>, B<span style="color:#662222;">(</span>len<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

len = Slice<span style="color:#662222;">(</span>N,A,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">-1</span>,B<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// including A[5], excluding A[0]
</span>wt<span style="color:#662222;">(</span>len, <span style="color:#00AA22;">&quot;:&quot;</span>, B<span style="color:#662222;">(</span>len<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

len = Slice<span style="color:#662222;">(</span>N,A,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">-40</span>,<span style="color:#AA00AA;">-13</span>,B<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// (A[3], A[-10], A[-23], A[-36]) = (A[3], A[0], A[7], A[3])
</span>wt<span style="color:#662222;">(</span>len, <span style="color:#00AA22;">&quot;:&quot;</span>, B<span style="color:#662222;">(</span>len<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

len = Slice<span style="color:#662222;">(</span>N,A,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">-1</span>,B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>len, <span style="color:#00AA22;">&quot;:&quot;</span>, B<span style="color:#662222;">(</span>len<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>&lt;MYFORMAT_TEX_BR&gt;

<span style="color:#888888;">/*
20 : 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
3 : 5 7 9
5 : 5 4 3 2 1
4 : 3 0 7 4
0 : 
*/</span>
</span></pre>

<p>配列のシフト<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> arrRot<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> k, <span style="color:#0000FF;">int</span> N, T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, T B<span style="color:#441111;">[</span><span style="color:#441111;">]</span> = <span style="color:#000000;font-weight:bold;">NULL</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 長さNの配列Aに対して，B[i] = A[(i+k)%N] なる配列Bを計算する．B=NULLのときはAに上書きする．（左にkだけシフトします．先頭の要素を最後にくっつける操作をk回やる感じ．）kはN以上だったりマイナスでも大丈夫なはずです．</li>
</ul>



<h2 id="ayjfaf001b">主に1つの配列に関する計算</h2>

<p>相異なる要素数をカウントする<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> Distinct<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> sorted=<span style="color:#AA00AA;">0</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 要素数 N の配列 A[] 中の，相異なる要素の数を返します．O(N log N) 時間，ソート済みなら O(N) 時間．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> Distinct<span style="color:#662222;">(</span><span style="color:#0000FF;">vector</span>&lt;T&gt; A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> sorted=<span style="color:#AA00AA;">0</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span></li>
<li>template&lt;class T1, class T2&gt; inline int DistinctE(T1 a, T2 b) : a, b の中で異なる要素数を返します．</li>
<li>template&lt;class T1, class T2, class T3&gt; inline int DistinctE(T1 a, T2 b, T3 c) : a, b, c の中で異なる要素数を返します．</li>
<li>template&lt;class T1, class T2, class T3, class T4&gt; inline int DistinctE(T1 a, T2 b, T3 c, T4 d) : a, b, c, d の中で異なる要素数を返します．</li>
</ul>
<p>とある要素の数をカウントする<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> Count<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span> / <span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> arrCountVal<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span> : 要素数 N の配列 A[] 中の val と一致する要素数を返します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> Count<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;A, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span> / <span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> arrCountVal<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;A, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> Count<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;A, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span> / <span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> arrCountVal<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;A, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span></li>
</ul>
<p>とある要素が連続する最大長さを求める<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> arrCountValSeqMax<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span> : 要素数 N の配列 A[] 中の val が連続して登場する最大の長さを返します．登場しないなら0を返します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> arrCountValSeqMax<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> A, <span style="color:#4444FF;">const</span> S val<span style="color:#662222;">)</span></span></span></li>
</ul>
<p>回文にするのに変えないといけない要素数<br>A[i] != A[N-1-i] の数を数える（i=0,1,...,N/2-1）<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> PalindromeCost<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> PalindromeCost<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T&gt; A<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> PalindromeCost<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> A<span style="color:#662222;">)</span></span></span></li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">string</span> str1 = <span style="color:#00AA22;">&quot;aabbcc&quot;</span>, str2 = <span style="color:#00AA22;">&quot;abcbd&quot;</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>PalindromeCost<span style="color:#662222;">(</span>str1<span style="color:#662222;">)</span>, PalindromeCost<span style="color:#662222;">(</span>str2<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// 2 1
</span>
<span style="color:#0000FF;">string</span> str = <span style="color:#00AA22;">&quot;aabbaa&quot;</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">1</span>,str.<span style="color:#000000;font-weight:bold;">size</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span>+<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> wt<span style="color:#662222;">(</span>i, <span style="color:#00AA22;">&quot;:&quot;</span>, PalindromeCost<span style="color:#662222;">(</span>str.substr<span style="color:#662222;">(</span><span style="color:#AA00AA;">0</span>,i<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// 1 : 0 (a)
</span><span style="color:#888888;">// 2 : 0 (aa)
</span><span style="color:#888888;">// 3 : 1 (aab)
</span><span style="color:#888888;">// 4 : 2 (aabb)
</span><span style="color:#888888;">// 5 : 1 (aabba)
</span><span style="color:#888888;">// 6 : 0 (aabbaa)
</span></span></pre>

<p>Mex<br></p>
<ul><li>template&lt;class T&gt; int Mex(int N, T A[], int sorted=0, void *mem = wmem) : 要素数 N の配列 A[] の mex を返します．つまり，非負整数で配列 A[] に存在しない最小の値を返します．</li>
<li>template&lt;class T1&gt; inline int Mex(T1 a) : Mex(1, {a})</li>
<li>template&lt;class T1, class T2&gt; inline int Mex(T1 a, T2 b) : Mex(2, {a, b})</li>
<li>template&lt;class T1, class T2, class T3&gt; inline int Mex(T1 a, T2 b, T3 c) : Mex(3, {a, b, c})</li>
</ul>
<p>K番目の要素<br></p>
<ul><li>template&lt;class T1, class T2&gt; inline T1 Kth0(const T1 a, const T2 b) : a, b の中で小さい方（0-originで小さい方から0番目）を返す．</li>
<li>template&lt;class T1, class T2&gt; inline T1 Kth1(const T1 a, const T2 b) : a, b の中で大きい方（0-originで小さい方から1番目）を返す．</li>
<li>template&lt;class T1, class T2, class T3&gt; inline T1 Kth0(const T1 a, const T2 b, const T3 c) : a, b, c の中で最も小さいもの（0-originで小さい方から0番目）を返す．</li>
<li>template&lt;class T1, class T2, class T3&gt; inline T1 Kth1(const T1 a, const T2 b, const T3 c) : a, b, c の中で中央値（0-originで小さい方から1番目）を返す．clamp．</li>
<li>template&lt;class T1, class T2, class T3&gt; inline T1 Kth2(const T1 a, const T2 b, const T3 c) : a, b, c の中で最も大きいもの（0-originで小さい方から2番目）を返す．</li>
<li>template&lt;class T1, class T2, class T3, class T4&gt; inline T1 Kth0(const T1 a, const T2 b, const T3 c, const T4 d) : a, b, c, d の中で0-originで小さい方から0番目を返す．</li>
<li>template&lt;class T1, class T2, class T3, class T4&gt; inline T1 Kth1(const T1 a, const T2 b, const T3 c, const T4 d) : a, b, c, d の中で0-originで小さい方から1番目を返す．</li>
<li>template&lt;class T1, class T2, class T3, class T4&gt; inline T1 Kth2(const T1 a, const T2 b, const T3 c, const T4 d) : a, b, c, d の中で0-originで小さい方から2番目を返す．</li>
<li>template&lt;class T1, class T2, class T3, class T4&gt; inline T1 Kth3(const T1 a, const T2 b, const T3 c, const T4 d) : a, b, c, d の中で0-originで小さい方から3番目を返す．</li>
<li>template&lt;class T&gt; inline T KthA(const int K, const int N, const T A[], void *mem = wmem) : 長さ N の配列 A[] の中で 0-origin で小さい方から K 番目の値を返す．配列A[]を破壊しない．内部でnth_elementを使用．</li>
</ul>



<h2 id="ayjfaf002a">主に2つの配列に関する処理</h2>

<p>ソートしながらマージする（マージソートのマージ）<br></p>
<ul><li>template&lt;class T1, class T2, class T3&gt; int arrMerge(int As, T1 A[], int Bs, T2 B[], T3 res[]) : 配列A[], B[]はソート済み．配列AとBを繋げてソート済みにした配列res[]を求める．戻り値はresの配列のサイズAs+Bs．</li>
<li>template&lt;class T1, class T2, class T3&gt; int arrMergeD(int As, T1 A[], int Bs, T2 B[], T3 res[]) : 配列A[], B[]はソート済み．配列AとBを重複を除きマージしてソートした配列res[]を求める．厳密には要素xについて配列Aにi個，配列Bにj個ある場合，配列resの中にはmin(i,j)個になる．戻り値はresの配列のサイズ．</li>
</ul>
<p>マージテク（要素数が小さい方だけ移動させることで計算量を削減するテクニック）のマージ<br>AにBの要素を追加して，Bを空にする（並び順はどうなるか不明）<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> MergeTech<span style="color:#662222;">(</span><span style="color:#0000FF;">set</span>&lt;T&gt; &amp;A, <span style="color:#0000FF;">set</span>&lt;T&gt; &amp;B<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> MergeTech<span style="color:#662222;">(</span><span style="color:#0000FF;">multiset</span>&lt;T&gt; &amp;A, <span style="color:#0000FF;">multiset</span>&lt;T&gt; &amp;B<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> MergeTech<span style="color:#662222;">(</span><span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;A, <span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;B<span style="color:#662222;">)</span></span></span></li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">set</span>&lt;<span style="color:#0000FF;">int</span>&gt; a1<span style="color:#662222;">(</span> <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">6</span><span style="color:#440000;font-weight:bold;">}</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">set</span>&lt;<span style="color:#0000FF;">int</span>&gt; b1<span style="color:#662222;">(</span> <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">8</span>,<span style="color:#AA00AA;">16</span><span style="color:#440000;font-weight:bold;">}</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span>

MergeTech<span style="color:#662222;">(</span>a1,b1<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>a1<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 1 2 3 4 5 6 8 16
</span>wt<span style="color:#662222;">(</span>b1<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// none
</span>
<span style="color:#0000FF;">multiset</span>&lt;<span style="color:#0000FF;">int</span>&gt; a2<span style="color:#662222;">(</span> <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">6</span><span style="color:#440000;font-weight:bold;">}</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">multiset</span>&lt;<span style="color:#0000FF;">int</span>&gt; b2<span style="color:#662222;">(</span> <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">8</span>,<span style="color:#AA00AA;">16</span><span style="color:#440000;font-weight:bold;">}</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span>

MergeTech<span style="color:#662222;">(</span>a2,b2<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>a2<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 1 2 3 4 4 5 6 8 16
</span>wt<span style="color:#662222;">(</span>b2<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// none
</span>
<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">int</span>&gt; a3<span style="color:#662222;">(</span> <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">6</span><span style="color:#440000;font-weight:bold;">}</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">vector</span>&lt;<span style="color:#0000FF;">int</span>&gt; b3<span style="color:#662222;">(</span> <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">8</span>,<span style="color:#AA00AA;">16</span><span style="color:#440000;font-weight:bold;">}</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span>

MergeTech<span style="color:#662222;">(</span>a3,b3<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>a3<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 1 2 4 8 16 3 4 5 6
</span>wt<span style="color:#662222;">(</span>b3<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// none
</span></span></pre>


<h2 id="ayjfaf002b">主に2つの配列に関する計算</h2>

<p>比較<br></p>
<ul><li>template&lt;class S, class T&gt; inline int arrcmp(int As, S A[], int Bs, T B[]) : 長さAsの配列Aと長さBsの配列Bを辞書順で大小比較します．A &gt; B なら 1，A = B なら 0，A &lt; B なら -1 を返します（strcmp的な感じ）．</li>
</ul>
<p>ワイルドカード文字がある場合の一致判定<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> WildEQ<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;A, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;B, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">char</span> wc<span style="color:#662222;">)</span></span></span> : 文字wcは自由な1文字に変更可能として，文字列AとBが一致させることができるならば 1，そうでないなら 0 を返します</li>
</ul>
<p><pre><span style="color:#444444"><span style="color:#0000FF;">string</span> a = <span style="color:#00AA22;">&quot;at**der&quot;</span><span style="color:#000000;">;</span><br><span style="color:#0000FF;">string</span> b = <span style="color:#00AA22;">&quot;a**oder&quot;</span><span style="color:#000000;">;</span><br><span style="color:#0000FF;">string</span> c = <span style="color:#00AA22;">&quot;c******&quot;</span><span style="color:#000000;">;</span><br><span style="color:#0000FF;">string</span> d = <span style="color:#00AA22;">&quot;******&quot;</span><span style="color:#000000;">;</span><br></p>
<p>wt<span style="color:#662222;">(</span> WildEQ<span style="color:#662222;">(</span>a,b,<span style="color:#00AA22;">'*'</span><span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 1<br></span>wt<span style="color:#662222;">(</span> WildEQ<span style="color:#662222;">(</span>a,c,<span style="color:#00AA22;">'*'</span><span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 0<br></span>wt<span style="color:#662222;">(</span> WildEQ<span style="color:#662222;">(</span>a,d,<span style="color:#00AA22;">'*'</span><span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 0<br></span></span></pre><br></p>
<p>配列Aの 最初, 最後 の部分が配列Bに一致するかを調べる（関数名に三単現のsはないです）<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2&gt; <span style="color:#0000FF;">int</span> startWith<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> As, <span style="color:#4444FF;">const</span> T1 A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> Bs, <span style="color:#4444FF;">const</span> T2 B<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span></span></span> : $As \geq Bs$ かつ A[i] = B[i] (i=0,1,..,Bs-1) が成り立つなら 1，そうでないなら 0 を返す</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2&gt; <span style="color:#0000FF;">int</span> startWith<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T1&gt; &amp;A, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T2&gt; &amp;B<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> startWith<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;A, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;B<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2&gt; <span style="color:#0000FF;">int</span> endWith<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> As, <span style="color:#4444FF;">const</span> T1 A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> Bs, <span style="color:#4444FF;">const</span> T2 B<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span></span></span> : $As \geq Bs$ かつ A[As-1-i] = B[Bs-1-i] (i=0,1,..,Bs-1) が成り立つなら 1，そうでないなら 0 を返す</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2&gt; <span style="color:#0000FF;">int</span> endWith<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T1&gt; &amp;A, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T2&gt; &amp;B<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> endWith<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;A, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;B<span style="color:#662222;">)</span></span></span></li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">string</span> a = <span style="color:#00AA22;">&quot;abc&quot;</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">string</span> b = <span style="color:#00AA22;">&quot;ab&quot;</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">string</span> c = <span style="color:#00AA22;">&quot;bc&quot;</span><span style="color:#000000;">;</span>

wt<span style="color:#662222;">(</span> startWith<span style="color:#662222;">(</span>a,b<span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 1
</span>wt<span style="color:#662222;">(</span> startWith<span style="color:#662222;">(</span>a,c<span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 0
</span>wt<span style="color:#662222;">(</span> startWith<span style="color:#662222;">(</span>b,a<span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 0
</span>
wt<span style="color:#662222;">(</span> endWith<span style="color:#662222;">(</span>a,b<span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 0
</span>wt<span style="color:#662222;">(</span> endWith<span style="color:#662222;">(</span>a,c<span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 1
</span>wt<span style="color:#662222;">(</span> endWith<span style="color:#662222;">(</span>c,a<span style="color:#662222;">)</span> <span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 0
</span></span></pre>


<h2 id="ayjfaf003a">主に複数の配列に関する処理</h2>

<ul><li>template&lt;class S&gt; S arrErase(int k, int &amp;sz, S a[]) : 要素数szの配列aのk番目の要素を消す．szは勝手に1減る．a[0]=1, a[1]=3, a[2]=4, sz=3 のとき arrErase(1,sz,a) によって a[0]=1, a[1]=4, sz=2 に変更される．削除した要素を返す（削除する要素数が1の場合のみ）．</li>
<li>template&lt;class S, class T&gt; void arrErase(int k, int &amp;sz, S a[], T b[]) : 要素数szの配列aと配列bのk番目の要素を消す．</li>
<li>template&lt;class S, class T, class U&gt; void arrErase(int k, int &amp;sz, S a[], T b[], U c[]) : 要素数szの配列aと配列bと配列cのk番目の要素を消す．</li>
<li>template&lt;class S&gt; void arrInsert(const int k, int &amp;sz, S a[], const S aval) : 要素数szの配列aに要素を a[k] = aval になるように挿入する．</li>
<li>template&lt;class S, class T&gt; void arrInsert(const int k, int &amp;sz, S a[], const S aval, T b[], const T bval)</li>
<li>template&lt;class S, class T, class U&gt; void arrInsert(const int k, int &amp;sz, S a[], const S aval, T b[], const T bval, U c[], const U cval)</li>
<li>template&lt;class S, class T, class U, class V&gt; void arrInsert(const int k, int &amp;sz, S a[], const S aval, T b[], const T bval, U c[], const U cval, V d[], const V dval)</li>
<li>template&lt;class S&gt; int arrEraseVal(S val1, int &sz, S a[]) : 要素数szの配列aの中で値がval1の要素を全て消す．szは勝手に消された分減る．消した要素の数を戻り値として返す．</li>
<li>template&lt;class S&gt; int arrEraseVal(S val1, S val2, int &sz, S a[]) : 要素数szの配列aの中で値がval1またはval2の要素を全て消す．szは勝手に消された分減る．消した要素の数を戻り値として返す．</li>
<li>template&lt;class S&gt; int arrEraseVal(S val1, S val2, S val3, int &sz, S a[]) : 要素数szの配列aの中で値がval1またはval2またはval3の要素を全て消す．szは勝手に消された分減る．消した要素の数を戻り値として返す．</li>
<li>template&lt;class S&gt; int arrEraseVal(S val1, S val2, S val3, S val4, int &sz, S a[]) : 要素数szの配列aの中で値がval1またはval2またはval3またはval4の要素を全て消す．szは勝手に消された分減る．消した要素の数を戻り値として返す．</li>
<li>template&lt;class S&gt; int vecEraseVal(S val1, vector&lt;S&gt; &a) : 配列aの中で値がval1の要素を全て消す．消した要素の数を戻り値として返す．</li>
<li>template&lt;class T, class S&gt; inline int vec2arr(vector&lt;T&gt; &amp;v, S arr[]) : vectorを配列に変換します．arr[i] = v[i] して要素数を返します．</li>
<li>template&lt;class T, class S1, class S2&gt; inline int vec2arr(vector&lt;vector&lt;T&gt;&gt; &amp;v, S1 arr2[], S2 arr2[]) : vectorを配列に変換します．arr1[i] = v[i][0], arr2[i] = v[i][1] して要素数を返します．</li>
<li>template&lt;class T, class S1, class S2, class S3&gt; inline int vec2arr(vector&lt;vector&lt;T&gt;&gt; &amp;v, S1 arr2[], S2 arr2[], S3 arr3[]) : vectorを配列に変換します．arr1[i] = v[i][0], arr2[i] = v[i][1], arr3[i] = v[i][2] して要素数を返します．</li>
</ul>



<h2 id="ayjfaf003b">主に複数の配列に関する計算</h2>




<h1 id="akjfaf8371h">典型手法</h1>

<h2 id="ayjfoiujd87">尺取法（TwoPointers）</h2>

<p>長さ n 配列の配列 a に対して，条件が成り立つ区間（空でない連続部分列）を尺取法で求めるものです．<br>ただし，条件は「空の区間に対して成り立つ」と「条件が成り立つ区間に包含される区間でも成り立つ（短いほど成り立ちやすい）」が成り立たなければいけません．<br>（実際には，a は配列である必要はありませんが，配列として説明しています）<br></p>
<p>初め空の区間から初めて，要素を追加したり，削除しながら条件が成り立つか調べます．<br><span id="code"><span style="color:#444444">TwoPointers<span style="color:#662222;">(</span>n, res, ind<span style="color:#662222;">)</span><span style="color:#441111;">[</span>追加<span style="color:#441111;">]</span><span style="color:#441111;">[</span>削除<span style="color:#441111;">]</span><span style="color:#441111;">[</span>条件<span style="color:#441111;">]</span><span style="color:#000000;">;</span></span></span> という形式で記述します．<br>追加では，a[ind]（ind番目の要素）が追加されるときの処理，<br>削除では，a[ind]（ind番目の要素）が削除されるときの処理，<br>条件では，条件を満たしているかどうか調べる関数の中身（return で bool を返す）を記述してください．<br>この記述の前に必要な前処理（初期化）をしておいてください．<br></p>
<p>resは計算結果を格納する整数の配列（長さn以上）で，j=res[i] というのは，区間 [i,i), [i,i+1), [i,j) は条件を満たすが [i,j] は条件を満たさない（または j=n）を意味します．<br>条件を満たす区間の最大長は max(res[i] - i) で，区間の数は sum(res[i] - i) です．<br></p>
<p>例えば，非負整数からなる配列 a に対して，和が10以下になる区間を列挙するには以下のように記述します．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">11</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">6</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> res<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, s = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 和 s は 0 で初期化しておく
</span>
TwoPointers<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>, res, ind<span style="color:#662222;">)</span><span style="color:#441111;">[</span>
  s += a<span style="color:#441111;">[</span>ind<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#441111;">]</span><span style="color:#441111;">[</span>
  s -= a<span style="color:#441111;">[</span>ind<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#441111;">]</span><span style="color:#441111;">[</span>
  <span style="color:#0088FF;">return</span> s &lt;= <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
<span style="color:#441111;">]</span><span style="color:#000000;">;</span>

<span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span> wt<span style="color:#662222;">(</span>i,res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;max_len&quot;</span>, <span style="color:#000000;font-weight:bold;">max</span><span style="color:#441111;">[</span>i,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>-i<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;num&quot;</span>, sum<span style="color:#441111;">[</span>i,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>-i<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

<span style="color:#888888;">// 0 3
</span><span style="color:#888888;">// 1 4
</span><span style="color:#888888;">// 2 5
</span><span style="color:#888888;">// 3 5
</span><span style="color:#888888;">// 4 5
</span><span style="color:#888888;">// 5 5
</span><span style="color:#888888;">// 6 8
</span><span style="color:#888888;">// 7 10
</span><span style="color:#888888;">// 8 10
</span><span style="color:#888888;">// 9 10
</span><span style="color:#888888;">// max_len 3
</span><span style="color:#888888;">// num 20
</span></span></pre>
<p>そして，これはだいたい以下のような感じで展開されます（機能追加時の実装っぽいものです）．<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">11</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">6</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> res<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, s = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>

  <span style="color:#0000FF;">auto</span> TP_insert = <span style="color:#441111;">[</span>&amp;<span style="color:#441111;">]</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> ind<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    s += a<span style="color:#441111;">[</span>ind<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">auto</span> TP_erase = <span style="color:#441111;">[</span>&amp;<span style="color:#441111;">]</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> ind<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    s -= a<span style="color:#441111;">[</span>ind<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">auto</span> TP_check = <span style="color:#441111;">[</span>&amp;<span style="color:#441111;">]</span><span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0088FF;">return</span> s &lt;= <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>

  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">int</span> i = <span style="color:#AA00AA;">0</span>, j = <span style="color:#AA00AA;">0</span>, n = <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
    <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#000000;">;</span><span style="color:#000000;">;</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
      <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>TP_check<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
        res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = j<span style="color:#000000;">;</span>
        <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>j == n<span style="color:#662222;">)</span> <span style="color:#0088FF;">break</span><span style="color:#000000;">;</span>
        TP_insert<span style="color:#662222;">(</span>j++<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
      <span style="color:#440000;font-weight:bold;">}</span> <span style="color:#0088FF;">else</span> <span style="color:#440000;font-weight:bold;">{</span>
        TP_erase<span style="color:#662222;">(</span>i++<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
        res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = res<span style="color:#441111;">[</span>i-<span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
      <span style="color:#440000;font-weight:bold;">}</span>
    <span style="color:#440000;font-weight:bold;">}</span>
    <span style="color:#0088FF;">while</span><span style="color:#662222;">(</span>i+<span style="color:#AA00AA;">1</span> &lt; n<span style="color:#662222;">)</span> res<span style="color:#441111;">[</span>++i<span style="color:#441111;">]</span> = j<span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span>

  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span> wt<span style="color:#662222;">(</span>i,res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;max_len&quot;</span>, <span style="color:#000000;font-weight:bold;">max</span><span style="color:#441111;">[</span>i,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>-i<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;num&quot;</span>, sum<span style="color:#441111;">[</span>i,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>res<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>-i<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>





<h1 id="akjfaf0010">典型問題</h1>



<h1 id="akjfaf0">その他（未整理）</h1>


<h2>ループ</h2>
<p><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>n<span style="color:#662222;">)</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> hoge<span style="color:#000000;">;</span> <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>hoge=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>hoge&lt;n<span style="color:#000000;">;</span>hoge++<span style="color:#662222;">)</span></span></span> に置き換えられます（hogeは適当な変数名）．<br><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,n<span style="color:#662222;">)</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;<span style="color:#662222;">(</span>n<span style="color:#662222;">)</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span></span></span> に置き換えられます．<br><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,a,b<span style="color:#662222;">)</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#662222;">(</span>a<span style="color:#662222;">)</span><span style="color:#000000;">;</span>i&lt;<span style="color:#662222;">(</span>b<span style="color:#662222;">)</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span></span></span> に置き換えられます．<br><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,a,b,s<span style="color:#662222;">)</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#662222;">(</span>a<span style="color:#662222;">)</span><span style="color:#000000;">;</span>i&lt;<span style="color:#662222;">(</span>b<span style="color:#662222;">)</span><span style="color:#000000;">;</span>i+=<span style="color:#662222;">(</span>s<span style="color:#662222;">)</span><span style="color:#662222;">)</span></span></span> に置き換えられます．<br>REP(n) は int hoge, piyo = n; for(hoge=0;hoge&lt;piyo;hoge++) に置き換えられます（hoge, piyoは適当な変数名）．<br>REP(i,n) は int piyo = n; for(i=0;i&lt;piyo;i++) に置き換えられます（piyoは適当な変数名）．<br>REP(i,a,b) は int piyo = b; for(i=(a);i&lt;piyo;i++) に置き換えられます（piyoは適当な変数名）．<br>REP(i,a,b,s) は int piyo = b, huga = s; for(i=(a);i&lt;piyo;i+=huga) に置き換えられます（piyoは適当な変数名）．<br>また，この際，変数iが宣言されていなかった場合，勝手にint型の変数として宣言されます．<br>rep では終了条件の変数・式 (n, b) が複数回評価されたり，ループの中で書き換え可能ですが，REP はそうではないことに注意してください．<br></p>
<p>同じ範囲をループで逆順で回す場合は以下があります（sを指定した場合，必ずしも同じ範囲ではないかもしれない）．<br>rrep(n) は int hoge; for(hoge=(n)-1;hoge&gt;=0;hoge--) に置き換えられます（hogeは適当な変数名）：使う意味はないです．<br>rrep(i,n) は for(i=(n)-1;i&gt;=0;i--) に置き換えられます．<br>rrep(i,a,b) は for(i=(b)-1;i&gt;=(0);i--) に置き換えられます．<br>rrep(i,a,b,s) は for(i=(b)-1;i&gt;=(a);i-=(s)) に置き換えられます．<br>RREP(n) は int hoge, piyo = n; for(hoge=piyo-1;hoge&gt;=0;hoge--) に置き換えられます（hoge, piyoは適当な変数名）：使う意味はないです．<br>RREP(i,n) は int piyo = n; for(i=piyo-1;i&gt;=0;i--) に置き換えられます（piyoは適当な変数名）．<br>RREP(i,a,b) は int piyo = a; for(i=(b)-1;i&gt;=piyo;i--) に置き換えられます（piyoは適当な変数名）．<br>RREP(i,a,b,s) は int piyo = a, huga = s; for(i=(b)-1;i&gt;=piyo;i-=huga) に置き換えられます（piyoは適当な変数名）．<br></p>
<p>配列の中身を変数に代入して使用したい場合は，例えば <span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#441111;">[</span>arr<span style="color:#441111;">]</span><span style="color:#662222;">(</span>i,n<span style="color:#662222;">)</span> hoge<span style="color:#000000;">;</span></span></span> および <span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#441111;">[</span>arr<span style="color:#441111;">]</span><span style="color:#662222;">(</span>i,n<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span> hoge<span style="color:#000000;">;</span> <span style="color:#440000;font-weight:bold;">}</span></span></span> は<br></p>

<pre><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>tekitouna_namae, n<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">auto</span> &amp;i = arr<span style="color:#441111;">[</span>tekitouna_namae<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  hoge<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>に展開されます．rep, REP, rrep, RREP それぞれ，引数の数も自由です．<br>また，インデックスも利用する場合，例えば rep[arr,ind](i,n) hoge; および rep[arr,ind](i,n){ hoge; } は<br></p>

<pre><span style="color:#444444"><span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>ind, n<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">auto</span> &amp;i = arr<span style="color:#441111;">[</span>ind<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  hoge<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>に展開されます．<br>変数 i は既に宣言されていても，ブロックの中で再び定義されます．<br></p>
<p>ループから抜ける break について，二重ループから抜ける break_break などがあります．<br>break_break は break した後，その直後に break したのと同じ挙動になるはずです．<br>3重ループを抜ける break_break_break や，一つ上のループに対して直接continueをする break_continue などがあります．<br>break_ を何回か繰り返して break または continue を最後に付けた文があり，break_A は break を行って，ループを抜けた直後に A を行う感じです．<br></p>
<p>また，括弧内（(),[],{}のどれか）で2つ以上のドットで区切ると範囲を指定でき，勝手にループに展開されます．<br>ドットの数が等しいものが同じ変数だと思われて，同じドットの数のものは2回目以降に登場したときには区間の終わりは省略可能です．<br>（ドットの数が少ない方が内側のループになります．2次元配列のアクセス順で速度がかなり変わるので気をつけたほうが良い場合があります）<br>例えば，単位行列を作るコード，行列のコピーのコード，転置しながらコピーするコードは<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, C<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
A<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>..<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>
A<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span>
B<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>..<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span> = A<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>..<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
C<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>..<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span> = A<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>..<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
</span></pre>
<p>のように書け，これは<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> i, j, A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>j=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>j&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>j++<span style="color:#662222;">)</span> A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span> = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>j=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>j&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>j++<span style="color:#662222;">)</span> B<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span> = A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> <span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>j=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>j&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>j++<span style="color:#662222;">)</span> C<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span> = A<span style="color:#441111;">[</span>j<span style="color:#441111;">]</span><span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
</span></pre>
<p>と同値です（B[0...9][0..9] = A[0...9][0..9];はB[0...9][0..9] = A[0...][0..];と書くこともできます）．<br></p>
<p>括弧で囲まれていなければならないことに注意して下さい．<br></p>

<pre><span style="color:#444444">A<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span> = <span style="color:#662222;">(</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#662222;">)</span>
B<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#AA00AA;">9</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">50</span> - <span style="color:#662222;">(</span><span style="color:#AA00AA;">23.</span>.<span style="color:#662222;">)</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = i<span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span>i=<span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>i&lt;=<span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>i++<span style="color:#662222;">)</span> B<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = <span style="color:#AA00AA;">50</span> - <span style="color:#662222;">(</span><span style="color:#AA00AA;">23</span> + i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>と同値ですが， A[0..9] = 0..9; などとは書けません．<br></p>
<p>文字列の中に2個以上ドットが並ぶとバグる実装なのでそのうちなんとかする．<br></p>



<h2>特殊なループ1（多重ループ）</h2>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep_perm</span><span style="color:#662222;">(</span>d,n<span style="color:#662222;">)</span></span></span> : 0 から n-1 の置換に対するループ．$0 \leq d[0], d[1], \ldots, d[n-1] &lt; n$ かつ $d[i] \neq d[j]$．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep_scomb</span><span style="color:#662222;">(</span>d,n,m<span style="color:#662222;">)</span></span></span> : 0 から m-1 までの整数から順序を問わず n 個取り出す組合せのループ．$0 \leq d[0] &lt; d[1] &lt; \cdots &lt; d[n-1] &lt; m$．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep_mcomb</span><span style="color:#662222;">(</span>d,n,m<span style="color:#662222;">)</span></span></span> : 0 から m-1 までの整数から順序を問わず重複を許して n 個取り出す組合せのループ．$0 \leq d[0] \leq d[1] \leq \cdots \leq d[n-1] &lt; m$．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep_sarr</span><span style="color:#662222;">(</span>d,n,m<span style="color:#662222;">)</span></span></span> : 0 から m-1 までの整数から順序を加味して n 個取り出す組合せのループ．$0 \leq d[0], d[1], \ldots, d[n-1] &lt; m$ かつ $d[i] \neq d[j]$．多分<strong>低速なので注意</strong>．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0088FF;">rep_marr</span><span style="color:#662222;">(</span>d,n,m<span style="color:#662222;">)</span></span></span> : 0 から m-1 までの整数から順序を加味して重複を許して n 個取り出す組合せのループ．$0 \leq d[0], d[1], \ldots, d[n-1] &lt; m$．</li>
</ul>
<p>たとえば，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> d<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, n = <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">rep_perm</span><span style="color:#662222;">(</span>d,n<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  hoge<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> d<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, n = <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
<span style="color:#0088FF;">for</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> tmp = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span> tmp &lt; n<span style="color:#000000;">;</span> tmp++<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  d<span style="color:#441111;">[</span>tmp<span style="color:#441111;">]</span> = tmp<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
<span style="color:#0088FF;">do</span><span style="color:#440000;font-weight:bold;">{</span>
  hoge<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span> <span style="color:#0088FF;">while</span><span style="color:#662222;">(</span><span style="color:#000000;font-weight:bold;">next_permutation</span><span style="color:#662222;">(</span>d, d+n<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>に置換されます．<br>他のもだいたい同様で，辞書順最小のものからループします．<br>（重複を許さない組合せで n より m のほうが小さい場合（条件を満たす配列が存在しない場合）は，ループの中身は1回も実行されません）<br>このループに使用する，next_permutation() に相当する，条件を満たす配列で，辞書順で次のものを求める関数 scomb(), mcomb(), sarr(), marr() 等もあり以下のとおりです．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> next_mcomb<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> len, <span style="color:#0000FF;">int</span> arr<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> lim<span style="color:#662222;">)</span></span></span> : 長さ len の配列 arr[] は条件 hoge を満たすとする．その条件を満たす辞書順で次のものに変換し 1 を返す．辞書順で次のものがなければ，辞書順最小のものに変換し 0 を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> next_scomb<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> len, <span style="color:#0000FF;">int</span> arr<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> lim<span style="color:#662222;">)</span></span></span> : 長さ len の配列 arr[] は条件 hoge を満たすとする．その条件を満たす辞書順で次のものに変換し 1 を返す．辞書順で次のものがなければ，辞書順最小のものに変換し 0 を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> next_marr<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> len, <span style="color:#0000FF;">int</span> arr<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> lim<span style="color:#662222;">)</span></span></span> : 長さ len の配列 arr[] は条件 hoge を満たすとする．その条件を満たす辞書順で次のものに変換し 1 を返す．辞書順で次のものがなければ，辞書順最小のものに変換し 0 を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> next_sarr<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> len, <span style="color:#0000FF;">int</span> arr<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> lim, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 長さ len の配列 arr[] は条件 hoge を満たすとする．その条件を満たす辞書順で次のものに変換し 1 を返す．辞書順で次のものがなければ，辞書順最小のものに変換し 0 を返す．毎回 O(len+lim) 時間かかるので注意．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> next_sarr_s<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> len, <span style="color:#0000FF;">int</span> arr<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> lim, T use<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span></span></span> : 長さ len の配列 arr[] は条件 hoge を満たすとし，use[k] は arr[i] = k なる i が存在すれば 1，そうでなければ 0 を満たすとする．その条件を満たす辞書順で次のものに変換し 1 を返す．辞書順で次のものがなければ，辞書順最小のものに変換し 0 を返す．</li>
</ul>
<p>hoge は rep_piyo の説明を参照．<br></p>



<h2>特殊なループ2（主に2次元以上で一定以内の距離を走査するループ）</h2>
<p>例から書くと<br></p>

<pre><span style="color:#444444"><span style="color:#0088FF;">rep_dist</span><span style="color:#662222;">(</span>i, j, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">8</span><span style="color:#662222;">)</span> wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;({i},{j})&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// (3,8)からマンハッタン距離で1以下の距離にある（(3,8)は除く）
</span><span style="color:#888888;">// (2,8)(3,7)(3,9)(4,8)
</span>
<span style="color:#0088FF;">rep_dist</span><span style="color:#662222;">(</span>i, j, k, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;({i},{j},{k})&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// (3,8,1)からマンハッタン距離で1以下の距離にある（(3,8,1)は除く）
</span><span style="color:#888888;">// (2,8,1)(3,7,1)(3,8,0)(3,8,2)(3,9,1)(4,8,1)
</span>
<span style="color:#0088FF;">rep_dist</span><span style="color:#662222;">(</span>i, j, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">8</span>, m2z<span style="color:#662222;">)</span> wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;({i},{j})&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// (3,8)からマンハッタン距離で2以下の距離にある（(3,8)自身も含む）
</span><span style="color:#888888;">// (1,8)(2,7)(2,8)(2,9)(3,6)(3,7)(3,8)(3,9)(3,10)(4,7)(4,8)(4,9)(5,8)
</span>
<span style="color:#0088FF;">rep_dist</span><span style="color:#662222;">(</span>i, j, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">8</span>, t2<span style="color:#662222;">)</span> wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;({i},{j})&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// (3,8)からチェビシェフ距離で2以下の距離にある（(3,8)は除く）
</span><span style="color:#888888;">// (1,6)(1,7)(1,8)(1,9)(1,10)(2,6)(2,7)(2,8)(2,9)(2,10)(3,6)(3,7)(3,9)(3,10)(4,6)(4,7)(4,8)(4,9)(4,10)(5,6)(5,7)(5,8)(5,9)(5,10)    
</span>
<span style="color:#0088FF;">rep_dist</span><span style="color:#662222;">(</span>i, j, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">e3</span><span style="color:#662222;">)</span> wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;({i},{j})&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// (3,8)からユークリッド距離で3以下の距離にある（(3,8)は除く）
</span><span style="color:#888888;">// (0,8)(1,6)(1,7)(1,8)(1,9)(1,10)(2,6)(2,7)(2,8)(2,9)(2,10)(3,5)(3,6)(3,7)(3,9)(3,10)(3,11)(4,6)(4,7)(4,8)(4,9)(4,10)(5,6)(5,7)(5,8)(5,9)(5,10)(6,8)
</span>
<span style="color:#0088FF;">rep_dist</span><span style="color:#662222;">(</span>i, j, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">8</span>, ee2<span style="color:#662222;">)</span> wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;({i},{j})&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// (3,8)からユークリッド距離でsqrt(2)以下の距離にある（(3,8)は除く）
</span><span style="color:#888888;">// (2,7)(2,8)(2,9)(3,7)(3,9)(4,7)(4,8)(4,9)
</span></span></pre>
<p>一般的には<br></p>
<ul><li>rep_dist(x1,x2,...,xk, c1,c2,...,ck, mode) : modeは省略可能</li>
</ul>
<p>という形式です．<br>x1,...,xk がループ変数（定義されてなければint型で勝手に定義します）で，c1,...,ckが中心の座標を表します．<br></p>
<p>modeは以下を連結したものを指定します：<br></p>
<ul><li>距離の種類「m：マンハッタン距離」「tまたはc：チェビシェフ距離」「e：ユークリッド距離」「ee：ユークリッド距離の2乗」，省略するとmになります．</li>
<li>これ以下の距離を操作するという整数の値，省略すると1になります</li>
<li>中心自身もループに含める場合はzを指定します</li>
</ul>
<p>距離の定義は以下の通りです：<br></p>
<ul><li>マンハッタン距離の定義は $\sum |x_i - c_i|$．</li>
<li>チェビシェフ距離の定義は $\max |x_i - c_i|$．</li>
<li>ユークリッド距離の定義は $\sqrt{\sum (x_i - c_i)^2}$．</li>
</ul>
<p>距離を指定する場合，あまり大きな整数を指定することは考えてません（バグったり不具合が起こる可能性が高いです）．<br>ループの順番は辞書順で回るはずです．<br></p>



<h2>演算子</h2>
<p>昔のGCC拡張で存在した <span id="code"><span style="color:#444444">&lt;?</span></span> および <span id="code"><span style="color:#444444">&gt;?</span></span> 演算子の同時に代入するバージョンのみ使えます．<br>つまり，<span id="code"><span style="color:#444444">a &lt;?= b<span style="color:#000000;">;</span></span></span> は <span id="code"><span style="color:#444444">a = <span style="color:#000000;font-weight:bold;">min</span><span style="color:#662222;">(</span>a, b<span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> と，<span id="code"><span style="color:#444444">a &gt;?= b<span style="color:#000000;">;</span></span></span> は <span id="code"><span style="color:#444444">a = <span style="color:#000000;font-weight:bold;">max</span><span style="color:#662222;">(</span>a, b<span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> と大体同じです．<br>代入しないバージョンは素直にminおよびmaxを使うこと．<br><span id="code"><span style="color:#444444">a &gt;?= b &gt; <span style="color:#AA00AA;">10</span></span></span> は <span id="code"><span style="color:#444444">a &gt;?= <span style="color:#662222;">(</span>b &gt; <span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span></span></span> とみなされます．必要なら <span id="code"><span style="color:#444444"><span style="color:#662222;">(</span>a &gt;?= b<span style="color:#662222;">)</span> &gt; <span style="color:#AA00AA;">10</span></span></span> などと括弧を付けてください．<br>（式 <span id="code"><span style="color:#444444">a &gt;?= b</span></span> の評価値は代入後の a の値，つまり max(a,b) です）<br></p>
<p>正の整数に関する繰り上げの割り算演算子 /+ が使えます．<br>13 /+ 3 は 5 となります．<br>実際には a /+ b は (a+b-1) / b で定義され，正の整数でないと繰り上げ割り算になる保証はありません．<br>また，a+b-1 がオーバーフローする可能性があるので要注意です．<br>a = a /+ b; は a /+= b; と書くこともできます．<br><span id="code"><span style="color:#444444">a /+= b &gt; <span style="color:#AA00AA;">10</span></span></span> は <span id="code"><span style="color:#444444">a /+= <span style="color:#662222;">(</span>b &gt; <span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span></span></span> とみなされます．必要なら <span id="code"><span style="color:#444444"><span style="color:#662222;">(</span>a /+= b<span style="color:#662222;">)</span> &gt; <span style="color:#AA00AA;">10</span></span></span> などと括弧を付けてください．<br>負などもありうる場合には以下の関数が使えます．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#4444FF;">inline</span> T fDiv<span style="color:#662222;">(</span>T a, S b<span style="color:#662222;">)</span></span></span> : $\lfloor a/b \rfloor$ を返します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#4444FF;">inline</span> T cDiv<span style="color:#662222;">(</span>T a, S b<span style="color:#662222;">)</span></span></span> : $\lceil a/b \rceil$ を返します．</li>
</ul>
<p>負の数を正の数で割った余りを非負の数で返す %% 演算子があります．<br>(-5) %% 2 は 1 になります．<br>演算子の優先順位が低いので，-5 %% 2 は-(5 %% 2) = -1になります．<br>a = a %% b; は a %%= b; と書くこともできます．<br><span id="code"><span style="color:#444444">a %%= b &gt; <span style="color:#AA00AA;">10</span></span></span> は <span id="code"><span style="color:#444444">a %%= <span style="color:#662222;">(</span>b &gt; <span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span></span></span> とみなされます．必要なら <span id="code"><span style="color:#444444"><span style="color:#662222;">(</span>a %%= b<span style="color:#662222;">)</span> &gt; <span style="color:#AA00AA;">10</span></span></span> などと括弧を付けてください．<br></p>
<p>べき乗演算子 ** が使えます．<br>2 ** 3 は $2^3 = 8$ を表します．<br>点 (x1, y1) と (x2, y2) とのユークリッド距離は sqrt( (x1-x2)**2 + (y1-y2)**2 ) と簡潔に書けるようになります．<br>バイナリ法を使用します．<br>x ** y において，y は非負整数である必要があって，結果の型は x の型と同じになります（y が非負整数じゃない場合は標準の pow 関数などを使って下さい）．<br>ただし，x, y ともに double 型のときは，標準の pow(x,y) が呼び出されます．<br>a = a ** b; は a **= b; と書くこともできます．<br><span id="code"><span style="color:#444444">a **= b &gt; <span style="color:#AA00AA;">10</span></span></span> は <span id="code"><span style="color:#444444">a **= <span style="color:#662222;">(</span>b &gt; <span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span></span></span> とみなされます．必要なら <span id="code"><span style="color:#444444"><span style="color:#662222;">(</span>a **= b<span style="color:#662222;">)</span> &gt; <span style="color:#AA00AA;">10</span></span></span> などと括弧を付けてください．<br></p>
<p>数値の後の掛け算の演算子*は省略できることがあります．<br>z = 2 2x+2(x+5); で z = 2 * 2 * x + 2 * (x+5); の意味になります．<br>他の解釈ができる場合は*を省略できません．<br>2u は 2*u ではなくunsigned 型の定数 2 で，3d1 は 3*10 = 30 を表す整数で 3 * d1 などにはなりません．<br>数値はアルファベットで終わっている場合は，*を（現状では）省略できません．<br>z = 2u x; は駄目です．<br>また，数値の後以外の*の省略は（現状では）できません．<br>例えば，x(x+y) や (2)(x+y) に * が補われることはありません．<br>また，単純に*が補われるだけなので，x=2 のときに 7%2x は 7%2*x=1*2=2 となることに注意してください（7%(2x)ではない）．<br></p>
<p>等式，不等式の条件を続けるときに &amp;&amp; を省略できます．<br>if(5 &lt; x+y &lt; 10) は if(5 &lt; x+y &amp;&amp; x+y &lt; 10) に置き換わります．<br>if(i &lt;= 5 &lt; k &lt;= 12 &gt; j != m == n) は if(i &lt;= 5 &amp;&amp; 5 &lt; k &amp;&amp; k &lt;= 12 &amp;&amp; 12 &gt; j && j != m && m == n) に置き換わります．<br>if(5 &lt; x++ &lt; 10) は if(5 &lt; x++ &amp;&amp; x++ &lt; 10) に置き換わるので注意してください．<br>ただし，hoge &lt; hoge &gt; hoge &lt; hoge &gt; hoge などの場合は，テンプレート絡みなどで使用することがあるので，展開されません（左から右に単調非減少の形で条件を書くと良いと考えています）．<br></p>


<h2>複数の演算（内部でarraylike operationと呼んでるもの）</h2>
<p><span id="code"><span style="color:#444444"><span style="color:#662222;">(</span>a1,a2,...,an<span style="color:#662222;">)</span> += <span style="color:#662222;">(</span>b1,b2,...,bn<span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> のような形で複数の演算を一度に行います．<br>コンマ演算子をオーバーロードしていると変なことが起こるかもしれないので，この機能を無効化する場合は //no-arraylike-operations のフラグを指定してください．<br>具体的には，<br></p>

<pre><span style="color:#444444"><span style="color:#662222;">(</span>a,b<span style="color:#662222;">)</span> = <span style="color:#662222;">(</span>b,a+b<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">auto</span> tmp1 = b<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">auto</span> tmp2 = a+b<span style="color:#000000;">;</span>
  a = tmp1<span style="color:#000000;">;</span>
  b = tmp2<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>と展開され，<br></p>

<pre><span style="color:#444444"><span style="color:#662222;">(</span>a,b<span style="color:#662222;">)</span> += k<span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">auto</span> tmp = k<span style="color:#000000;">;</span>
  a += k<span style="color:#000000;">;</span>
  b += k<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>と展開されます．<br>また，<span id="code"><span style="color:#444444"><span style="color:#662222;">(</span>a,b,c<span style="color:#662222;">)</span>++<span style="color:#000000;">;</span></span></span> や <span id="code"><span style="color:#444444">--<span style="color:#662222;">(</span>a,b<span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> はそれぞれ <span id="code"><span style="color:#444444">a++<span style="color:#000000;">;</span> b++<span style="color:#000000;">;</span> c++<span style="color:#000000;">;</span></span></span> や <span id="code"><span style="color:#444444">--a<span style="color:#000000;">;</span> --b<span style="color:#000000;">;</span></span></span> に展開されます．<br>更に，現状では<br></p>

<pre><span style="color:#444444"><span style="color:#662222;">(</span>a, b, c<span style="color:#662222;">)</span> *= <span style="color:#662222;">(</span>f<span style="color:#662222;">(</span>m, n<span style="color:#662222;">)</span> + k * <span style="color:#662222;">(</span>b, c, a<span style="color:#662222;">)</span> + <span style="color:#662222;">(</span>s, t<span style="color:#662222;">)</span><span style="color:#662222;">)</span> % <span style="color:#AA00AA;">100</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">auto</span> tmp1 = <span style="color:#662222;">(</span>f<span style="color:#662222;">(</span>m, n<span style="color:#662222;">)</span> + k * b + s<span style="color:#662222;">)</span> % <span style="color:#AA00AA;">100</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 実際は s とかは (s) とカッコが付いたりします
</span>  <span style="color:#0000FF;">auto</span> tmp2 = <span style="color:#662222;">(</span>f<span style="color:#662222;">(</span>m, n<span style="color:#662222;">)</span> + k * c + t<span style="color:#662222;">)</span> % <span style="color:#AA00AA;">100</span><span style="color:#000000;">;</span> 
  <span style="color:#0000FF;">auto</span> tmp3 = <span style="color:#662222;">(</span>f<span style="color:#662222;">(</span>m, n<span style="color:#662222;">)</span> + k * a + s<span style="color:#662222;">)</span> % <span style="color:#AA00AA;">100</span><span style="color:#000000;">;</span> 
  a *= tmp1<span style="color:#000000;">;</span>
  b *= tmp2<span style="color:#000000;">;</span>
  c *= tmp3<span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>に展開されます．<br>共通部分は (hoge, piyo) の形式で書かなければ良いです．<br>また，サイズが違う場合はサイクリックに適応されます（R言語のような感じ）．<br>現状では，f(n)が3回呼び出されますが，将来的に変更される可能性があります（右辺に副作用があるものを書かないでください）．<br></p>


<h2>複数の処理（内部でarraylike sentenceと呼んでるもの）</h2>
<p>arraylike operationのある種の一般化です．<br>@[a,b] と@[]内に,で区切ったものが展開されます．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">unionFind</span> u_a, u_b, u_c<span style="color:#000000;">;</span>
u_@<span style="color:#441111;">[</span>a,b,c<span style="color:#441111;">]</span>.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>で<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">unionFind</span> u_a, u_b, u_c<span style="color:#000000;">;</span>
u_a.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_b.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_c.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>に展開されます．<br>また，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">unionFind</span> u_a, u_b, u_c<span style="color:#000000;">;</span>
u_@<span style="color:#441111;">[</span>a,b,c<span style="color:#441111;">]</span>.walloc<span style="color:#662222;">(</span>@<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">20</span>,<span style="color:#AA00AA;">30</span><span style="color:#441111;">]</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>で<br></p>

<pre><span style="color:#444444">u_a.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_b.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">20</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_c.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">30</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>に展開されます．<br>中身の要素の長さが違う場合は，短いものはR言語っぽくサイクリックに拡張されます．<br>また，2種類以上，独立に展開する場合は，@1[a,b]，@2[a,b]と@+数字1文字で11種類使えます．<br></p>

<pre><span style="color:#444444">u_@<span style="color:#AA00AA;">1</span><span style="color:#441111;">[</span>a,b,c<span style="color:#441111;">]</span>.walloc<span style="color:#662222;">(</span>@<span style="color:#AA00AA;">2</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">20</span>,<span style="color:#AA00AA;">30</span><span style="color:#441111;">]</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre><span style="color:#444444">u_a.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_b.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_c.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_a.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">20</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_b.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">20</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_c.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">20</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_a.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">30</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_b.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">30</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
u_c.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">30</span>,<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>など（順番は不定にしておきます）に展開されます<br></p>


<h2>定数</h2>
<p><span id="code"><span style="color:#444444"><span style="color:#FF22FF;">int_inf</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#AA00AA;">1073709056</span></span></span> ($2^{30}-2^{15}$) に，<br><span id="code"><span style="color:#444444"><span style="color:#FF22FF;">ll_inf</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#AA00AA;">4611686016279904256LL</span></span></span> ($2^{62}-2^{31}$) に，<br><span id="code"><span style="color:#444444"><span style="color:#FF22FF;">double_inf</span></span></span> は <span id="code"><span style="color:#444444"><span style="color:#AA00AA;">1e150</span></span></span> に置換されます．<br></p>
<p><span id="code"><span style="color:#444444"><span style="color:#FF22FF;">int_inf</span></span></span> および <span id="code"><span style="color:#444444"><span style="color:#FF22FF;">ll_inf</span></span></span> はそれぞれ2倍してちょっとした数を足してもint型，long long型でオーバーフローしないという値に設定しています．<br>また，<span id="code"><span style="color:#444444"><span style="color:#FF22FF;">double_inf</span></span></span> は2乗してもオーバーフローしないという値に設定しています．<br></p>
<p>また，MDは1000000007（$10^9+7$）に，PIは3.14159265358979323846（円周率）に置換されます（厳密には最初に#define MD 1000000007などが追加されます）．<br>MDとPIはコード中で #define MD 1000000009 などと言う記述が出てきたら置換されずそちらが優先されます．<br></p>
<p>また，double型の定数の書き方 1e-5 などと同様に，整数型の定数を 1d5 などと書けます．<br>$x$d$y$ で $\lfloor x \times 10^y \rfloor$ を表します．<br>$2^{31}$ 未満であれば int 型，$2^{31}$ 以上であれば ll 型，$2^{63}$ 以上であれば ull 型の定数になり，$2^{64}$ 以上の値だと上手く動きません．<br>$y$ は整数で $-30$ 以上 $30$ 以下でないと正しく動きません．<br></p>


<h2>関数のメモ化</h2>
<p>関数の引数に続いて : で区切ってMemoizeをつけると，同じ引数で呼び出されたとき，以前に計算した結果を即座に返すようにします．<br>引数が配列（ポインタ）とか変なのを含む場合は動かないと思います．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">Modint</span> f<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n : <span style="color:#0088FF;">Memoize</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>n&lt;=<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> <span style="color:#0088FF;">return</span> n<span style="color:#000000;">;</span>
  <span style="color:#0088FF;">return</span> f<span style="color:#662222;">(</span>n-<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> + f<span style="color:#662222;">(</span>n-<span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>でフィボナッチ数を計算する関数をメモ化します．<br>標準では map を使用してメモするため，f(n) を呼び出したとき，この場合は，O(n log n) 時間，O(n) 領域使うと思います．<br>f(n) を計算するときに，直接的，または，間接的に f(n) を呼び出すと動きません（多分無限ループ）．<br></p>
<p>配列にメモする場合は，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">Modint</span> f<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n : <span style="color:#0088FF;">Memoize</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1d5</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>n&lt;=<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> <span style="color:#0088FF;">return</span> n<span style="color:#000000;">;</span>
  <span style="color:#0088FF;">return</span> f<span style="color:#662222;">(</span>n-<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> + f<span style="color:#662222;">(</span>n-<span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>とすると，n が 0 から 99999 (=10^5-1) しか呼び出さないことを仮定して Modint memo[1d5]; を用意してメモ化します．<br>0から始まらない場合<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">Modint</span> f<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n : <span style="color:#0088FF;">Memoize</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">-3</span>:<span style="color:#AA00AA;">123</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>n&lt;=<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> <span style="color:#0088FF;">return</span> n<span style="color:#000000;">;</span>
  <span style="color:#0088FF;">return</span> f<span style="color:#662222;">(</span>n-<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> + f<span style="color:#662222;">(</span>n-<span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>で n が -3 以上 123 以下と仮定して Modint memo[127]; を使ってメモ化します（127 = 123 - (-3) + 1）．<br>2次元以上の場合は，範囲を,で区切って書きます．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">Modint</span> f<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> x, <span style="color:#0000FF;">int</span> y : <span style="color:#0088FF;">Memoize</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">-1</span>:<span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">15</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  hoge
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>は x が -1 から 10 まで，y は 0 から 14 までの範囲と仮定してメモ化します．<br></p>
<p>計算結果を消去したい場合は f_clear() を呼び出して下さい（現状全部消えます，配列の場合，サイズに比例した時間がかかります）．<br>fは元々の関数名で，対応するものに変更してください．<br></p>



<h2>ワーキングメモリ</h2>
<p>ワーキングメモリを必要な関数や機能などを使うと勝手にワーキングメモリを確保します．<br>void *wmem; に（デフォルトで）96,000,000バイトのメモリが確保されます．<br>サイズを変更する場合は，どこか（の行頭）で，<br><span id="code"><span style="color:#444444"><span style="color:#888888;">//working_memory=500MB</span></span></span><br>などと書くと500*1024*1024バイトのメモリになります．<br><span id="code"><span style="color:#444444"><span style="color:#888888;">//working_memory=500m</span></span></span><br><span id="code"><span style="color:#444444"><span style="color:#888888;">//working_memory=524288000</span></span></span><br>も同じ意味です．Bは省略可能，K,M,Gが接頭語として使えます．<br></p>


<h2>行列</h2>
<p>行列は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">Matrix</span>&lt;<span style="color:#0000FF;">mint</span>&gt; m<span style="color:#000000;">;</span></span></span> などで定義します．<br>m[0][1] で0行1列の成分にアクセスできます（行番号，列番号は0から始まる）．<br>行列の足し算，引き算，かけ算は+，-，*でできます．べき乗演算子 ** なども使えます．定義できない演算をすると0行0列の行列になります．<br>int, ll, doubleの定数倍も可能です．<br>m = 1; などと定数を代入すると対角成分が1に，それ以外は0になります．<br>以下は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">Matrix</span>&lt;T&gt;</span></span> に関してです．<br></p>
<p>コンストラクタ<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">Matrix</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span>: 0行0列の行列</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">Matrix</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> rr, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> cc<span style="color:#662222;">)</span></span></span>: rr行cc列の行列．要素の初期化はされない．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">Matrix</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">Matrix</span>&lt;T&gt; &amp;a<span style="color:#662222;">)</span></span></span></li>
</ul>
<p>その他<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> m.changeSize<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> rr, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> cc<span style="color:#662222;">)</span></span></span>: 行列のサイズをrr行cc列に変更</li>
</ul>


<h2>置換</h2>
<p>置換は Permutation p; などで定義します．<br>p[i] = j は第i要素を第j番目に飛ばす，という意味です．<br>i も j も 0-origin です．<br>現状 p ** n の計算は（他の型と同様に）バイナリ法です．<br></p>
<p>コンストラクタ<br></p>
<ul><li>Permutation(): 要素数0の置換</li>
<li>Permutation(const int nn): 要素数nnの置換．メモリは確保するが初期化はしない．</li>
<li>Permutation(const Permutation &a)</li>
</ul>
<p>デストラクタ<br></p>
<ul><li>~Permutation()</li>
</ul>
<p>演算子<br></p>
<ul><li>Permutation&amp; operator=(const Permutation &a) : 恒等置換にします</li>
<li>Permutation&amp; operator=(const int a) : a=1 のとき，恒等置換にします．aが1でない場合は未定義です．</li>
<li>Permutation&amp; operator*=(const Permutation &amp;a) : 置換 a, b に対して，a * b は置換 b を作用させた後，置換 a を作用させるのと同値な置換を返します．順番に注意（ワーキングメモリを使用します）</li>
<li>Permutation operator*(const Permutation &amp;a)</li>
<li>bool operator==(const Permutation &amp;a)</li>
<li>inline int&amp; operator[](const int a)</li>
</ul>
<p>メンバ関数<br></p>
<ul><li>void p.changeSize(const int nn) : 置換のサイズを nn にします（メモリの確保をします，データは破壊されることがあります，nn次の置換）．</li>
<li>template&lt;class T&gt; void p.apply(T A[], T B[]) : 配列Aに置換を作用させて，その結果を配列Bに返します</li>
<li>template&lt;class T&gt; void p.apply(T A[]) : 配列Aに置換を作用させて，その結果で配列Aを上書きします（ワーキングメモリを使用します）</li>
<li>int p.cycle_len(int res[] = NULL) : 置換をサイクルに分解したとき，そのサイクルの長さからなる配列resを返します．戻り値はサイクルの数です．</li>
<li>void p.cycle_len_EachElement(int res[]) : res[i] に i を含むサイクルの長さを代入します．</li>
<li>template&lt;class T&gt; inline T p.getIndex(void *mem = wmem) : サイズ n の中で，辞書順で何番目の置換なのかを返す．Fenwick treeを利用してO(n log n)で求める．int型で求める場合は p.getIndex&lt;int&gt;() で（ただしすぐオーバーフローする）．</li>
</ul>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">8</span>,<span style="color:#AA00AA;">9</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">100</span>,<span style="color:#AA00AA;">800</span>,<span style="color:#AA00AA;">9</span>,<span style="color:#AA00AA;">10</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> B<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> sz<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> pp1<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">6</span>,<span style="color:#AA00AA;">7</span>,<span style="color:#AA00AA;">8</span>,<span style="color:#AA00AA;">9</span>,<span style="color:#AA00AA;">0</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> pp2<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">7</span>,<span style="color:#AA00AA;">6</span>,<span style="color:#AA00AA;">9</span>,<span style="color:#AA00AA;">8</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>

  <span style="color:#0000FF;">Permutation</span> p1, p2, m, id<span style="color:#000000;">;</span>
  p1.changeSize<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  p2.changeSize<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span> p1<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = pp1<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span> p2<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = pp2<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>



  wt<span style="color:#662222;">(</span>A<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>           <span style="color:#888888;">// 5 2 8 9 1 1 100 800 9 10
</span>  p1.apply<span style="color:#662222;">(</span>A, B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>           <span style="color:#888888;">// 10 5 2 8 9 1 1 100 800 9
</span>  p2.apply<span style="color:#662222;">(</span>A, B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>           <span style="color:#888888;">// 2 5 9 8 1 1 800 100 10 9
</span>


  m = p1 ** <span style="color:#AA00AA;">13</span><span style="color:#000000;">;</span>
  m.apply<span style="color:#662222;">(</span>A, B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>           <span style="color:#888888;">// 800 9 10 5 2 8 9 1 1 100
</span>


  m = p1 * p2<span style="color:#000000;">;</span>
  m.apply<span style="color:#662222;">(</span>A, B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>           <span style="color:#888888;">// 9 2 5 9 8 1 1 800 100 10
</span>
  p2.apply<span style="color:#662222;">(</span>A<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  p1.apply<span style="color:#662222;">(</span>A<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>A<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>           <span style="color:#888888;">// 9 2 5 9 8 1 1 800 100 10
</span>

  id.changeSize<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  id = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span>              <span style="color:#888888;">// identity
</span>  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    m = p1 ** i<span style="color:#000000;">;</span>
    <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>m==id<span style="color:#662222;">)</span> wt<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// i = 0, 10, 20, ..., 90
</span>  <span style="color:#440000;font-weight:bold;">}</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    m = p1 ** i<span style="color:#000000;">;</span>
    <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>m==p1<span style="color:#662222;">)</span> wt<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// i = 1, 11, 21, ..., 91
</span>  <span style="color:#440000;font-weight:bold;">}</span>


  sz = p1.cycle_len<span style="color:#662222;">(</span>B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>              <span style="color:#888888;">// 10
</span>  sz = p2.cycle_len<span style="color:#662222;">(</span>B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>              <span style="color:#888888;">// 2 2 2 2 2
</span>  sz = id.cycle_len<span style="color:#662222;">(</span>B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>              <span style="color:#888888;">// 1 1 1 1 1 1 1 1 1 1
</span><span style="color:#440000;font-weight:bold;">}</span>
</span></pre>

<h2>IntMap</h2>
<p>{0,1,...,n-1} から {0,1,...,n-1} の写像は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">IntMap</span> f<span style="color:#000000;">;</span></span></span> などで定義します．<br>f[i] = j は第i要素を第j番目に飛ばす，という意味です．<br></p>
<p>コンストラクタ<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">IntMap</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> : n=0</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">IntMap</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> nn<span style="color:#662222;">)</span></span></span> : 要素数n=nnとする．メモリは確保するが初期化はしない．</li>
</ul>
<p>デストラクタ<br></p>
<ul><li>~IntMap()</li>
</ul>
<p>演算子<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#4444FF;">inline</span> <span style="color:#0000FF;">int</span>&amp; operator<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> a<span style="color:#662222;">)</span></span></span> : これを使って写像を定義する</li>
</ul>
<p>メンバ関数<br></p>
<ul><li>void f.changeSize(const int nn) : n = nn にします（メモリの確保をします．f[i]の値や，過去計算した前計算の結果は破棄されます）．</li>
<li>int f.calcCycle(void) : サイクルを全て求める．戻り値はサイクルの数．サイクルの情報は変数のいくつかに代入される．O(n)時間．サイクルは x[0], x[1], x[2], ..., x[k] = x[0] で x[i+1] = f[x[i]] なるもの．</li>
<li>void f.calcNext(int recalc = 1) : s回写像を適応した結果，f^s[x] = f[f[...f[x]...]] を計算するための前処理をする．ダブリングとサイクルの計算を行う．calcCycleを行っていて，fの内容を破壊していないならrecalc=0で呼び出せばサイクルは再計算しない．O(n log n)時間．</li>
<li>template&lt;class T&gt; int f.getNext(int x, T s) : s回写像を適応した結果，f^s[x] = f[f[...f[x]...]] を返す．calcNext()を呼び出していない場合，初回に計算する．基本的にはO(log n)時間．Tは整数を表す型．</li>
</ul>
<p>変数<br></p>
<ul><li>int f.numCycle : サイクルの数．calcCycle()で計算される．</li>
<li>int f.cycleLen[i] : i番目のサイクルの要素数．calcCycle()で計算される．</li>
<li>int f.cycle[i][j] : i番目のサイクルのj番目の要素．calcCycle()で計算される．</li>
<li>int f.int2c[i] : 整数iが属するサイクルの番号．サイクルに属さないなら-1．calcCycle()で計算される．</li>
<li>int f.int2cInd[i] : 整数iが属するサイクルの要素番号（cycle[int2c[i]][int2cInt[i]] = i）．サイクルに属さないなら-1．calcCycle()で計算される．</li>
</ul>
<p>変数（多分使わない）<br></p>
<ul><li>int f.n</li>
<li>int f.mem : メモリ確保した配列サイズ</li>
<li>int f.nx[i][j] : ダブリングの配列．jを2^i回飛ばした先を格納</li>
<li>int f.calc_nx : nx配列を計算しているならば1，していなければ0</li>
<li>int f.logn : nx配列の1次元目のサイズ</li>
</ul>



<h2>Fenwick Tree (Binary Indexed Tree, BIT)</h2>
<p>（1次元の）Fenwick treeが使えます．<br>fenwick&lt;int&gt; t; などで定義します．この場合は各要素や和などを求める時に全てint型で計算されます．<br>扱う配列の長さの最大値を maxN として，t.malloc(maxN); または t.walloc(maxN); でメモリを確保します．<br>その後，配列の長さが N の場合に初期化（全要素を0にする）場合，t.init(N); とします．<br>メモリ確保とともに，確保したメモリ分の長さを初期化する場合は，t.malloc(N, 1); または t.walloc(N, 1); です．<br></p>
<p>関数などは以下の通り（fenwick&lt;T&gt; t; で宣言したとします．また，要素数を $N$ として，0番目の要素から$N$-1番目の要素まで存在します）：<br></p>
<ul><li>void t.malloc(int mem) : mem 要素分のメモリを確保します．malloc使用．</li>
<li>void t.malloc(int mem, int fg) : mem 要素分のメモリを確保し，fg が 0 でなければ mem 要素分 0 に初期化します．malloc使用．</li>
<li>void t.walloc(int mem, void **workMemory = &wmem) : mem 要素分のメモリを確保します．ワーキングメモリ使用．</li>
<li>void t.walloc(int mem, int fg, void **workMemory = &wmem) : mem 要素分のメモリを確保し，fg が 0 でなければ mem 要素分 0 に初期化します．ワーキングメモリ使用．</li>
<li>void t.add(int a, T val) : a 番目の要素の値に val を加えます．$O(\log N)$ 時間．</li>
<li>T t.get(int a): 0番目の要素，1番目の要素，…，a番目の要素の和を返します．$O(\log N)$ 時間．</li>
<li>T t.range(int a, int b): a番目の要素，a+1番目の要素，…，b番目の要素の和を返します．-2番目，-1番目，N番目，N+1番目などは0とみなします．bよりaのほうが大きい場合は0を返します．$O(\log N)$ 時間．</li>
<li>int t.kth(T v): 各要素は全て非負のとき，t.get(a)がvを超える最小のaを求めます．下の例も参照．$O((\log N)^2)$ 時間，現在は良くない実装．</li>
</ul>
<p>区間は閉区間 [a,b] の形で指定することに注意して下さい．<br></p>
<p>malloc()を使った場合のメモリの開放は t.free(); です．<br></p>

<pre><span style="color:#444444">  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">int</span> d<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">4</span>, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">5</span>, <span style="color:#AA00AA;">9</span>, <span style="color:#AA00AA;">2</span>, <span style="color:#AA00AA;">6</span>, <span style="color:#AA00AA;">5</span>, <span style="color:#AA00AA;">4</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> arr<span style="color:#441111;">[</span><span style="color:#AA00AA;">20</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> i, s<span style="color:#000000;">;</span>

    <span style="color:#0000FF;">fenwick</span>&lt;<span style="color:#0000FF;">int</span>&gt; t<span style="color:#000000;">;</span>
    t.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    t.init<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span> t.add<span style="color:#662222;">(</span>i,d<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

    s = t.get<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span>s<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// d[0]+d[1]+d[2]+d[3] = 3+1+4+1 = 9
</span>    s = t.range<span style="color:#662222;">(</span><span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">7</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span>s<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// d[5]+d[6]+d[7] = 9+2+6 = 17
</span>
    <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">20</span><span style="color:#662222;">)</span> arr<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = t.kth<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span>arr<span style="color:#662222;">(</span><span style="color:#AA00AA;">20</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 0がd[0]個，1がd[1]個，…からなる配列のk番目の要素
</span>                 <span style="color:#888888;">// 0 0 0 1 2 2 2 2 3 4 4 4 4 4 5 5 5 5 5 5
</span>  <span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>演算を + ではなく ^ にしたバージョンは fenwick_xor&lt;T&gt; です．<br>基本的な機能は同じですが，kth() がありません．<br></p>


<h2>バイナリヒープ（priority_queueとほぼ同様）</h2>
<p>Heap&lt;T&gt; h; もしくは Heap_max&lt;T&gt; hm; で宣言する．<br>Heapは通常の最小値を取り出せるやつ，Heap_maxは最大値を取り出せるやつ．<br>大体の操作は $O(\log size)$．<br></p>
<p>Heap&lt;T&gt; h; について：<br></p>
<ul><li>int h.size : ヒープに入っている要素数．</li>
<li>void h.malloc(const int N) : mallocを使ってN要素分を格納できるだけのメモリを確保．ヒープの中を空に設定する．</li>
<li>void h.walloc(const int N, void **mem = &wmem) : ワーキングメモリを使ってN要素分を格納できるだけのメモリを確保．ヒープの中を空に設定する．</li>
<li>void h.free() : mallocで確保したメモリを解放します．</li>
<li>void h.init() : ヒープを空にします（h.size = 0）．</li>
<li>T h.top() : ヒープの中にある最小値を返します．</li>
<li>T h.pop() : ヒープの中にある最小値を削除し，その値を返します．</li>
<li>T h.push(const T x) : ヒープの中にxを入れます．戻り値はxの値そのものを返します．</li>
</ul>
<p>Heap_max&lt;T&gt; hm; について：<br></p>
<ul><li>int hm.size : ヒープに入っている要素数．</li>
<li>void hm.malloc(const int N) : mallocを使ってN要素分を格納できるだけのメモリを確保．ヒープの中を空に設定する．</li>
<li>void hm.walloc(const int N, void **mem = &wmem) : ワーキングメモリを使ってN要素分を格納できるだけのメモリを確保．ヒープの中を空に設定する．</li>
<li>void hm.free() : mallocで確保したメモリを解放します．</li>
<li>void hm.init() : ヒープを空にします（h.size = 0）．</li>
<li>T hm.top() : ヒープの中にある最大値を返します．</li>
<li>T hm.pop() : ヒープの中にある最大値を削除し，その値を返します．</li>
<li>T hm.push(const T x) : ヒープの中にxを入れます．戻り値はxの値そのものを返します．</li>
</ul>


<h2>バイナリヒープ（固定長配列用）</h2>
<p><span id="code"><span style="color:#444444"><span style="color:#0000FF;">LHeap</span>&lt;<span style="color:#0000FF;">int</span>&gt;</span></span> などで宣言．<br>$N$ 要素の配列 $A_k = \verb|val[k]|$ を考える．<br>ヒープにある要素を入れたり値を変えたり（$\verb|change|$），ヒープの中に入っている最小の要素を取り出して取り出した要素の番号を返したり（$\verb|pop|$）する．<br>大体の操作の計算時間 $O(\log N)$．<br>以下は <span id="code"><span style="color:#444444"><span style="color:#0000FF;">LHeap</span>&lt;T&gt; h<span style="color:#000000;">;</span></span></span> で定義したとする．<br></p>
<p>よく使いそうなもの：<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> h.<span style="color:#000000;font-weight:bold;">malloc</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N<span style="color:#662222;">)</span></span></span>：$N$ 要素分のメモリを確保</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> h.<span style="color:#000000;font-weight:bold;">malloc</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> ini<span style="color:#662222;">)</span></span></span>：$N$ 要素分のメモリを確保し，iniが0でなければ init(N) もやる</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> h.walloc<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">void</span> **mem=&amp;wmem<span style="color:#662222;">)</span></span></span>：$\verb|mem|$ から $N$ 要素分のメモリを確保して，次のアドレスを返す</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> h.walloc<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> ini, <span style="color:#0000FF;">void</span> **mem=&amp;wmem<span style="color:#662222;">)</span></span></span>：$\verb|mem|$ から $N$ 要素分のメモリを確保して，次のアドレスを返し，iniが0でなければ init(N) もやる</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> h.<span style="color:#000000;font-weight:bold;">free</span><span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span></span></span>：<span id="code"><span style="color:#444444">h.<span style="color:#000000;font-weight:bold;">malloc</span><span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N<span style="color:#662222;">)</span></span></span>で確保したメモリの解放</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> h.init<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N<span style="color:#662222;">)</span></span></span>：初期化．今後 $N$ 要素の配列を使う．ヒープの中は空．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> h.change<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n, T v<span style="color:#662222;">)</span></span></span>：$A_k = v$ に変更する．ヒープに入っていない要素ならヒープに突っ込み，入っている要素だったら，適切な位置に移動する．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> h.pop<span style="color:#662222;">(</span><span style="color:#0000FF;">void</span><span style="color:#662222;">)</span></span></span>：ヒープに入っている最小の要素のインデックスを返し，その要素を消す．最小が $A_k$ なら $k$ を返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> h.<span style="color:#000000;font-weight:bold;">size</span></span></span>：ヒープに入っている要素の数．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> h.hp<span style="color:#441111;">[</span><span style="color:#441111;">]</span></span></span>：$\verb|hp[k]|$ でヒープに入っている $k$ 番目の要素のインデックス．$\verb|pop()|$ で取り出される要素のインデックスは $\verb|hp[0]|$．</li>
<li><span id="code"><span style="color:#444444">T h.val<span style="color:#441111;">[</span><span style="color:#441111;">]</span></span></span>：$A_k$ の値 $\verb|val[k]|$．</li>
</ul>
<p>そうではないもの：<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> h.place<span style="color:#441111;">[</span><span style="color:#441111;">]</span></span></span>：$\verb|place[k]|$ は $A_k$ がヒープに入っているならその位置，入っていないなら $-1$．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">double</span> v<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">LHeap</span>&lt;<span style="color:#0000FF;">double</span>&gt; hp<span style="color:#000000;">;</span>

  hp.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.init<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">0</span>, <span style="color:#AA00AA;">100.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">200.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">80.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">-200.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">150.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

  <span style="color:#0088FF;">while</span><span style="color:#662222;">(</span>hp.<span style="color:#000000;font-weight:bold;">size</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    i = hp.pop<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 1 -200.000000000000000
</span>    v = hp.val<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 0 100.000000000000000
</span>    wt<span style="color:#662222;">(</span>i,v<span style="color:#662222;">)</span><span style="color:#000000;">;</span>        <span style="color:#888888;">// 8 150.000000000000000
</span>  <span style="color:#440000;font-weight:bold;">}</span>
</span></pre>


<h2>バイナリヒープ（ダイクストラ用）</h2>
<p>DijkstraHeap&lt;int&gt; などで宣言．<br>バイナリヒープ（固定長配列用）のダイクストラ用にチューニングしたもの．<br>$\verb|pop|$ した時に $\verb|visited[]|$ のフラグを立てる，更新時に訪れたものや長くなったものは更新しないなどを関数の中で判定する．<br></p>
<p>よく使いそうなもの：<br></p>
<ul><li>$\verb|malloc(int N)|$：$N$ 要素分のメモリを確保</li>
<li>$\verb|malloc(int N, int init_fg)|$：malloc(N) する．その後，init_fg は 0 でないなら init(N) もする</li>
<li>$\verb|walloc(int N, void **mem = &amp;wmem)|$：$\verb|mem|$ から $N$ 要素分のメモリを確保して，次のアドレスを返す</li>
<li>$\verb|walloc(int N, int init_fg, void **mem = &amp;wmem)|$：walloc(N,mem) する．その後，init_fg は 0 でないなら init(N) もする</li>
<li>$\verb|free(void)|$：$\verb|malloc(int N)|$で確保したメモリの解放</li>
<li>$\verb|init(int N)|$：初期化．今後 $N$ 要素の配列を使う．ヒープの中は空</li>
<li>$\verb|change(int n, T v)|$：$A_k$ を既に処理していないなら，$A_k = \min(A_k, v)$ に変更する．ヒープに入っていない要素ならヒープに突っ込み，入っている要素だったら，適切な市に移動する</li>
<li>$\verb|pop(void)|$：ヒープに入っている最小の要素のインデックスを返し，その要素を消す．最小が $A_k$ なら $k$ を返す</li>
<li>$\verb|int size|$：ヒープに入っている要素の数</li>
<li>$\verb|int hp[]|$：$\verb|hp[k]|$ でヒープに入っている $k$ 番目の要素のインデックス．$\verb|pop()|$ で取り出される要素のインデックスは $\verb|hp[0]|$</li>
<li>$\verb|T val[]|$：$A_k$ の値 $\verb|val[k]|$</li>
<li>$\verb|char visited[]|$：$A_k$ を始点とする枝たちを処理したなら $1$，そうでないなら $0$</li>
</ul>
<p>そうではないもの：<br></p>
<ul><li>$\verb|int place[]|$：$\verb|place[k]|$ は $A_k$ がヒープに入っているならその位置，入っていないなら $-1$．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">double</span> v<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">DijkstraHeap</span>&lt;<span style="color:#0000FF;">double</span>&gt; hp<span style="color:#000000;">;</span>

  hp.walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.init<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">0</span>, <span style="color:#AA00AA;">100.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">200.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">80.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">-200.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  hp.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">150.0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

  <span style="color:#0088FF;">while</span><span style="color:#662222;">(</span>hp.<span style="color:#000000;font-weight:bold;">size</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    i = hp.pop<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 1 -200.000000000000000
</span>    v = hp.val<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 8 80.000000000000000
</span>    wt<span style="color:#662222;">(</span>i,v<span style="color:#662222;">)</span><span style="color:#000000;">;</span>        <span style="color:#888888;">// 0 100.000000000000000
</span>  <span style="color:#440000;font-weight:bold;">}</span>
</span></pre>


<h2>セグメントツリー（標準的なの？）</h2>
<p>（1次元の）セグメントツリーが使えます．<br>segtree&lt;int&gt; t; などで定義します．この場合は各要素や和などを求める時に全てint型で計算されます．<br>1回のみ使用する場合は，配列の長さを N として t.malloc(N, 1); とすると，配列の要素が全て 0 で初期化され，セグメントツリーが使えるようになります．<br>何回も使いまわす可能性がある場合は，配列の長さの最大値を maxN として，t.malloc(maxN); でメモリを確保します．<br>その後，配列の長さが N の場合にセグメントツリーを使えるようにするためには，t.setN(N); で使えるようになります．<br>mallocの代わりにwallocでワーキングメモリを使ってメモリを確保します．<br></p>
<p>0以外で初期化したい場合は，t.setN(N,0,0);（各要素は全く初期化されない），または，t.setN(N,1,0); （各要素は一応0で初期化される）としておき，<br>t[hoge] = 要素hogeの初期値;<br>と適当に初期化した後，t.build();とすれば使えるようになります．<br></p>
<p>segtree&lt;T&gt; t; とした場合，使える感じの関数は以下の通り（要素数を $N$ として，0番目の要素から$N$-1番目の要素まで存在します）：<br></p>
<ul><li>void t.change(int a, int b, T val): a番目の要素，a+1番目の要素，…，b-1番目の要素の値を val にします．$O(\log N)$ 時間．</li>
<li>void t.add(int a, int b, T val): a番目の要素，a+1番目の要素，…，b-1番目の要素の値に val を加えます．$O(\log N)$ 時間．</li>
<li>T t.getSum(int a, int b): a番目の要素，a+1番目の要素，…，b-1番目の要素の和を返します．$O(\log N)$ 時間．</li>
<li>pair&lt;T, int&gt; t.getMin(int a, int b): a番目の要素，a+1番目の要素，…，b-1番目の要素の (最小値, その最小値を実現する最初の要素の番号) を返します．$O(\log N)$ 時間．</li>
<li>T t.getMinVal(int a, int b): a番目の要素，a+1番目の要素，…，b-1番目の要素の最小値を返します．$O(\log N)$ 時間．</li>
<li>int t.getMinInd(int a, int b): a番目の要素，a+1番目の要素，…，b-1番目の要素の最小値を実現する最初の要素の番号を返します．$O(\log N)$ 時間．</li>
</ul>
<p>区間は最初は含むが最後は含まない [a,b) の形で指定することに注意して下さい．<br></p>
<p>malloc()を使った場合のメモリの開放は t.free(); です．<br></p>


<h2>セグメントツリー（亜種？）</h2>
<p>初期化の仕方などは標準的な segtree と同じですが，機能が制限されていたり，変な機能がついているものです．<br>基本的に必要な機能のみがついているものを使うと，速くて省メモリのはずです．<br>基本的に構造体の名前が segtree_[変更に対する対応クエリの羅列]_[取得に関する対応クエリの羅列] という形式になっています（長い…）．<br>例えば，<br>segtree_Point_SumMin&lt;T&gt; t;<br>だと，変更に関するクエリの<br>void t.add(int x, T val)<br>void t.change(int x, T val)<br>と取得に関するクエリの<br>T t.getSum(int a, int b)<br>pair&lt;T, int&gt; t.getMin(int a, int b)<br>T t.getMinVal(int a, int b)<br>int t.getMinInd(int a, int b)<br>が使用できます．<br></p>
<p>変更に関するクエリと構造体の名前に含まれていたら使用できるという文字列（,で区切られている場合どれかが含まれていれば使用可能）<br></p>
<ul><li>void t.change(int x, T val) : <span style="text-decoration: underline;">Point</span> : x番目の要素を val に変更します</li>
<li>void t.add(int x, T val) : <span style="text-decoration: underline;">Point</span> : x番目の要素に val を足し込みます</li>
<li>void t.change(int a, int b, T val) : <span style="text-decoration: underline;">Change</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の値を val にします</li>
<li>void t.add(int a, int b, T val) : <span style="text-decoration: underline;">Add, P1add</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の値に val を加えます</li>
<li>void t.p1add(int a, int b, T x1, T x0) : <span style="text-decoration: underline;">P1add</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の値に x0, x0+x1, x0+2*x1, ..., x0+(b-a-1)*x_1 を加えます</li>
</ul>
<p>取得に関するクエリと構造体の名前に含まれていたら使用できるという文字列（,で区切られている場合どれかが含まれていれば使用可能）<br></p>
<ul><li>T t.getAt(int i) : <span style="text-decoration: underline;">At</span> : i番目の要素を返します</li>
<li>T t.getSum(int a, int b) : <span style="text-decoration: underline;">Sum</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の和を返します</li>
<li>T t.getProd(int a, int b) : <span style="text-decoration: underline;">Prod</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の積を返します</li>
<li>T t.getOr(int a, int b) : <span style="text-decoration: underline;">Or</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素のビットごとのorを返します</li>
<li>T t.getAnd(int a, int b) : <span style="text-decoration: underline;">And</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素のビットごとのandを返します</li>
<li>T t.getXor(int a, int b) : <span style="text-decoration: underline;">Xor</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素のビットごとのxorを返します</li>
<li>pair&lt;T, int&gt; t.getMin(int a, int b) : <span style="text-decoration: underline;">Min</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の (最小値, その最小値を実現する最初の要素の番号) を返します</li>
<li>T t.getMinVal(int a, int b) : <span style="text-decoration: underline;">Minval, Min, Minval2</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の最小値を返します</li>
<li>int t.getMinInd(int a, int b) : <span style="text-decoration: underline;">Min</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の最小値を実現する最初の要素の番号を返します</li>
<li>pair&lt;T, T&gt; t.getMinVal2(int a, int b) : <span style="text-decoration: underline;">Minval2</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の（最小値，2番目に小さい値）を返します．範囲内の要素数1でで2番目に小さい値が存在しない場合は numeric_limits&lt;T&gt;::max() が入っています．</li>
<li>T t.getMaxVal(int a, int b) : <span style="text-decoration: underline;">Maxval</span> : a番目の要素，a+1番目の要素，…，b-1番目の要素の最大値を返します</li>
</ul>
<p>定義されている構造体<br></p>
<ul><li>segtree_Point_Minval&lt;T&gt; t</li>
<li>segtree_Point_Maxval&lt;T&gt; t</li>
<li>segtree_Point_Min&lt;T&gt; t</li>
<li>segtree_Point_SumMin&lt;T&gt; t: 1点更新の標準的なsegtree</li>
<li>segtree_Point_Prod&lt;T&gt; t</li>
<li>segtree_Point_Or&lt;T&gt; t</li>
<li>segtree_Point_And&lt;T&gt; t</li>
<li>segtree_Point_Xor&lt;T&gt; t</li>
<li>segtree_Point_Minval2&lt;T&gt; t</li>
<li>segtree_Add_Minval&lt;T&gt; t</li>
<li>segtree_Change_Sum&lt;T&gt; t</li>
<li>segtree_ChangeAdd_Sum&lt;T&gt; t</li>
<li>segtree_ChangeP1add_Sum&lt;T&gt; t</li>
</ul>
<p>その他の事項：<br>segtree_ChangeAdd_SumMin は通常の segtree を使ってください．<br>segtree_Point_Sum（1点更新で和を求めるだけのもの）はfenwickでできます（が，t.change(int x, T val) に対応するには値を配列などに保持し，差分を足してください）．<br></p>


<h2>セグメントツリー（1点更新の汎用的なの）</h2>
<p>segtree_ph&lt;T&gt; t; で定義します．<br>初期化は通常のsegtreeと同じですが，0で初期化するように指定しても初期化されません（同じように書けるように引数は存在します）．<br></p>
<p>res = f(a, b) を計算する関数<br>T segtree_ph_func(T a, T b){ hoge; }<br>をグローバルで定義しておきます．fは結合律 f(a,f(b,c)) = f(f(a,b),c) =: f(a,b,c) を満たすとします．<br></p>
<ul><li>void t.change(int x, T val) : x番目の要素を val に変更します</li>
<li>T t.get(int a, int b) : f(a番目の要素，a+1番目の要素，…，b-1番目の要素) を返します．<strong>a = bの場合は何を返すか不定</strong>です．</li>
</ul>
<p>例えば，T = int で，<br>int segtree_ph_func(int a, int b){ return a + b; }<br>を作っておくと，1点更新で，区間和を求めることができるsegtreeになります．<br></p>
<p>ただし，基本的には，汎用的に利用するため，構造体と関数を新しく定義して利用することを想定しています．<br>実装方法は以下も参考にしてください．<br><a href="http://rsujskf.s602.xrea.com/?codeforces_672_div2_c2">Codeforces Round #672 DIV2 C2問題 - Pokemon Army (hard version)</a><br></p>


<h2>セグメントツリー（1点更新の汎用的なの，旧版）</h2>
<p>segtree_phとの違いは segtree_p*_func の形式です．<br></p>
<p>segtree_pg&lt;T&gt; t; で定義します．<br>初期化は通常のsegtreeと同じですが，0で初期化するように指定しても初期化されません（同じように書けるように引数は存在します）．<br></p>
<p>res = f(a, b) を計算する関数<br>void segtree_pg_func(T &res, T &a, T &b){ hoge; }<br>をグローバルで定義しておきます．fは結合律 f(a,f(b,c)) = f(f(a,b),c) =: f(a,b,c) を満たすとします．<br></p>
<ul><li>void t.change(int x, T val) : x番目の要素を val に変更します</li>
<li>T t.get(int a, int b) : f(a番目の要素，a+1番目の要素，…，b-1番目の要素) を返します．<strong>a = bの場合は何を返すか不定</strong>です．</li>
</ul>
<p>例えば，T = int で，<br>void segtree_pg_func(int &res, int a, int b){ res = a + b; }<br>を作っておくと，1点更新で，区間和を求めることができるsegtreeになります．<br></p>
<p>ただし，基本的には，汎用的に利用するため，構造体と関数を新しく定義して利用することを想定しています．<br>実装方法は以下も参考にしてください．<br><a href="http://rsujskf.s602.xrea.com/?codeforces_672_div2_c2">Codeforces Round #672 DIV2 C2問題 - Pokemon Army (hard version)</a><br></p>
<p>segtree_pg 名前の由来は p は1点更新を意味する point，g はグローバルに関数を定義する形式から名前をつけています．<br></p>


<h2>セグメントツリー（区間更新の汎用的なの）</h2>
<p>segtree_rh&lt;SVAL, SFUN&gt; t; で定義します．<br>初期化は通常のsegtreeと同じですが，0で初期化するように指定しても初期化されません（同じように書けるように引数は存在します）．<br></p>
<p>res = h(a, b) を計算する関数<br>SVAL segtree_rh_merge(SVAL a, SVAL b){ hoge; }<br>をグローバルで定義しておきます．hは結合律 h(a,h(b,c)) = h(h(a,b),c) =: h(a,b,c) を満たすとします．<br></p>
<p>変更に関して，res = f(a) を計算する関数<br>SVAL segtree_rh_apply(SFUN f, SVAL a){ hoge; }<br>および，関数の合成 res(x) = f(g(x)) なる関数 res を計算する関数<br>SFUN segtree_rh_compose(SFUN f, SFUN g){ hoge; }<br>をグローバルで定義しておきます．<br></p>
<ul><li>void t.change(int a, int b, SFUN f) : k=a,a+1,...,b-1に対して，k番目の要素 v[k] を f(v[k]) に変更します．</li>
<li>T t.get(int a, int b) : h(a番目の要素，a+1番目の要素，…，b-1番目の要素) を返します．<strong>a = bの場合は何を返すか不定</strong>です．</li>
<li>template&lt;bool (*f)(SVAL)&gt;int t.max_right(int a, int mx) : fはtemplateで指定された関数として f(g(v[a], v[a+1], ..., v[b-1])) が true になる最大の b を返します（単調性を仮定します）．ただし b の値は mx まで調べます（f(h(...))の...の部分にv[mx以上]が含まれていたら即座にfalseになります）．</li>
<li>template&lt;bool (*f)(SVAL)&gt;int t.max_right(int a) : min_left(a, trueN) です．ただし trueN は setN で設定した時の引数の N です．</li>
<li>template&lt;bool (*f)(SVAL)&gt;int t.min_left(int b, int mn) : fはtemplateで指定された関数として f(g(v[a], v[a+1], ..., v[b-1])) が true になる最小の a を返します（単調性を仮定します）．ただし a の値は mn まで調べます（f(h(...))の...の部分にv[mn未満]が含まれていたら即座にfalseになります）．</li>
<li>template&lt;bool (*f)(SVAL)&gt;int t.min_left(int b) : min_left(b, 0) です</li>
</ul>
<p>AtCoder Libraryのlazy_segtreeとだいたい同じ機能です．実装方法は例えば以下を参考にしてください．<br><a href="http://rsujskf.s602.xrea.com/?atcoder_practice2_k">AtCoder Library Practice Contest K問題 - Range Affine Range Sum</a><br><a href="http://rsujskf.s602.xrea.com/?atcoder_practice2_l">AtCoder Library Practice Contest L問題 - Lazy Segment Tree</a><br><a href="http://rsujskf.s602.xrea.com/?codeforces_684_div1_c">Codeforces Round #684 DIV1 C問題 - Greedy Shopping</a> (二分探索の参考)<br></p>
<p>また，changeでは全て一定値で置き換え，getで最小値を取得の場合は，segtree_rh&lt;ll, ll&gt; で，<br>ll segtree_rh_apply(ll f, ll a){ return f; }<br>ll segtree_rh_merge(ll a, ll b){ return min(a, b); }<br>ll segtree_rh_compose(ll f, ll g){ return f; }<br>などでできますが，複雑になると構造体を作ったほうがわかりやすい気がします．<br></p>


<h2>セグメントツリー（区間更新の汎用的なの，旧版）</h2>
<p>segtree_rh との違いは segtree_rg_func の関数名，関数の形式の違いと，恒等写像を用意する必要があるところです．<br></p>
<p>segtree_rg&lt;SVAL, SFUN&gt; t; で定義します．<br>初期化は通常のsegtreeと同じですが，0で初期化するように指定しても初期化されません（同じように書けるように引数は存在します）．<br></p>
<p>res = h(a, b) を計算する関数<br>void segtree_rg_func(SVAL &res, SVAL a, SVAL b){ hoge; }<br>をグローバルで定義しておきます．hは結合律 h(a,h(b,c)) = h(h(a,b),c) =: h(a,b,c) を満たすとします．<br></p>
<p>変更に関して，res = f(a) を計算する関数<br>void segtree_rg_func(SVAL &res, SFUN f, SVAL a){ hoge; }<br>および，関数の合成 res(x) = f(g(x)) なる関数 res を計算する関数<br>void segtree_rg_func(SFUN &res, SFUN f, SFUN g){ hoge; }<br>をグローバルで定義しておきます．<br>また，恒等写像を表す写像 res を返す<br>void segtree_rg_id(SFUN &res)<br>もグローバルで定義しておきます．<br></p>
<ul><li>void t.change(int a, int b, SFUN f) : k=a,a+1,...,b-1に対して，k番目の要素 v[k] を f(v[k]) に変更します．</li>
<li>T t.get(int a, int b) : h(a番目の要素，a+1番目の要素，…，b-1番目の要素) を返します．<strong>a = bの場合は何を返すか不定</strong>です．</li>
</ul>
<p>SVAL, SFUN を同じ型にすることは現状できません．<br>基本的には，汎用的に利用するため，構造体と関数を新しく定義して利用することを想定しています．<br></p>
<p>AtCoder Libraryのlazy_segtreeとだいたい同じ機能です．実装方法は例えば以下を参考にしてください．<br><a href="http://rsujskf.s602.xrea.com/?atcoder_practice2_k">AtCoder Library Practice Contest K問題 - Range Affine Range Sum</a><br><a href="http://rsujskf.s602.xrea.com/?atcoder_practice2_l">AtCoder Library Practice Contest L問題 - Lazy Segment Tree</a><br></p>
<p>また，changeでは全て一定値で置き換え，getで最小値を取得の場合は，segtree_rg&lt;int, ll&gt; で，<br>void segtree_rg_id(ll &res){ res = ll_inf; }<br>void segtree_rg_func(int &res, ll f, int a){ res = if[f==ll_inf, a, f]; }<br>void segtree_rg_func(int &res, int a, int b){ res = min(a, b); }<br>void segtree_rg_func(ll &res, ll f, ll g){ res = if[f==ll_inf, g, f]; }<br>などでできますが，構造体を作る余裕があるなら作ったほうがわかりやすい気がします．<br></p>
<p>segtree_rg 名前の由来は r は区間更新を意味する range，g はグローバルに関数を定義する形式から名前をつけています．<br></p>


<h2>static segment tree</h2>
<p>segment treeではないです（segment treeと同じインターフェースで利用できるようにしています）．<br>範囲に足し算するのは差分を2箇所操作する，和を求めるには累積和を事前計算しておくなどして，<br>変更クエリ・取得クエリのみを続けて行う際は，最初の1回除きできるだけ効率よく計算できるようにします．<br>変更クエリと取得クエリを繰り返して行うと性能が劣化します．<br>セグメントツリー（亜種？）と同様の形式です．<br>定義されている構造体<br></p>
<ul><li>static_segtree_Add_At&lt;T&gt; t</li>
</ul>
<p>参考：<a href="http://rsujskf.s602.xrea.com/?leetcode_1674">LeetCode Weekly Contest 217 3問目 - Minimum Moves to Make Array Complementary [1674]</a><br></p>



<h2>2次元領域木，2d range tree</h2>
<p>2次元平面内の長方形領域に含まれる点の重みの和を求める．<br>rangeTree2d&lt;S,T1,T2&gt; t; で定義する．<br>Sは重みの型，T1は1次元目（x座標）の型，T2は2次元目（y座標）の型．<br>実装は現状，y座標の区間を扱うようなsegment treeで，各ノードには対応するx座標値をソートして保持，x座標の区間の重みを計算できるようにFenwick treeを保持．<br>領域量は O(N log N) でワーキングメモリを結構使うので注意．必要ならば，//working_memory=300m などしておくと良い．<br></p>
<ul><li>inline void build(int nn, T1 dd1[], T2 dd2[], S ww[] = NULL, void **mem = &wmem) : 点の数 nn，i番目の点の座標 (dd1[i], dd2[i]) で重みが ww[i]．ww[] = NULL の場合は，全ての点の重みを 1 にします．時間計算量は O(N log N)．</li>
<li>inline void add(T1 x, T2 y, S v) : 点 (x,y) の重みを +v する．ただし，点 (x,y) が存在することを仮定している．2つ以上存在したら1個のみに +v する．時間計算量は O((log N)^2)．</li>
<li>inline S query(T1 x1, T1 x2, T2 y1, T2 y2) : x1 &le; x &lt; x2, y1 &le; y &lt; y2 なる点 (x,y) の重みの和を求める．時間計算量は O((log N)^2)．</li>
</ul>
<p>重みが一様（全て1）のバージョン rangeTree2d_nw もあります．nwはnon-weightedのつもり．<br>rangeTree2d_nw&lt;T1,T2&gt; t; で定義する．<br></p>
<ul><li>inline void build(int nn, T1 dd1[], T2 dd2[], void **mem = &wmem)</li>
<li>inline int query(T1 x1, T1 x2, T2 y1, T2 y2) : x1 &le; x &lt; x2, y1 &le; y &lt; y2 なる点 (x,y) の数を求める．</li>
</ul>


<h2>2次元領域木，2d range tree（抽象化版）</h2>
<p>2次元平面内の長方形領域に含まれる点の重み w1, w2, ..., wn に対して f(w1, w2, ..., wn) を求める（可換かつモノイド）．<br>rangeTree2d_pf&lt;S,T1,T2&gt; t; で定義する．<br>領域量は O(N log N) でワーキングメモリを rangeTree2d 以上に使うので注意（Fenwick treeの代わりにSegment treeで管理します）．必要ならば，//working_memory=300m などしておくと良い．<br></p>
<ul><li>inline void t.build(int nn, T1 dd1[], T2 dd2[], S ww[] = NULL, void **mem = &wmem) : 点の数 nn，i番目の点の座標 (dd1[i], dd2[i]) で重みが ww[i]．ww[] = NULL の場合は点の重みは初期化しません．時間計算量は O(N log N)．</li>
<li>inline void t.change(T1 x, T2 y, S v) : 点 (x,y) の重みを v にする．ただし，点 (x,y) が存在することを仮定している．2つ以上存在したら壊れるかもしれない．時間計算量は O((log N)^2)．</li>
<li>inline void t.add(T1 x, T2 y, S v) : 点 (x,y) の重みを +v する．ただし，点 (x,y) が存在することを仮定している．2つ以上存在したら壊れるかもしれない．時間計算量は O((log N)^2)．</li>
<li>inline void t.setDefault(const S val) : queryにおいて対応する点が存在しない場合に返す値defvalをvalにセットします．</li>
<li>inline S t.query(T1 x1, T1 x2, T2 y1, T2 y2) : x1 &le; x &lt; x2, y1 &le; y &lt; y2 なる点 (x,y) の重みに対して f(w) を求める．そのような点が存在しない場合はsetDefaultで設定したdefvalを返す（呼び出していないなら何を返すか不定）．時間計算量は O((log N)^2)．</li>
</ul>
<p>関数 f を表す関数<br>S rangeTree2d_pf_func(S a, S b)<br>をグローバルに定義しておいてください．<br>例えば，rangeTree2d_pf&lt;int,int,int&gt; t; において，最小値を求める場合は，<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> rangeTree2d_pf_func<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> a, <span style="color:#0000FF;">int</span> b<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0088FF;">return</span> <span style="color:#000000;font-weight:bold;">min</span><span style="color:#662222;">(</span>a,b<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>とすれば良く，この場合は t.setDefault(int_inf) などを呼び出しておくと良いです．<br></p>
<p>f(x,y,z,w) = f(x,f(y,f(z,w))) みたいに計算されます．<br></p>


<h2>グラフ（構造体）</h2>
<p>graph構造体を使えます．graph g; などで定義します．<br></p>
<ul><li>int g.N : ノード数</li>
<li>int *g.es : g.es[i] はノード i から出ている枝の本数</li>
<li>int **g.edge : g.edge[i][j] はノード i から出ている j 番目の枝が向かう先のノード番号</li>
<li>void g.setEdge(int N, int M, int A[], int B[], void **mem=&wmem) : ノード数 N，枝数 M の無向グラフをセット（g.N, g.es, g.edgeを書き換え）します．(A[i], B[i])間に枝があります．枝は登場順に格納します．ワーキングメモリを使用し，wmemは使用した分勝手に進みます．</li>
<li>void g.setDirectEdge(int N, int M, int A[], int B[], void **mem=&wmem) : ノード数 N，枝数 M の有向グラフをセットします．A[i]からB[i]に向かう枝があります．ワーキングメモリを使用し，wmemは使用した分勝手に進みます．</li>
<li>void g.setEdgeRootedTree(int N, int M, int A[], int B[], int root=0, int reorder=0, int cnv[] = NULL, void **mem = &wmem) : ノード数 N，枝数 M の根付き木をセットします．A[i], B[i] の順番は問わず，親から子に向かう枝のみを設定します．reorder=1の場合は，節点の番号を根に近いから振り直します（番号が大きくなる方向にのみ枝があるようになります）．cnv[i] = k は番号を付け替えた後のノード i はもともとのデータではノード k だったことを意味します．ワーキングメモリを使用し，wmemは使用した分勝手に進みます．</li>
<li>graph g.reverse(void **mem=&wmem) : 枝の向きを逆にしたグラフを返す</li>
<li>void g.getDist(int root, int res[], void *mem=wmen) : ノードrootから各ノードまでの距離をBFSで求めます．辿り着けないノードまでの距離は -1 を返します．ワーキングメモリを使います．</li>
<li>int g.getDist(int a, int b, void *mem=wmen) : ノードaとノードbの間の最短距離をBFSで求めます．辿り着けない場合は -1 を返します．ワーキングメモリを使います．</li>
<li>int g.TreeDiameter(void *mem=wmen) : グラフの直径を返します．つまりdist(a,b)の最大値を返します．木であると仮定します．</li>
<li>int g.TreeDiameter(int &a, int &b, void *mem=wmen) : グラフの直径とdist(a,b)が最大となるようなa,bを1組求めます．木であると仮定します．</li>
<li>template&lt;class S1, class S2&gt; void getDistTree_WeightedNode_max(int root, S1 w[], S2 res[], void *mem = wmem) : 木であると仮定します．ノードrootから各ノード i までに通るノードの重み w[k] の最大値 res[i] を求めます．</li>
<li>void g.getDistPairMatrix(int k, int ind[], T **d, void *mem = wmem) : d[i][j] = 「ノードind[i]とノードind[j]の最短距離」を計算して代入します．配列indのサイズがkです．辿り着けない場合は-1にします．dはメモリ確保済みであること．BFSをk-1回程度行います．参考：<a href="http://rsujskf.s602.xrea.com/?atcoder_beginner_contest_190_e">AtCoder Beginner Contest 190 E問題 - Magical Ornament</a>．</li>
<li>void g.SubTreeSize(int root, int res[], void *mem=wmen) : 根をrootとして，各ノードiを根とする部分木に含まれるノードの数 res[i] を求めます．グラフが無向木・有向木じゃない場合は何が起こるか不定です．</li>
<li>template&lt;class S&gt; void g.SubTreeWeight(int root, S weight[], S res[], void *mem=wmen) : 根をrootとして，各ノードiを根とする部分木に含まれるノードの重みの和 res[i] を求めます．グラフが無向木・有向木じゃない場合は何が起こるか不定です．</li>
<li>template&lt;class S&gt; void g cntShortest(int root, int dist[], S cnt[], void *mem = wmem) : ノードrootから各ノードまでの距離と最短距離を達成する方法の数をBFSで求めます．辿り着けないノードまでの距離は -1，方法の数は 0 を返します．ワーキングメモリを使います．</li>
<li>graph g.reduce(int tn, int ind[], int self_e = 0, int dep_e = 0, void **mem = &wmem) : ノード i を新しくノード番号を ind[i] と付け替えたグラフを返します．複数のノードを1つにまとめることができます．ind[i]=-1とするとノードiは消えます．self_e=0なら結果のグラフでセルフループとなる枝は削除されます．dep_e=0なら結果のグラフで同じノード間をつなぐ枝が複数あるなら1つを残し削除されます．tnは返すグラフのノード数です．</li>
<li>int g.scc(int res[], void *mem = wmem) : 強連結成分分解．強連結の数が戻り値として返し，res[i]はノードiが何番の強連結に属すか返す．</li>
<li>int g.bcc(int res[], void *mem = wmem) : 二重連結成分分解．二重連結の数が戻り値として返し，res[i]はノードiが何番の二重連結に属すか返す．</li>
<li>int g.articulation(int res[], void *mem=wmem) : 無向グラフの関節点を列挙します．戻り値は関節点の数で，rep[]に関節点のノード番号を入れます．</li>
<li>int g.shortestPath(const int s, const int t, int res[], void *mem=wmem) : ノードsからノードtへの最短路の1つをbfsで求める．戻り値は距離．戻り値3，配列 res={s,0,1,t} のような感じで，配列は距離+1個の要素になる．たどり着けないなら-1を返す．</li>
<li>int g.TopologicalSort(int res[], void *mem=wmem) : トポロジカルソートした結果をresに格納する．i &lt; j ならノードres[j]からノードres[i]に枝はない．成功したら1を返し，グラフがDAGじゃない場合は0を返す．</li>
<li>int g.longestPath_length(void *mem = wmem) : 有向グラフに対して最も長いパスの長さを求めます．閉路があるなら-1を返します．参考：<a href="http://rsujskf.s602.xrea.com/?atcoder_beginner_contest_135_f">AtCoder Beginner Contest 135 F問題 - Strings of Eternity</a>．</li>
<li>int g.Grundy(int res[], void *mem=wmem) : DAGに対して各ノードのGrundy数を求めます．正確には，iから出ている枝の終点のノードからなる集合をSとすると，$\verb|res|[i] = \min \{k \in \mathbb{Z}_{\geq 0} \mid {}^\forall j \in S, \verb|res|[j] \neq k\}$となります．戻り値はDAGでなければ0を返し（resは計算されません），DAGなら1を返します．</li>
<li>int g.preorder(int res[], int root=0, void *mem=wmem) : ノード番号 root から dfs した結果の行きがけ順（ノードにたどり着いた順番）にノード番号を格納した配列 res を求める．たどり着けたノード数 = res の要素数を戻り値として返す．dfs で使う枝は格納順に使用していきます．</li>
<li>int g.anUndirectedCycle(int res[] = NULL, void *mem = wmem) : 無向グラフに対してサイクルを1つ求める．戻り値はサイクルの長さ．サイクルが存在しなければ-1を返す．長さ3の場合の res の中身は {3,9,0,3} の用な感じで長さ+1個の要素を使う．時間計算量は $O(N+M)$．何を返すかわからない（一応極小なものを返す気がする）．</li>
<li>int g.shortestCycle(int res[] = NULL, void *mem=wmem) : 有向グラフに対して長さ最小のサイクルを求める．戻り値はサイクルの長さ．サイクルが存在しなければ-1を返す．長さ3の場合の res の中身は {3,9,0,3} の用な感じで長さ+1個の要素を使う．時間計算量は $O(N(N+M))$．</li>
<li>int g.shortestUndirectedCycle_length(void *mem=wmem) : 無向グラフに対して長さ最小のサイクル（同じ枝を2回通らない）の長さを求める．自己ループがあれば1，多重枝があれば2，サイクルが存在しなければ-1を返す．時間計算量は $O(N(N+M))$．</li>
<li>int g.shortestUndirectedCycle_length(const int node, void *mem=wmem) : 無向グラフに対して，ノード node を通る，長さ最小のサイクル（同じ枝を2回通らない）の長さを求める．自己ループがあれば1，多重枝があれば2，サイクルが存在しなければ-1を返す．時間計算量は $O(N(N+M))$．</li>
<li>int g.maxIndependenceSet(int res[] = NULL, void *mem = wmem) : 単純無向グラフに対して，最大独立集合の要素数を返します．res[]は最大独立集合に含まれるノード番号を入れます．枝刈り全探索です．$N=100$ぐらいまでなら何とかなる気がします．</li>
<li>ll g.countIndependenceSet(void *mem = wmem) : 単純無向グラフに対して，独立集合の数を返します．全探索です．$N=40$ぐらいまでなら何とかなる気がします．</li>
<li>int g.bipartite(int res[] = NULL, void *mem = wmem) : 無向グラフに対して二部グラフかどうかを判定します．二部グラフなら1を，そうでないなら0を返します．res[i] は 0 か 1 で2色で塗り分けたときのノードiの色を返します．</li>
</ul>
<p>無向木に対する全方位DP（Rerooting）<br></p>
<ul><li>template&lt;class V&gt; void Rerooting(V res[], void *mem = wmem)</li>
</ul>
<p>wgraphにあるRerootingでECostがなくなって，関数の名前の最初にwがなくなったものです．<br>wgraphのほうの説明を見てください．<br></p>
<p>例えば，グローバルに<br>struct rval{ int sz; ll dist; };<br>void RerootingId(rval &a){ a = {0, 0}; }<br>rval RerootingMerge(rval a, rval b){ return {a.sz + b.sz, a.dist + b.dist}; }<br>rval RerootingEdge(rval a, int EFrom, int ETo){ return a; }<br>rval RerootingNode(rval a, int Nind){ return {a.sz+1, a.dist+a.sz}; }<br>を用意しておくと，<br>szにそのノードを根とする部分木のノード数＝全体のノード数<br>distにそのノードから他のノードまでの距離の総和<br>を求めることになります．<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> N = <span style="color:#AA00AA;">6</span>, M = <span style="color:#AA00AA;">7</span><span style="color:#000000;">;</span>                       <span style="color:#888888;">//  0 → 1 ← 2
</span>  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">7</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">0</span>, <span style="color:#AA00AA;">0</span>, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">2</span>, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">4</span>, <span style="color:#AA00AA;">5</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>       <span style="color:#888888;">//  |    ^    |
</span>  <span style="color:#0000FF;">int</span> B<span style="color:#441111;">[</span><span style="color:#AA00AA;">7</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">2</span>, <span style="color:#AA00AA;">5</span>, <span style="color:#AA00AA;">4</span>, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">4</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>       <span style="color:#888888;">//  v    |    v
</span>                                          <span style="color:#888888;">//  3 → 4 ← 5
</span>  <span style="color:#0000FF;">int</span> i<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">graph</span> g<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> dist<span style="color:#441111;">[</span><span style="color:#AA00AA;">6</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>

  g.setEdge<span style="color:#662222;">(</span>N, M, A, B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>                  <span style="color:#888888;">// node 0: degree 2: 1 3
</span>  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,N<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>                               <span style="color:#888888;">// node 1: degree 3: 0 2 4
</span>    wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;node {i}: degree {g.es[i]}: &quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// node 2: degree 2: 1 5
</span>    wt<span style="color:#662222;">(</span>g.edge<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">(</span>g.es<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>               <span style="color:#888888;">// node 3: degree 2: 0 4
</span>  <span style="color:#440000;font-weight:bold;">}</span>                                       <span style="color:#888888;">// node 4: degree 3: 3 1 5
</span>                                          <span style="color:#888888;">// node 5: degree 2: 2 4
</span>  g.getDist<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span>, dist<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>dist<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>            <span style="color:#888888;">// 1 2 3 0 1 2
</span>
  g.setDirectEdge<span style="color:#662222;">(</span>N, M, A, B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>            <span style="color:#888888;">// node 0: degree 2: 1 3
</span>  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,N<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>                               <span style="color:#888888;">// node 1: degree 1: 2
</span>    wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;node {i}: degree {g.es[i]}: &quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// node 2: degree 1: 5
</span>    wt<span style="color:#662222;">(</span>g.edge<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">(</span>g.es<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>               <span style="color:#888888;">// node 3: degree 1: 4
</span>  <span style="color:#440000;font-weight:bold;">}</span>                                       <span style="color:#888888;">// node 4: degree 1: 1
</span>                                          <span style="color:#888888;">// node 5: degree 1: 4
</span>  g.getDist<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span>, dist<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>dist<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>            <span style="color:#888888;">// -1 2 3 0 1 4
</span><span style="color:#440000;font-weight:bold;">}</span>
</span></pre>


<h2>枝に重みのあるグラフ（構造体）</h2>
<p>wgraph構造体を使えます．wgraph&lt;T&gt; g; などで定義します．<br></p>
<ul><li>int g.N : ノード数</li>
<li>int *g.es : g.es[i] はノード i から出ている枝の本数</li>
<li>int **g.edge : g.edge[i][j] はノード i から出ている j 番目の枝が向かう先のノード番号</li>
<li>T **g.cost : g.cost[i][j] はノード i から出ている j 番目の枝の重み</li>
<li>graph g : 枝の重みを無視したグラフ</li>
<li>void g.setEdge(int N, int M, int A[], int B[], T C[], void **mem=&wmem) : ノード数 N，枝数 M の無向グラフをセット（g.N, g.es, g.edgeを書き換え）します．(A[i], B[i])間に枝があります．ワーキングメモリを使用し，wmemは使用した分勝手に進みます．</li>
<li>void g.setDirectEdge(int N, int M, int A[], int B[], T C[], void **mem=&wmem) : ノード数 N，枝数 M の有向グラフをセットします．A[i]からB[i]に向かう枝があります．ワーキングメモリを使用し，wmemは使用した分勝手に進みます．</li>
<li>void g.setEdgeRootedTree(int N, int M, int A[], int B[], T C[], int root=0, int reorder=0, int cnv[] = NULL, void **mem = &wmem) : ノード数 N，枝数 M の根付き木をセットします．A[i], B[i] の順番は問わず，親から子に向かう枝のみを設定します．reorder=1の場合は，節点の番号を根に近いから振り直します（番号が大きくなる方向にのみ枝があるようになります）．cnv[i] = k は番号を付け替えた後のノード i はもともとのデータではノード k だったことを意味します．ワーキングメモリを使用し，wmemは使用した分勝手に進みます．</li>
<li>template&lt;class S&gt; void g.getDist(int root, S res[], S unreachable = -1, void *mem=wmen) : ノードrootから各ノードまでの距離をダイクストラ法で求めます．辿り着けないノードまでの距離は unreachable を返します．各枝の距離は非負と仮定します．ワーキングメモリを使います．時間計算量は $O(N + M \log N)$ 程度です．</li>
<li>template&lt;class S&gt; S g.getDistT(int a, int b, S unreachable = -1, void *mem=wmen) : ノードaからノードbまでの距離をダイクストラ法で求めます．辿り着けないノードまでの距離は unreachable を返します．各枝の距離は非負と仮定します．ワーキングメモリを使います．時間計算量は $O(N + M \log N)$ 程度です．参考：<a href="http://rsujskf.s602.xrea.com/?yukicoder_1283">yukicoder No.1283 - Extra Fee</a></li>
<li>template&lt;class S&gt; void g.getDistDense(int root, S res[], S unreachable = -1, void *mem=wmen) : ノードrootから各ノードまでの距離をヒープを使わないナイーブなダイクストラ法で求めます．辿り着けないノードまでの距離は unreachable を返します．各枝の距離は非負と仮定します．ワーキングメモリを使います．時間計算量は $O(N^2 + M)$ 程度です．</li>
<li>template&lt;class S&gt; void g.getDistForest(int root, S res[], S unreachable = -1, void *mem=wmen) : 森の場合，ノードrootから各ノードまでの距離をBFSで求めます．辿り着けないノードまでの距離は unreachable を返します．ワーキングメモリを使います．</li>
<li>template&lt;class S&gt; void g.BellmanFord(int root, S res[], S unreachable = -1, S minusInf = -2, int step = -1, void *mem = wmem) : ノードrootから各ノードまでの距離をBellman-Ford法で求めます．辿り着けないノードまでの距離は unreachable を，負閉路のためいくらでも距離が短くなる場合は minusInf を返します．stepが-1でなければ，rootからstep回以下移動する場合の最短距離を返します（minusInfにはならない）．ワーキングメモリを使います．</li>
<li>template&lt;class S&gt; void g.getDist01(int root, S res[], void *mem=wmen) : 枝の重みは0または1のみと仮定し，ノードrootから各ノードまでの距離を01BFSで求めます．辿り着けないノードまでの距離は -1 を返します．</li>
<li>int g.getDist01(int a, int b, void *mem=wmen) : 枝の重みは0または1のみと仮定し，ノードaからノードbまでの距離を返します．</li>
<li>T g.MST_Prim_cost(void *mem = wmem) : 無向グラフだと仮定して，最小全域木の重み和を返す．Prim法を使う．</li>
<li>int g.MST_Prim_cost(T &res, void *mem = wmem) : 無向グラフだと仮定して，最小全域木の重み和をresに代入して求める．戻り値は全域木が存在するなら1，存在しないなら0を返す．Prim法を使う．</li>
</ul>
<p>無向木に対する全方位DP（Rerooting）<br></p>
<ul><li>template&lt;class V&gt; void Rerooting(V res[], void *mem = wmem)</li>
</ul>
<p>枝は向きがあると思います（向きによって重みが違っても良いですが，無向木に対して枝を両方の向きに分裂させた形のグラフのみが対象です）．<br>ノードkに対する値(型はV)をn(k)，枝kに対する値(型はV)をe(k)と書くことにします．<br>枝kに対する値は，枝kの重み(g.cost)がECost，枝kはEFromからEToに向かう枝として，e(k) = wRerootingEdge(n(Eto), ECost, EFrom, ETo) で定義されます．<br></p>
<p>ノードkに対する値は，ノードkから他のノードに向かう枝をe1, e2, ..., em としたとき，<br>tmp = f(e1, e2, ..., em)<br>として<br>n(k) = wRerootingNode(tmp, k)<br>で定義します．<br>ただし，f は f(a, b, c) = f(a, f(b, c)) = f(f(a, b), c) などを満たし，更に（現状は）可換と仮定します．<br>fを表す関数を wRerootingMerge で指定します．<br>また，f(e, a) = a なる単位元 e を設定する関数 wRerootingId も用意しておきます．<br></p>
<p>最終的には，全ノードに対する n(k) の値を res[k] に代入して返します．<br></p>
<p>例えば，グローバルに<br>struct rval{ int sz; ll dist; };<br>void wRerootingId(rval &a){ a = {0, 0}; }<br>rval wRerootingMerge(rval a, rval b){ return {a.sz + b.sz, a.dist + b.dist}; }<br>rval wRerootingEdge(rval a, T ECost, int EFrom, int ETo){ return {a.sz, a.dist + a.sz * ECost}; }<br>rval wRerootingNode(rval a, int Nind){ return {a.sz+1, a.dist}; }<br>を用意しておくと（Tはintを想定，wgraph&lt;T&gt;の場合），<br>szにそのノードを根とする部分木のノード数＝全体のノード数<br>distにそのノードから他のノードまでの距離の総和（costが距離を表します）<br>を求めることになります．<br></p>



<h2>Heavy-Light Decomposition（HLD，重軽分解）</h2>
<p>根付き無向木に対してHeavy-Light Decomposition（HLD）を計算します．<br>根はノード0を利用します．<br>計算したHLDを用いて，LCAなどを高速に求めることができます．<br>また，segtreeを載せることができます．<br>HLD hld; で定義したとします．<br></p>
<ul><li>void hld.init(graph g, void **mem = &wmem) : グラフ g をセットします．以降で graph g を破壊しないでください．</li>
<li>int hld.lca(int x, int y) : ノードxとノードyのLCAを求める．$O(\log N)$ 時間．</li>
<li>int hld.depth(int x) : ノードxの深さ（ノード0からの距離）を求める．$O(\log N)$ 時間．</li>
<li>int hld.dist(int x, int y) : ノードxとノードyの間の距離を求める．$O(\log N)$ 時間．</li>
<li>int hld.up(int x, int d = 1) : ノードxのd世代親のノード番号を求める．存在しないなら-1．$O(\log N)$ 時間．</li>
</ul>
<p>以下 HLD hld; の多分使わない情報．<br></p>
<ul><li>int hld.N : ノード数．graphと同じ．</li>
<li>int *hld.es : 次数．graphと同じ．</li>
<li>int **hld.edge : 枝．graphと同じ．</li>
<li>int groupNum : グループ（Lightの枝で結ばれるパス）の数</li>
<li>int *groupSize : i番目のグループに属するノード数が groupSize[i]</li>
<li>int **groupNode : i番目のグループに属するj番目のノード番号が groupNode[i][j]</li>
<li>int *groupUpNode : i番目のグループから根に向かってHeavyの枝を伝って登った先のノード番号が groupUpNode[i]（一番上のグループなら-1）</li>
<li>int *groupDepth : グループを1つのノードと見たときに，i番目のグループの根からの距離 groupDepth[i]</li>
<li>int *group : ノードiが属するグループ番号が group[i]</li>
<li>int *groupind : ノードiはグループ group[i] の groupind[i] 番目のノード</li>
</ul>
<p>Fenwick treeを載せるときは，HLD_fenwick&lt;T&gt; t; を定義します．<br>ノードに値を持ちます．<br>（枝に値をもたせたい場合は，すぐ上に向かう枝の値をノードに持たせて，LCAでパスを分割したりするとできるかも）<br></p>
<ul><li>void t.init(HLD *hld__, void **mem = &wmem) : 初期設定．全節点は0で初期化されます．</li>
<li>void t.add(int u, T val) : ノードuの値にvalを足します</li>
<li>T t.get(int u, int v) : ノードuからノードvに向かうバス上の全てのノード（uもvも含む）の値の和を求めます</li>
</ul>
<p>以下 HLD_fenwick&lt;T&gt; t; の多分使わない情報．<br></p>
<ul><li>HLD *t.hld : そうです．</li>
<li>fenwick&lt;T&gt; *fen : fen[i]はグループiのfenwickです．</li>
</ul>
<p>segtreeを載せるときは，HLD_segtree&lt;T&gt; t; を定義します．<br>ノードに値を持ちます．<br></p>
<ul><li>void t.init(HLD *hld__, T initval[], void **mem = &wmem) : 初期設定．initval[i] はノード i の初期値です．0で初期化するなら initval は NULL でも良い．</li>
<li>void t.change(int u, int v, T val) : ノードuからノードvに向かうバス上の全てのノード（uもvも含む）の値をvalに置き換えます</li>
<li>void t.add(int u, int v, T val) : ノードuからノードvに向かうバス上の全てのノード（uもvも含む）の値にvalを足します</li>
<li>T t.getSum(int u, int v) : ノードuからノードvに向かうバス上の全てのノード（uもvも含む）の値の和を求めます</li>
<li>pair&lt;T,int&gt; t.getMin(int u, int v) : ノードuからノードvに向かうバス上の全てのノード（uもvも含む）の値の（最小値，その最小値を達成するノード番号の1つ）を求めます</li>
<li>T t.getMinVal(int u, int v) : ノードuからノードvに向かうバス上の全てのノード（uもvも含む）の値の最小値を求めます</li>
<li>int t.getMinInd(int u, int v) : ノードuからノードvに向かうバス上の全てのノード（uもvも含む）の値の最小値を達成するノード番号の1つを求めます</li>
</ul>
<p>枝に重みが載っていると思った場合の関数は以下の通り（実際は枝(x,y)の重みはx,yの内，深い方のノードに持たせていて，内部でLCAやら色々呼び出して辻褄合わせたりするので多分遅め）．参考：<a href="http://rsujskf.s602.xrea.com//?atcoder_past202010-open_m">第四回 アルゴリズム実技検定 M問題 - 筆塗り</a>．<br></p>
<ul><li>void t.change_edge(int u, int v, T val)</li>
<li>void t.add_edge(int u, int v, T val)</li>
<li>T t.getSum_edge(int u, int v)</li>
<li>pair&lt;T,int&gt; t.getMin_edge(int u, int v)</li>
<li>T t.getMinVal_edge(int u, int v)</li>
<li>int t.getMinInd_edge(int u, int v)</li>
</ul>
<p>以下 HLD_segtree&lt;T&gt; t; の多分使わない情報．<br></p>
<ul><li>HLD *t.hld : そうです．</li>
<li>segtree&lt;T&gt; *seg : seg[i]はグループiのsegtreeです．</li>
</ul>



<h2>最大流（maxflow, Dinic）</h2>
<p>最大流は maxflow&lt;int,ll&gt; flow; などで定義します．この場合，各辺の流量は int 型ですが，合計で流れる流量は ll 型です．<br>以下の説明では maxflow&lt;T,S&gt; flow; とします．<br></p>
<ul><li>int flow.node : ノード数</li>
<li>T flow.eps : これ以下だと 0 だと思う閾値（S = double のときなどに使われる，デフォルトだと 1e-9．init() 関数，setGraph() 関数などでセットされる）</li>
<li>int *flow.es : flow.es[i] でノード i から出ている枝の本数</li>
<li>int **flow.edge : flow.edge[i][j] はノード i から出ている j 番目の枝が向かう先のノード番号</li>
<li>int **flow.rev : ノード i から出ている j 番目の枝の逆向きの枝がノード j から出ている flow.edge[i][j] 番目の枝</li>
<li>T **flow.flow : ノード i から出ている j 番目の枝にそって後どれぐらい流せるか</li>
<li>flow.malloc(int N) : ノード数 N のグラフを確保できるメモリを確保（枝の分のメモリは確保しない）</li>
<li>flow.malloc(int N, int init_flag) : malloc(N) をした後，init_flag が 0 でなければ init(N) を呼び出します．</li>
<li>flow.walloc(int N, void**mem = &wmem) : ノード数 N のグラフを確保できるメモリを確保（枝の分のメモリは確保しない）</li>
<li>flow.walloc(int N, int init_flag, void**mem = &wmem)</li>
<li>flow.init(int N) : グラフを初期化，ノード数を N に設定</li>
<li>flow.addEdge(int n1, int n2, T f1, T f2 = 0) : ノード n1 から n2 に向かって流量 f1，ノード n2 から n1 に向かって流量 f2 の枝を張る</li>
<li>flow.setGraph(int N, int M, int n1[], int n2[], T f1[], T f2[]) : ノード数 N，枝数 M のグラフを設定</li>
<li>void setGraph_w(int N, int M, int n1[], int n2[], T f1[], T f2[], void **mem = wmem) : ノード数 N，枝数 M のグラフを設定</li>
<li>S solve(int st, int ed) : ノード st からノード ed までflowを流して，流れた量を返す</li>
</ul>
<p>以下のコードは <a href="http://www.spoj.com/problems/FASTFLOW/">http://www.spoj.com/problems/FASTFLOW/</a> を解くコード．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">30000</span><span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">30000</span><span style="color:#441111;">]</span>, C<span style="color:#441111;">[</span><span style="color:#AA00AA;">30000</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> N, M<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">ll</span> res<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">maxflow</span>&lt;<span style="color:#0000FF;">int</span>,<span style="color:#0000FF;">ll</span>&gt; f<span style="color:#000000;">;</span>

  rd<span style="color:#662222;">(</span>N,M<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  rd<span style="color:#662222;">(</span><span style="color:#662222;">(</span>A,B,C<span style="color:#662222;">)</span><span style="color:#662222;">(</span>M<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  A<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.M-<span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span>--<span style="color:#000000;">;</span>
  B<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.M-<span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span>--<span style="color:#000000;">;</span>

  f.<span style="color:#000000;font-weight:bold;">malloc</span><span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  f.init<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  f.addEdge<span style="color:#662222;">(</span>A<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.M-<span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span>,B<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#441111;">]</span>,C<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#441111;">]</span>,C<span style="color:#441111;">[</span><span style="color:#AA00AA;">0.</span>.<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  res = f.solve<span style="color:#662222;">(</span><span style="color:#AA00AA;">0</span>, N-<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#440000;font-weight:bold;">}</span>
</span></pre>


<h2>最小費用流（minCostFlow）</h2>
<p>最大流は minCostFlow&lt;int,double&gt; flow; などで定義します．この場合，流量は int 型で，コストは double 型です．<br>以下の説明では minCostFlow&lt;FT,CT&gt; flow; とします．<br>徐々に流していくアルゴリズムを適当に実装したもので，少なくても現状は良い実装ではないと思います．<br>負の閉路などがあると動きません．<br></p>
<ul><li>int flow.node : ノード数</li>
<li>FT flow.eps : これ以下だと 0 だと思う閾値（FT = double のときなどに使われる，デフォルトだと 1e-9．init() 関数などでセットされる）</li>
<li>int *flow.es : flow.es[i] でノード i から出ている枝の本数</li>
<li>int **flow.edge : flow.edge[i][j] はノード i から出ている j 番目の枝が向かう先のノード番号</li>
<li>int **flow.rev : ノード i から出ている j 番目の枝の逆向きの枝がノード j から出ている flow.edge[i][j] 番目の枝</li>
<li>FT **flow.flow : ノード i から出ている j 番目の枝にそって後どれぐらい流せるか</li>
<li>flow.malloc(int N) : ノード数 N のグラフを確保できるメモリを確保（枝の分のメモリは確保しない）</li>
<li>flow.init(int N) : グラフを初期化，ノード数を N に設定</li>
<li>flow.addEdge(int n1, int n2, FT f, CT c) : ノード n1 から n2 に向かって流量 f，コスト c の枝を張る</li>
<li>template&lt;class FTS, class CTS&gt; void solve(int st, int ed, FTS &fres, CTS &cres, FT flim = -1, CT clim = 0) : ノード st からノード ed までflowを流して，流れた量をfresに，コストをcresに代入する．ただし，最大で流量flimまでしか流さない．flim=-1なら流せるだけ流す，flim=-2ならコストがclim未満の間だけ流す．</li>
</ul>
<p>参考：<a href="http://rsujskf.s602.xrea.com/?yukicoder_1288">yukicoder No.1288 - yuki collection</a><br></p>



<h2>Trie</h2>
<p>Trie t; で定義したとします．<br>最終的なノード数の上限を n（例えば食わせる文字列の文字数の和+1），アルファベットのサイズ（文字の種類数）を k として，t.malloc(n, k); などでメモリの確保 + 初期化します．<br>n=10^6, k=26 で100メガバイト以上メモリが必要なので注意してください（nk*sizeof(int)は最低限必要で，それ以外も細々と必要かも）．<br>ルート（空文字）に対応するノード番号は 0 です．<br></p>
<ul><li>int t.node : 現在のグラフのノード数</li>
<li>void t.malloc(const int n, const int k) : ノード数の上限を n，アルファベットサイズの上限を k としてメモリ確保．</li>
<li>void t.walloc(const int n, const int k, void **mem = &wmem) : mallocのワーキングメモリ版</li>
<li>void t.free(void) : mallocで確保したメモリの解放</li>
<li>void t.init(void) : 初期化（空文字を表すノード1個のみに戻す，アルファベットのサイズはメモリ確保時の上限に設定）</li>
<li>void t.init(const int k) : 初期化（空文字を表すノード1個のみに戻す，アルファベットのサイズをkに設定）</li>
<li>template&lt;class T&gt; int t.addWord(const T word[], const int len) : ルートから word[] に対応するパスを作り，到達地点の（wordに対応する）ノード番号を返す．</li>
<li>template&lt;class T&gt; inline int t.addNext(const int n, const T c) : ノード n から1文字 c を付け加えたノード番号を返す．存在しないなら，そのノードを作って，そのノード番号を返す．</li>
<li>template&lt;class T&gt; inline int t.next(const int n, const T c) : ノード n から1文字 c を付け加えたノード番号を返す．存在しないなら -1 を返す．</li>
</ul>


<h2>AhoCorasick</h2>
<p>AhoCorasick aho; で定義したとします．<br>最終的なノード数の上限を n（例えば食わせる文字列の文字数の和+1），アルファベットのサイズ（文字の種類数）を k として，aho.malloc(n, k); でメモリの確保＋初期化します．<br>アルファベットは0からk-1までの数値です．<br>文字列を addWord でいくつか加えてTrieぽいグラフを作る．<br>そして，construct で failedリンクを作って準備完了です．<br></p>
<ul><li>int aho.node : グラフのノード数</li>
<li>void aho.init(void) : 初期化（空文字を表すノード1個のみに戻す）</li>
<li>template&lt;class T&gt; int aho.addWord(const T word[], const int len, const int id) : Wordを追加する．Trieにおける終点のノード番号を返す</li>
<li>void aho.construct(void *mem = wmem)</li>
<li>template&lt;class T&gt; inline void next(const int n, const T c) : ノードnにいるときに次にcの文字で遷移した先のノードを返す．constructを呼び出した後に使える．</li>
<li>int aho.indsz[n] : ノードnが終端となるような文字列の数</li>
<li>int aho.ind[n][k] : ノードnが終端となるようなk個目の文字列のid（idはaddWordで食わせたもの）</li>
</ul>
<p>全ての文字列を区別する必要がなければ以下のもので十分かもしれません．<br></p>
<p>AhoCorasick_Sum&lt;S&gt; aho; で定義したとします．<br>最終的なノード数の上限を n（例えば食わせる文字列の文字数の和+1），アルファベットのサイズ（文字の種類数）を k として，aho.malloc(n, k); でメモリの確保＋初期化します．<br>アルファベットは0からk-1までの数値です．<br>文字列を addWord でいくつか加えてTrieぽいグラフを作る．<br>そして，construct で failedリンクを作って準備完了です．<br></p>
<ul><li>int aho.node : グラフのノード数</li>
<li>void aho.init(void) : 初期化（空文字を表すノード1個のみに戻す）</li>
<li>template&lt;class T&gt; int aho.addWord(const T word[], const int len, const S val)</li>
<li>void aho.construct(void *mem = wmem)</li>
<li>template&lt;class T&gt; inline void next(const int n, const T c) : ノードnにいるときに次にcの文字で遷移した先のノードを返す．constructを呼び出した後に使える．</li>
<li>S aho.sum[n] : ノードnが終端となるような文字列のvalの和</li>
</ul>
<p>AhoCorasickの使い方の参考：<br><a href="http://rsujskf.s602.xrea.com/?atcoder_beginner_contest_122_d">AtCoder Beginner Contest #122 D問題 - We Like AGC</a><br></p>



<h2>Polynomial（1変数多項式）</h2>
<p>あまりちゃんと作っていません．<br>Polynomial&lt;T&gt P; で作ります．定義域，値域ともにTです．<br>疎構造ではないので，次数の高い多項式は問答無用でたくさんの項を扱うことになって遅いです．<br>今のところ愚直な実装です．<br></p>
<p>コンストラクタ<br></p>
<ul><li>Polynomial() : 恒等的に0の多項式</li>
<li>Polynomial(T a) : 恒等的にaの多項式（定数関数）</li>
<li>Polynomial(const Polynomial&lt;T&gt; &a)</li>
</ul>
<p>デストラクタ<br></p>
<ul><li>~Polynomial()</li>
</ul>
<p>その他関数 [メンバ関数]<br></p>
<ul><li>inline void P.change(const int dg, const T cf) : 次数dgの係数をcfに変更する</li>
<li>inline int P.deg(void) : 次数を返す．定数関数（常に0も含む）の次数は0</li>
<li>inline T P.coef(const int k) : $x^k$ の係数を返す．k が次数より大きければちゃんと 0 を返す．</li>
</ul>
<p>オペレーター [メンバ関数]<br></p>
<ul><li>Polynomial&lt;T&gt;& operator=(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt;& operator=(const T a)</li>
<li>Polynomial&lt;T&gt;& operator+=(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt; operator+(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt;& operator-=(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt; operator-(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt;& operator*=(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt; operator*(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt;& operator/=(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt; operator/(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt;& operator%=(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt; operator%(const Polynomial&lt;T&gt; &a)</li>
<li>Polynomial&lt;T&gt;& operator*=(const T &a)</li>
<li>Polynomial&lt;T&gt; operator*(const T &a)</li>
<li>Polynomial&lt;T&gt;& operator/=(const T &a)</li>
<li>Polynomial&lt;T&gt; operator/(const T &a)</li>
<li>inline T operator()(const T x)</li>
</ul>
<p>オペレーター [メンバ関数以外]<br></p>
<ul><li>template&lt;class T&gt; Polynomial&lt;T&gt; operator*(const T a, const Polynomial&lt;T&gt; &b)</li>
</ul>
<p>使わなさそうなの<br></p>
<ul><li>int d : 次数を格納する変数</li>
<li>T *c : 係数を格納する配列（c[i]はx^iの係数）</li>
<li>int mem : 係数を保存する配列 c でメモリを格納しているサイズ</li>
<li>void expand(int z) : 係数を保存する配列 c のサイズを z 個以上格納できるように拡張する</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">double</span> x<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">Polynomial</span>&lt;<span style="color:#0000FF;">double</span>&gt; P, Q, R1, R2<span style="color:#000000;">;</span> <span style="color:#888888;">// P = Q = 0
</span>
  P.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span>, <span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// P = x^2
</span>  P.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// P = x^2 + 2*x
</span>  P.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">0</span>, <span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// P = x^2 + 2*x + 1
</span>
  x = P<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// P(2) = 2^2 + 2*2 + 1 = 9
</span>
  Q.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// Q = x
</span>  Q.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">0</span>, <span style="color:#AA00AA;">4</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// Q = x + 4
</span>
  <span style="color:#888888;">// x^2 + 2*x + 1 = (x-2) (x+4) + 9
</span>  R1 = P / Q<span style="color:#000000;">;</span>  <span style="color:#888888;">// x - 2
</span>  R2 = P % Q<span style="color:#000000;">;</span>  <span style="color:#888888;">// 9
</span>
  Q *= <span style="color:#AA00AA;">2.0</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 2x + 8
</span>
  <span style="color:#888888;">// x^2 + 2x + 1 = (0.5x - 1) (2x + 8) + 9
</span>  R1 = P / Q<span style="color:#000000;">;</span> <span style="color:#888888;">// 0.5x - 1
</span>  R2 = P % Q<span style="color:#000000;">;</span> <span style="color:#888888;">// 9
</span>
  Q.change<span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">0</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// Q = 8
</span>  R1 = P / Q<span style="color:#000000;">;</span> <span style="color:#888888;">// (1/8) x^2 + (1/4) x + (1/8);
</span>  R2 = P % Q<span style="color:#000000;">;</span> <span style="color:#888888;">// 0
</span></span></pre>


<h2>その他色々な関数など</h2>

<ul><li>void walloc1d(T **arr, int x, void **mem = &wmem): 配列arrに要素数xだけワーキングメモリから割り当てる（ワーキングメモリは割当てた分は勝手に進む）</li>
<li>void walloc1d(T **arr, int x1, int x2, void **mem = &wmem): arr[x1], arr[x1+1], ..., arr[x2-1] が使用できるように割り当てる</li>
<li>void walloc2d(T ***arr, int x, int y, void **mem = &wmem): 二次元配列arrに要素数x*yだけワーキングメモリから割り当てる（ワーキングメモリは割当てた分は勝手に進む）</li>
<li>void walloc2d(T ***arr, int x1, int x2, int y1, int y2, void **mem = &wmem): arr[x1][y1]～arr[x2-1][y2-1] が使えるように割り当てる</li>
<li>void malloc1d(T **arr, int x): 配列arrに要素数xだけmallocを使ってメモリを割り当てる</li>
<li>void malloc2d(T ***arr, int x, int y): 二次元配列arrに要素数x*yだけmallocを使ってメモリを割り当てる</li>
<li>void free1d(T *arr): malloc1d() で確保したメモリを開放</li>
<li>void free2d(T **arr): malloc2d() で確保したメモリを開放</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i, j<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> *a, **m, **hoge<span style="color:#000000;">;</span>

  walloc1d<span style="color:#662222;">(</span>&amp;a, <span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  walloc2d<span style="color:#662222;">(</span>&amp;m, <span style="color:#AA00AA;">50</span>, <span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span> a<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = i<span style="color:#000000;">;</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">50</span><span style="color:#662222;">)</span> <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>j,<span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span> m<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span> = i+j<span style="color:#000000;">;</span>
                                 <span style="color:#888888;">// ↓出力 *例* (sizeof(*a)=4の環境)
</span>  <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%p %d\n&quot;</span>,a,a<span style="color:#662222;">)</span><span style="color:#000000;">;</span>         <span style="color:#888888;">// 0x404040 4210752
</span>  <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%p %d\n&quot;</span>,m,m<span style="color:#662222;">)</span><span style="color:#000000;">;</span>         <span style="color:#888888;">// 0x4041d0 4211152
</span>  <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%p %d\n&quot;</span>,m<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span>,m<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 0x404298 4211352
</span>  <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%p %d\n&quot;</span>,m<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span>,m<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 0x404428 4211752
</span>
  malloc2d<span style="color:#662222;">(</span>&amp;hoge, <span style="color:#AA00AA;">50</span>, <span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  free2d<span style="color:#662222;">(</span>hoge<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> *a<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">void</span> *mem<span style="color:#000000;">;</span>

  mem = wmem<span style="color:#000000;">;</span>        <span style="color:#888888;">// ワーキングメモリの先頭アドレスを覚えておく
</span>  walloc1d<span style="color:#662222;">(</span>&amp;a, <span style="color:#AA00AA;">1d6</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 10^6要素の配列を確保
</span>  <span style="color:#888888;">/* 何かする */</span>
  wmem = mem<span style="color:#000000;">;</span>        <span style="color:#888888;">// ワーキングメモリの先頭アドレスを戻すことによって，配列aを解放
</span></span></pre>
<HR>

<p>Rand構造体．乱数生成に使う．xorshift．<br>Rand rnd; で宣言したとして以下の通り．<br>何回か実行したとき，うまく種を設定しないと最初の数十回ぐらいは似た系列が出てくるので，気になる場合は，最初にgetを100回呼び出すなど空打ちすると良い．<br>一部仕様は未決定．<br>種を設定しない場合は，time(NULL)を使って設定．<br></p>
<ul><li>int rnd.get(int a): 0以上a未満の整数を一様にランダムに返す</li>
<li>int rnd.get(int a, int b): a以上b以下の整数を一様にランダムに返す</li>
<li>ll rnd.get(ll a): 0以上a未満の整数を一様にランダムに返す</li>
<li>ll rnd.get(ll a, ll b): a以上b以下の整数を一様にランダムに返す</li>
<li>double rnd.get(double a, double b): a以上b未満の実数を一様にランダムに返す</li>
</ul>
<p>以下は微妙に仕様を決めきれてない．<br></p>
<ul><li>ll rnd.get(void): 0以上2^32未満の整数を一様にランダムに返す</li>
<li>double rnd.getUni(void): 0以上1未満の実数を一様にランダムに返す</li>
<li>ll rnd.getExp(int a): 0以上a未満の整数をランダムに返す．ただし，小さい値がでやすい．exp(k)の形に書いたとき，kの値が一様に分布な感じ．</li>
<li>ll rnd.getExp(int a, int b): a以上b以下の整数をランダムに返す．ただし，小さい値がでやすい．exp(k)+aの形に書いたとき，kの値が一様に分布な感じ．</li>
</ul>
<p>以下はそのうち実装予定でまだ作ってない<br></p>
<ul><li>void rnd.set(unsigned w): 種をセット</li>
<li>void rnd.set(unsigned x, unsigned y, unsigned z, unsigned w): 種をセット</li>
</ul>

<HR>


<p>Timer 構造体．<br>時間を測るために使う．<span id="code"><span style="color:#444444"><span style="color:#0000FF;">Timer</span> timer<span style="color:#000000;">;</span></span></span> で宣言したとして以下の通り．<span id="code"><span style="color:#444444"><span style="color:#000000;font-weight:bold;">gettimeofday</span></span></span>を使用する．<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> timer.<span style="color:#0000FF;">set</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span>: 初期化．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">double</span> timer.get<span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span>: 最後にset()を呼び出してからの経過秒数を返す．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">ll</span> sum = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">Timer</span> timer<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">double</span> tm<span style="color:#000000;">;</span>
  timer.<span style="color:#0000FF;">set</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">1d8</span><span style="color:#662222;">)</span> sum += <span style="color:#AA00AA;">1d9</span> /+ i<span style="color:#000000;">;</span>
  tm = timer.get<span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;time: {tm}, sum: {sum}\n&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// time: 0.678610086441040, sum: 19048729277
</span></span></pre>
<p>Timer2 構造体．<br><span id="code"><span style="color:#444444">Timer2 timer<span style="color:#000000;">;</span></span></span> などで宣言して上記と同じように使用可能（Timer 構造体と使い方は全く一緒）．<br><span id="code"><span style="color:#444444"><span style="color:#000000;font-weight:bold;">std</span>::chrono::high_resolution_clock::now<span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> を使用する．<br></p>

<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">string</span> toLower<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> S<span style="color:#662222;">)</span></span></span> : 各文字に tolower() をかましたものを返す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">string</span> toUpper<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> S<span style="color:#662222;">)</span></span></span> : 各文字に toupper() をかましたものを返す．</li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">string</span> S = <span style="color:#00AA22;">&quot;HoGe@Piyo&quot;</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>toLower<span style="color:#662222;">(</span>S<span style="color:#662222;">)</span>.<span style="color:#000000;font-weight:bold;">c_str</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// hoge@piyo
</span>wt<span style="color:#662222;">(</span>toUpper<span style="color:#662222;">(</span>S<span style="color:#662222;">)</span>.<span style="color:#000000;font-weight:bold;">c_str</span><span style="color:#662222;">(</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// HOGE@PIYO
</span></span></pre>
<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> isSorted<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span></span></span> : 長さ N の配列 A[] はソート済みであれば 1，そうでなければ 0 を返す．ソート済みというのは <span id="code"><span style="color:#444444">A<span style="color:#441111;">[</span>i-<span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> &lt;= A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span></span></span> が任意の i = 1, 2, ..., N-1 について成り立つこと．</li>
</ul>

<HR>

<ul><li>template&lt;class T&gt; vector&lt;vector&lt;T&gt;&gt; Rot90(vector&lt;vector&lt;T&gt;&gt; a) : 時計回りに90度回転した盤面を返します</li>
</ul>

<HR>

<ul><li>template&lt;class T, class T1, class T2&gt; inline void swapV(T &amp;a, T1 x, T2 y) : a が x なら y に，y なら x に変更します．どちらでもないなら変更しません．</li>
</ul>

<HR>

<ul><li>template&lt;class S, class T&gt; int HammingDistance(int N, S A[], T B[]) : 配列 A, B のハミング距離を求めます．</li>
<li>template&lt;class T&gt; int editDistance(int As, T A[], int Bs, T B[], void *mem = wmem) : 配列 A, B の編集距離を求めます．時間計算量 O(As*Bs) ぐらいのDP．</li>
<li>template&lt;class T&gt; ll counterSumIsLT(int As, T A[], int Bs, T B[], T val) : 配列 A, B はソートされているとします．A[i] + B[j] が val 未満になる (i,j) の数を返します．時間計算量 O(As+Bs) ぐらいの尺取法．</li>
<li>template&lt;class T&gt; ll counterProdIsLT(int As, T A[], int Bs, T B[], T val) : 配列 A, B はソートされているとします．A[i] * B[j] が val 未満になる (i,j) の数を返します．時間計算量 O(As+Bs) ぐらいの尺取法．</li>
<li>template&lt;class T&gt; ll counterD2SumIsLT(int As, T A[], T val) : 配列 A はソートされているとします．i &lt; j であって，A[i] + A[j] が val 未満になる (i,j) の数を返します．時間計算量 O(As) ぐらいの尺取法．</li>
<li>template&lt;class T&gt; ll counterM2SumIsLT(int As, T A[], T val) : 配列 A はソートされているとします．i &le; j であって，A[i] + A[j] が val 未満になる (i,j) の数を返します．時間計算量 O(As) ぐらいの尺取法．</li>
<li>template&lt;class T&gt; ll counterD2ProdIsLT(int As, T A[], T val) : 配列 A はソートされているとします．i &lt; j であって，A[i] * A[j] が val 未満になる (i,j) の数を返します．時間計算量 O(As) ぐらいの尺取法．</li>
<li>template&lt;class T&gt; ll counterM2ProdIsLT(int As, T A[], T val) : 配列 A はソートされているとします．i &le; j であって，A[i] * A[j] が val 未満になる (i,j) の数を返します．時間計算量 O(As) ぐらいの尺取法．</li>
</ul>

<HR>

<ul><li>template&lt;class T, class S&gt; ll cntSubarrayFreq(int N, T A[], S lim[], void *mem = wmem) : 尺取法により条件を満たす空で無い連続部分列の数を返します．条件：部分列に含まれている値vの個数がlim[v]個以下．lim[A[i]]にはアクセスできる必要があり，それ以外のlimの要素は使用されません．</li>
<li>template&lt;class T, class S, class S2&gt; ll cntSubarrayDistinct(int N, T A[], S cost[], S2 lim, void *mem = wmem) : 尺取法により条件を満たす空で無い連続部分列の数を返します．条件：部分列に1個以上含まれている値vに対してcost[v]の和がlim以下．特にcostが常に1なら登場する種類数がlim以下．cost[A[i]]にはアクセスできる必要があり，それ以外のcostの要素は使用されません．</li>
<li>template&lt;class T, class S, class S2&gt; int maxSubarrayDistinct(int N, T A[], S cost[], S2 lim, void *mem = wmem) : cntSubarrayDistinctと同じ状況において，最も長い連続部分列の長さを返します．該当する部分列がなければ0を返します．</li>
</ul>

<HR>

<p>x if[c1,s1,c2,s2,e] y; は if(c1){ x s1 y; } else if(c2){ x s2 y; } else { x e y; } に展開される．(c1,s1)のペアはいくつ合っても良い．eは空なら省略可能．<br>ただし，現状if文などの()の中では使用不可能．<br>例えば<br></p>

<pre><span style="color:#444444">  a<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = x <span style="color:#0088FF;">if</span><span style="color:#441111;">[</span>i%<span style="color:#AA00AA;">2</span>==<span style="color:#AA00AA;">0</span>,+,-<span style="color:#441111;">]</span> y<span style="color:#000000;">;</span>
  s<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = b<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> <span style="color:#0088FF;">if</span><span style="color:#441111;">[</span>i,+s<span style="color:#441111;">[</span>i-<span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
</span></pre>
<p>は以下のように展開されます：<br></p>

<pre><span style="color:#444444">  <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>i%<span style="color:#AA00AA;">2</span>==<span style="color:#AA00AA;">0</span><span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    a<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = x + y<span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span> <span style="color:#0088FF;">else</span> <span style="color:#440000;font-weight:bold;">{</span>
    a<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = x - y<span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span>
  <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#440000;font-weight:bold;">{</span>
    s<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = b<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> + s<span style="color:#441111;">[</span>i-<span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span> <span style="color:#0088FF;">else</span> <span style="color:#440000;font-weight:bold;">{</span>
    s<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = b<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<HR>

<p>式に対して最小値，最大値，和などを求める．<br>最小値の場合は，<br>min[型][範囲](式)<br>の形式で [型] は省略可能（int型をたくさん足してll型で結果を得たい場合などは [型] を指定する）．<br>範囲を表す変数は int 型ですが，他の型の場合は範囲の書き方を見てください．<br>範囲が空なら，sumは0，mulは1，gcdは0，lcmは1になります．minは型が表せる最大の値，maxは型が表せる最小の値になります．<br></p>
<ul><li>min[型][範囲](式): 最小値を求める</li>
<li>max[型][範囲](式): 最大値を求める</li>
<li>sum[型][範囲](式): 和を求める</li>
<li>mul[型][範囲](式): 積を求める</li>
<li>gcd[型][範囲](式): gcdを求める</li>
<li>lcm[型][範囲](式): lcmを求める</li>
<li>XOR[型][範囲](式): XOR（ビットごとの排他的論理和）を求める</li>
<li>OR[型][範囲](式): OR（ビットごとの和）を求める</li>
<li>AND[型][範囲](式): AND（ビットごとの積）を求める．ただし，範囲が空の場合，現状では0を返す（非直感的）．</li>
<li>argmin[型][範囲](式): 式を最小にするような変数のうち最初のものを求める（範囲は1変数のみ対応）．</li>
<li>argmax[型][範囲](式): 式を最大にするような変数のうち最後のものを求める（範囲は1変数のみ対応）．</li>
<li>argminL[型][範囲](式): 式を最小にするような変数のうち最初のものを求める（範囲は1変数のみ対応）．</li>
<li>argmaxL[型][範囲](式): 式を最大にするような変数のうち最後のものを求める（範囲は1変数のみ対応）．</li>
</ul>
<p>範囲の書き方は以下のとおりです．<br>各変数の動く範囲を,区切りで記述します（変数は定義されていなくても構いません，式の評価にのみ利用します）．<br>i=a---b : 変数 i を a から b まで（両端を含む）動かします．<br>i,a,b : 変数 i を a から b-1 まで（両端を含む）動かします．<br>(i,j)=a---b : 変数 i と j を a から b まで（両端含む）動かします．<br>(i,j),a,b : 変数 i と j を a から b-1 まで（両端含む）動かします．<br></p>
<p>変数の型を指定する場合は，変数名の前につけてください．<br>例えば (i,j),a,b において i は int 型だけど，j を ll 型にする場合は (i, ll j),a,b としてください．<br></p>
<p>型において「@ 条件」をつけると条件を満たすもののみ処理します．<br>また，「<code>$</code> 値」をつけると範囲が空だったり，条件を満たすものが存在しない場合に，値を代入するようになります．<br>（値を指定しない場合は，それぞれの演算，型を考えて，単位元的なものを代入します）<br>min[i,0,n @ a[i] &gt;= 10 <code>$</code> 0](a[i])<br>で配列a[i]の中の10以上の要素の中での最小値を求めます．該当する要素がないなら0にします．<br>min[i,0,n @ a[i] &gt;= 10](a[i])<br>の場合，a[i]がint型で該当する要素がないなら2147483647になります．<br></p>
<p>また，配列に対する argmin, argmax は以下の形式も使えます．<br></p>
<ul><li>argmin(arr(n)): argmin[var=0---n-1](arr[var]) 長さnの配列arrの最小値の添え字を返す．複数存在するなら最小の添え字を返す．</li>
<li>argmax(arr(n)): argmax[var=0---n-1](arr[var]) 長さnの配列arrの最大値の添え字を返す．複数存在するなら最大の添え字を返す．</li>
<li>argminL(arr(n)): argminL[var=0---n-1](arr[var]) 長さnの配列arrの最小値の添え字を返す．複数存在するなら最小の添え字を返す．</li>
<li>argmaxL(arr(n)): argmaxL[var=0---n-1](arr[var]) 長さnの配列arrの最大値の添え字を返す．複数存在するなら最大の添え字を返す．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">int</span> i<span style="color:#000000;">;</span>
    i = <span style="color:#000000;font-weight:bold;">min</span><span style="color:#441111;">[</span>k=<span style="color:#AA00AA;">1</span>--<span style="color:#AA00AA;">-100</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span><span style="color:#000000;font-weight:bold;">abs</span><span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span>*k-<span style="color:#AA00AA;">50</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>                               <span style="color:#888888;">// 2 と表示
</span>    i = argmin<span style="color:#441111;">[</span>k=<span style="color:#AA00AA;">1</span>--<span style="color:#AA00AA;">-100</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span><span style="color:#000000;font-weight:bold;">abs</span><span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span>*k-<span style="color:#AA00AA;">50</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>                               <span style="color:#888888;">// 12 と表示
</span>  <span style="color:#440000;font-weight:bold;">}</span>
  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span>
      <span style="color:#AA00AA;">300000000</span>, <span style="color:#AA00AA;">500000000</span>, <span style="color:#AA00AA;">700000000</span>,
      <span style="color:#AA00AA;">300000000</span>, <span style="color:#AA00AA;">200000000</span>, <span style="color:#AA00AA;">700000000</span>,
      <span style="color:#AA00AA;">300000000</span>, <span style="color:#AA00AA;">500000000</span>, <span style="color:#AA00AA;">900000000</span>
    <span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span><span style="color:#000000;font-weight:bold;">min</span><span style="color:#441111;">[</span>i,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span>,j,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span><span style="color:#662222;">)</span> + <span style="color:#000000;font-weight:bold;">max</span><span style="color:#441111;">[</span>i,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span>,j,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 1100000000 = 200000000 + 900000000
</span>    wt<span style="color:#662222;">(</span>sum<span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span>i,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span>,j=<span style="color:#AA00AA;">0</span>--<span style="color:#AA00AA;">-2</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 4400000000 (ll型なのでオーバーフローしない)
</span>    wt<span style="color:#662222;">(</span>gcd<span style="color:#441111;">[</span><span style="color:#662222;">(</span>i,j<span style="color:#662222;">)</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 100000000
</span>    wt<span style="color:#662222;">(</span>lcm<span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#662222;">(</span>i,j<span style="color:#662222;">)</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#441111;">[</span>j<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 63000000000
</span>  <span style="color:#440000;font-weight:bold;">}</span>
  <span style="color:#440000;font-weight:bold;">{</span>
    wt<span style="color:#662222;">(</span><span style="color:#000000;font-weight:bold;">max</span><span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span> i,<span style="color:#AA00AA;">1d10</span>,<span style="color:#AA00AA;">1d10</span>+<span style="color:#AA00AA;">20</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>i+<span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 10000000021
</span>  <span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<HR>

<ul><li>bsearch_min[type,name,minval,maxval(,option)][block](cond): 「blockを実行した上でcondを満たす」最小の minval &le; name &le; maxval の値を返す．(,option)，[block]は省略可能．</li>
<li>bsearch_max[type,name,minval,maxval(,option)][block](cond): 「blockを実行した上でcondを満たす」最大の minval &le; name &le; maxval の値を返す．(,option)，[block]は省略可能．</li>
</ul>
<p>それぞれ単調性が成り立たなければならない．<br>例えば，bsearch_minの場合，name=10のときcondが成り立つならば，name=10以上（maxval以下）のときもcondは成り立たなければならない．<br>typeは変数nameの型を指定し，float, doubleの場合は実数の二分探索，それ以外は整数の二分探索を行う．<br>bsearch_minでは，name=maxvalでは評価されず，name=maxvalより小さい場合に常に偽ならmaxvalが返ってくる（name=maxvalのときはblock, condが未定義になるようなものでも良い）．<br>今のところ，minval, maxvalは省略不可能．<br></p>
<p>optionは以下の通り．<br></p>
<ul><li>AE=val : 実数の二分探索で，絶対誤差でval以下が保証できるようになったら打ち切る．</li>
<li>RE=val : 実数の二分探索で，相対誤差でval以下が保証できるようになったら打ち切る．</li>
<li>E=val : 実数の二分探索で，絶対誤差または相対誤差でval以下が保証できるようになったら打ち切る．</li>
</ul>
<p>実数の二分探索で，許容誤差を指定しない場合は，見ている範囲を[x,y]としたとき，(x+y)/2が（計算機上で）xまたはyに一致したら打ち切る（許容誤差を指定してもこの判定は行う）．<br></p>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i, j, k, t<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">double</span> x, y<span style="color:#000000;">;</span>

  k = <span style="color:#AA00AA;">-1</span><span style="color:#000000;">;</span>
  i = bsearch_max<span style="color:#441111;">[</span><span style="color:#0000FF;">int</span>,k,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>k*k&lt;=<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  j = bsearch_min<span style="color:#441111;">[</span><span style="color:#0000FF;">int</span>,k,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span>
    t = <span style="color:#AA00AA;">0</span><span style="color:#000000;">;</span>
    <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>j,<span style="color:#AA00AA;">1</span>,k+<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span> t += k / j<span style="color:#000000;">;</span>
  <span style="color:#441111;">]</span><span style="color:#662222;">(</span>t &gt;= <span style="color:#AA00AA;">100</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  x = bsearch_max<span style="color:#441111;">[</span><span style="color:#0000FF;">double</span>,x,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>x*x&lt;=<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  y = bsearch_max<span style="color:#441111;">[</span><span style="color:#0000FF;">double</span>,x,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">100</span>,E=<span style="color:#AA00AA;">1e-1</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>x*x&lt;=<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

  wt<span style="color:#662222;">(</span>i,j,k,x,y<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 3 28 -1 3.162277660168380 3.222656250000000
</span></span></pre>
<HR>

<p>三分探索（内部実装は少し違うかも）のようなもの．二分探索とほぼ同様の書き方．<br></p>
<ul><li>tsearch_min[type,name,minval,maxval(,option)][block](eq): name=kを代入してblockを実行した上でeqを計算するとき，最小のeqの値を返す．ただし，minval &le; name &le; maxval の間を動く．</li>
<li>tsearch_max[type,name,minval,maxval(,option)][block](eq): 同様に最大の値を返す</li>
<li>tsearch_argmin[type,name,minval,maxval(,option)][block](eq): 最小となるときのnameの値を返す．複数あるならその中で最小のものを返す．</li>
<li>tsearch_argminL[type,name,minval,maxval(,option)][block](eq): 最小となるときのnameの値を返す．複数あるならその中で最大のものを返す．</li>
<li>tsearch_argmax[type,name,minval,maxval(,option)][block](eq): 最大となるときのnameの値を返す．複数あるならその中で最小のものを返す．</li>
<li>tsearch_argmaxL[type,name,minval,maxval(,option)][block](eq): 最大となるときのnameの値を返す．複数あるならその中で最大のものを返す．</li>
</ul>
<p>optionは以下の通り．<br></p>
<ul><li>T=TYPE : eqの型がTYPEであることを指定する．blockの中で変数を定義してeqの中で使う場合，型を推測できないので必要になる．</li>
</ul>
<p>最小値を求める場合，name=kのときのeqの値を f(k) と書くことにしたら，とある L &le; R が存在して<br>minval &le; x &lt; y &le; L のとき f(x) &gt; f(y),<br>L &le; x &lt; y &le; R のとき f(x) = f(y),<br>R &le; x &lt; y &le; maxval のとき f(x) &lt; f(y)<br>が成り立たなければならない．<br></p>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  wt<span style="color:#662222;">(</span>tsearch_min<span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span>,x,<span style="color:#AA00AA;">-1d9</span>,<span style="color:#AA00AA;">1d9</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>x*<span style="color:#662222;">(</span>x+<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                                 <span style="color:#888888;">// -25
</span>  wt<span style="color:#662222;">(</span>tsearch_argmin<span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span>,x,<span style="color:#AA00AA;">-1d9</span>,<span style="color:#AA00AA;">1d9</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>x*<span style="color:#662222;">(</span>x+<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                              <span style="color:#888888;">// -5
</span>
  wt<span style="color:#662222;">(</span>tsearch_max<span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span>,x,<span style="color:#AA00AA;">-1d9</span>,<span style="color:#AA00AA;">1d9</span>,T=<span style="color:#0000FF;">ll</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span> y<span style="color:#000000;">;</span> y = x + <span style="color:#AA00AA;">5</span><span style="color:#000000;">;</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>-<span style="color:#662222;">(</span>y-<span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span>*<span style="color:#662222;">(</span>y+<span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>      <span style="color:#888888;">// 25
</span>  wt<span style="color:#662222;">(</span>tsearch_argmax<span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span>,x,<span style="color:#AA00AA;">-1d9</span>,<span style="color:#AA00AA;">1d9</span>,T=<span style="color:#0000FF;">ll</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#0000FF;">ll</span> y<span style="color:#000000;">;</span> y = x + <span style="color:#AA00AA;">5</span><span style="color:#000000;">;</span><span style="color:#441111;">]</span><span style="color:#662222;">(</span>-<span style="color:#662222;">(</span>y-<span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span>*<span style="color:#662222;">(</span>y+<span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// -5
</span><span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<p>参考：<a href="http://rsujskf.s602.xrea.com/?codeforces_679_div1_c">Codeforces Round #679 DIV1 C問題 - Solo mid Oracle</a><br></p>

<HR>

<ul><li>template&lt;class T&gt; inline int isPrime(T N, void *mem = wmem): N が素数なら 1，そうでないなら 0 を返す．</li>
<li>int Prime(int N, int res[], void *mem = wmem): N 未満の素数を列挙する．</li>
<li>template&lt;class T&gt; void intervalSieve(ll st, int len, T res[], int ps, int p[]) : 区間篩．res[i]はst+iが素数なら1，そうでないなら0が代入される（i=0,1,...,len-1）．ps, p[]としてsqrt(st+len-1)以下の素数を列挙しておく必要がある．</li>
<li>template&lt;class T, class R1, class R2&gt; int Factor(T N, R1 fac[], R2 fs[], void *mem = wmem): 素因数と重複度を求める．下記の例を参照．facは異なる素因数，fsはその素因数を何個持つか．Tはint, llなどの整数．</li>
<li>template&lt;class T, class R&gt; int Factor(T N, R fac[], void *mem = wmem): 相異なる素因数を求める．下記の例を参照．Tはint, llなどの整数．</li>
<li>template&lt;class T&gt; int Factor(T N, void *mem = wmem): 相異なる素因数の個数を求める．Tはint, llなどの整数．</li>
<li>template&lt;class T, class R&gt; int FactorM(T N, R fac[], void *mem = wmem): 重複を含めて素因数を求める．下記の例を参照．Tはint, llなどの整数．</li>
<li>template&lt;class T, class R&gt; int FactorM(T N, void *mem = wmem): FactorMでfacが要らない場合（素因数の数だけ求めれば良い場合）．</li>
<li>template&lt;class T, class R&gt; int Divisor(T N, R dv[], void *mem = wmem): 約数を求める．下記の例を参照．Tはint, llなどの整数．</li>
<li>template&lt;class T&gt; ll DivisorSum(ll N, void *mem = wmem): 約数の和を求める．</li>
<li>template&lt;class T&gt; T EulerPhi(T n, void *mem = wmem): オイラーのファイ関数（totient関数）．gcd(i,k)=1なる1以上k以下のiの個数．</li>
<li>template&lt;class T&gt; int Moebius(T n, void *mem = wmem): メビウス関数の値を求める．nが平方数で割り切れるなら0を返し，そうでないなら素因数の数を $k$ として $(-1)^k$ を返す．</li>
</ul>
<p>isPrime, Factor, FactorM, Divisor, DivisorSum, EulerPhi, Moebius においては，Nが64ビットに収まるならば，ミラーラビン，ポラードローなどを利用します（現状）．<br>64ビットに収まらない場合は愚直な実装です．<br>内部で128bit整数 __uint128_t 型を使っています．<br></p>
<ul><li>template&lt;class T&gt; void minFactorList(int N, T res[]): k=0,1,...,N-1に対して res[k] = [kの最小の素因数]，を計算します．特にkが素数の場合 res[k] = k になります．res[0]=res[1]=0．</li>
<li>template&lt;class T&gt; void maxFactorList(int N, T res[]): k=0,1,...,N-1に対して res[k] = [kの最大の素因数]，を計算します．</li>
<li>template&lt;class T&gt; void FactorList(int N, T res[], void *mem = wmem): k=0,1,...,N-1に対して res[k] = [kの相異なる素因数の数]，を計算します．Factor(k)の戻り値を列挙．</li>
<li>template&lt;class T&gt; void FactorMList(int N, T res[], void *mem = wmem): k=0,1,...,N-1に対して res[k] = [kの重複を含めた素因数の数]，を計算します．FactorM(k)の戻り値を列挙．</li>
<li>template&lt;class T&gt; void EulerPhiList(int N, T res[], void *mem = wmem): k=0,1,...,N-1に対して res[k] = EulerPhi(k)，を計算します．</li>
</ul>
<p>xxxList系の関数は特に記述がなければだいたい O(N log N) 時間以内ぐらいのつもり．<br></p>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> fac<span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span>, fs<span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span>, fsz<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> dv<span style="color:#441111;">[</span><span style="color:#AA00AA;">100</span><span style="color:#441111;">]</span>, dsz<span style="color:#000000;">;</span>

  fsz = Factor<span style="color:#662222;">(</span><span style="color:#AA00AA;">1500</span>, fac, fs<span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 1500 = 2^2 * 3^1 * 5^3
</span>  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,fsz<span style="color:#662222;">)</span> wt<span style="color:#662222;">(</span>fac<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>, fs<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// fsz=3, fac={2,3,5}, fs={2,1,3}
</span>
  fsz = Factor<span style="color:#662222;">(</span><span style="color:#AA00AA;">1500</span>, fac<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>fac<span style="color:#662222;">(</span>fsz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                  <span style="color:#888888;">// 2 3 5
</span>
  fsz = FactorM<span style="color:#662222;">(</span><span style="color:#AA00AA;">1500</span>, fac<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>fac<span style="color:#662222;">(</span>fsz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                  <span style="color:#888888;">// 2 2 3 5 5 5
</span>
  dsz = Divisor<span style="color:#662222;">(</span><span style="color:#AA00AA;">24</span>, dv<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>dv<span style="color:#662222;">(</span>dsz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                   <span style="color:#888888;">// 1 2 3 4 6 8 12 24
</span></span></pre>
<HR>

<ul><li>ll cntPrime(ll n, void *mem = wmem) : n 以下の素数の個数を返します．現状O(n^0.75)だと思う，多分．</li>
<li>template&lt;class T&gt; T sumPrime(ll n, void *mem = wmem) : n 以下の素数の和を返します．現状O(n^0.75)だと思う，多分．res = sumPrime&lt;__int128_t&gt;(n); や res = sumPrime&lt;Modint&gt;(n); で使用する．</li>
</ul>

<HR>

<ul><li>ull powmod(ull a, ull b, ull m) : a の b 乗を mod m で求める．a は 32bit 以内の整数．</li>
<li>template&lt;class T, class P, class M&gt; T PowMod(T a, P b, M m) : a の b 乗を mod m で求める．基本的にTの型で演算をやる．Tの型の変数にintの1を代入すると単位元になることが必要（T=Polynomial&lt;Modint&gt;などはOK）．bは，現状，負は未対応（b=0と同じ結果）．</li>
<li>ll primitiveRoot(ll p, void *mem = wmem) : 素数 p に対して，mod p での最小の原子根を返す．p は 32bit 以内の整数．pが素数でなければ -1 を返すことにしているが将来的には素数でない場合の挙動は変わるかも．時間計算量は $O(\sqrt{p} + yk \log p)$ 程度，ただし y は p-1 の約数の個数，k は答え=最小の原子根．</li>
<li>int get_inv_mod(ll a, int md) : mod md での a の逆元を返す．gcd(a, md) = 1 が必要．</li>
<li>void extendedEuclid(ll a, ll b, ll &x, ll &y, ll &z) : ax + by = z を満たす x, y, z を求める．ただし，z = gcd(|a|,|b|) &ge; 0 で x, y は xは非負で最小となるようなものを返す（b=0でxが負しか存在しない場合はそれを返す，yが複数存在する場合はy=0を返す）．a = b = 0 の場合は x = y = z = 0 を返す．</li>
<li>void extendedEuclid(ll a, ll b, ll &x, ll &y) : 上の関数でzが不要な場合．</li>
<li>ll chineseRemainder(int sz, ll val[], ll md[]) : 中国剰余定理CRT．x = val[k] (mod md[k]), k = 0, 1, ..., sz-1 が成り立つような最小の非負整数 x を返す．存在しないなら -1 を返す．lcm(md[]) が 2^62 程度まで．val[k] は 0 以上 md[k] 未満である必要はない．</li>
</ul>

<HR>

<ul><li>gcd(), GCD(): 引数の最大公約数を返します．rd, wtのように配列を指定可能です．</li>
<li>lcm(), LCM(): 引数の最小公倍数を返します．rd, wtのように配列を指定可能です．</li>
<li>min(), MIN(): 引数の最小値を返します．rd, wtのように配列を指定可能です．</li>
<li>max(), MAX(): 引数の最大値を返します．rd, wtのように配列を指定可能です．</li>
<li>sum(), SUM(): 引数の和を返します．rd, wtのように配列を指定可能です．</li>
<li>mul(), MUL(): 引数の積を返します．rd, wtのように配列を指定可能です．</li>
<li>XOR(): 引数のビットごとの排他的論理和を返します．rd, wtのように配列を指定可能です．</li>
<li>OR(): 引数のビットごとの論理和を返します．rd, wtのように配列を指定可能です．</li>
<li>AND(): 引数のビットごとの論理積を返します．rd, wtのように配列を指定可能です．</li>
</ul>
<p>関数名がよく使う名前なのでこの機能を無効化するフラグがあります（フラグの欄を参照のこと）．<br>引数の型は違っても構いませんが，計算途中でどのような型になるかは不明です（オーバーフローなどに注意）．<br>今のところ，整数と浮動小数点数ぐらいでしか上手く動かないと思います．例外的にsum()はstring型でも動くはずです（文字列を連結します）．<br>配列は長さ0の配列を与えると上手く動かないことがあります．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> i = <span style="color:#AA00AA;">10</span>, j = <span style="color:#AA00AA;">75</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">int</span> k<span style="color:#441111;">[</span><span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">100</span>, <span style="color:#AA00AA;">200</span>, <span style="color:#AA00AA;">300</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>gcd<span style="color:#662222;">(</span>i,j,k<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// gcd(10,75,100,200,300) = 5
</span>wt<span style="color:#662222;">(</span><span style="color:#000000;font-weight:bold;">min</span><span style="color:#662222;">(</span>i,j,k<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// min(10,75,100,200,300) = 10
</span>wt<span style="color:#662222;">(</span>sum<span style="color:#662222;">(</span>i,j,k<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// sum(10,75,100,200,300) = 685
</span></span></pre>
<p>min(), max() については（ //no-min() などのフラグを使わなければ）標準のC++の min(), max() を上書きして使えなくなる（両立できなくなる）ので，<br>std::min(), std::max() と std:: をつけると cLay の機能でなく，C++ のmin(), max() を使います．<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> x = <span style="color:#AA00AA;">-10</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">ull</span> y = <span style="color:#AA00AA;">4</span><span style="color:#000000;">;</span>
<span style="color:#0000FF;">ll</span> z<span style="color:#000000;">;</span>

z = <span style="color:#000000;font-weight:bold;">min</span><span style="color:#662222;">(</span>x,y<span style="color:#662222;">)</span> * <span style="color:#AA00AA;">1000000000</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>z<span style="color:#662222;">)</span><span style="color:#000000;">;</span>                 <span style="color:#888888;">// -10000000000 (min(x,y) はll型の-10になる; 一番桁数が大きいものの符号付きになる)
</span>
z = <span style="color:#000000;font-weight:bold;">std</span>::<span style="color:#000000;font-weight:bold;">min</span><span style="color:#662222;">(</span>x,y<span style="color:#662222;">)</span><span style="color:#000000;">;</span>     <span style="color:#888888;">// C++のminでは型が揃ってないのでコンパイルエラー
</span>
z = <span style="color:#000000;font-weight:bold;">min</span><span style="color:#662222;">(</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>      <span style="color:#888888;">// cLay の機能ではコンパイルエラー
</span>z = <span style="color:#000000;font-weight:bold;">std</span>::<span style="color:#000000;font-weight:bold;">min</span><span style="color:#662222;">(</span><span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// C++のminでは z=1 になる
</span></span></pre>
<HR>

<ul><li>template&lt;class T&gt; void slideMin(int n, int k, T in[], T res[], void *mem = wmem) : スライド最小値．長さnの配列inに対して，長さkの区間の最小値を全て求めます．res[i] = min(in[i], ..., in[i+k-1]) になります（i=0,1,...,n-k）．時間計算量 $O(n)$．</li>
<li>template&lt;class T&gt; void slideMax(int n, int k, T in[], T res[], void *mem = wmem) : スライド最大値．長さnの配列inに対して，長さkの区間の最大値を全て求めます．res[i] = max(in[i], ..., in[i+k-1]) になります（i=0,1,...,n-k）．時間計算量 $O(n)$．</li>
<li>template&lt;class T, class S&gt; auto maxRectArea(int N, T H[], S W[], void *mem = wmem) : H[i], W[i]は非負．高さH[i]，幅W[i]の長方形が並んでいるとき，その領域の内部に含まれるような最大の長方形の面積を返す．つまり，i, j が動くときの，max( (W[i]+...+W[j]) * min(H[i], ..., H[j]) ) を返す．いわゆるヒストグラム中の最大長方形．幅が1固定の場合は下の関数も可．戻り値は H[0] * S[0] の型．</li>
<li>template&lt;class T&gt; T maxRectArea(int N, T H[], void *mem = wmem) : 上の関数において全てのiに対して W[i] = 1 の場合の答えを返す．</li>
</ul>

<HR>

<p>Comb 構造体は（1つ下のconbination_mintのように）階乗などを前計算しておき組合せ的な数を求める構造体です．<br>Comb&lt;T&gt; comb; で定義したとします．T は mint, modint, Mint, Modint のどれかを想定しています．<br>必要な値がない場合は，必要になったときに勝手に計算します．<br></p>
<p>使いそうなの<br></p>
<ul><li>T comb.C(int a, int b) : 二項係数 C(a,b) = $\frac{a!}{b!(a-b)!}$ を返します（bが負，a以上のときは0を返します）．</li>
<li>T comb.P(int a, int b) : P(a,b) = $\frac{a!}{(a-b)!}$ を返します</li>
<li>T comb.H(int a, int b) : 重複組合せ H(a,b) = C(a+b-1, b) を返します</li>
<li>T comb.C_s(ll a, ll b) : 二項係数 C(a,b) を前計算する階乗を使用せずに愚直に計算します．時間計算量は $O( \min (b, a-b) )$ 程度です．</li>
<li>T comb.P_s(ll a, ll b) : P(a,b) を前計算する階乗を使用せずに愚直に計算します．時間計算量は $O(b)$ 程度です．</li>
<li>T comb.H_s(ll a, ll b)</li>
<li>T comb.fac(int k) : 階乗 $k!$ を返します</li>
<li>T comb.ifac(int k) : 階乗の逆数 $\frac{1}{k!}$ を返します</li>
<li>T comb.Multinomial(int sz, int a[]) : 多項係数 $\frac{(a[0]+a[1]+ \cdots + a[sz-1])!}{a[0]! a[1]! \cdots a[sz-1]!}$ を返します</li>
<li>T comb.Multinomial(int a) : 1 を返します</li>
<li>T comb.Multinomial(int a, int b) : $\frac{(a+b)!}{a! b!}$ を返します</li>
<li>T comb.Multinomial(int a, int b, int c) : $\frac{(a+b+c)!}{a! b! c!}$ を返します</li>
<li>T comb.Multinomial(int a, int b, int c, int d) : $\frac{(a+b+c+d)!}{a! b! c! d!}$ を返します</li>
<li>T comb.Catalan(int n) : カタラン数 $\frac{(2n)!}{n! (n+1)!}$ を返します</li>
<li>T comb.Catalan(int n, int m, int k) : 右にn回，上にm回進む格子路において，右下の角から距離k以下の部分が通れない場合の経路の数を求めます（<a href="http://rsujskf.s602.xrea.com/img/20210619.png">画像</a>）．n=m=kの場合普通のカタラン数に，kが0以下の場合は二項係数に，kがmin(n,m)より大きい場合は0に，その他の場合 C(n+m, m) - C(n+m, k-1) になります．</li>
<li>T comb.Catalan_s(ll n, ll m, ll k)</li>
<li>T comb.per_s(ll n, ll k) : 整数 n をちょうど k 個の正整数の和に分割する場合の数（k以下の整数の和に分割する場合の数）を求めます．現在 k は 3 以下の場合にのみ対応しています．時間計算量は $O(k!)$ 程度です．</li>
<li>T comb.dfac(int k) : 二重階乗 $k!!$ を返します．k が負の奇数の場合も動きますが，現状手抜きで毎回逆数の計算が入るので前計算除いても O(1) ではないです．</li>
<li>T comb.pw2(int k) : $2^k$ を返します．k が負の場合も動きます．$\min(0,k) \leq i \leq \max(0,k)$ なる $i$ に対して $2^i$ を全て計算するので，$|k|$ が大きいとき，何回も呼び出さない場合は ** 演算子などを利用するほうが良いです．</li>
<li>T comb.pw3(int k) : $3^k$ を返します．</li>
<li>T comb.pw10(int k) : $10^k$ を返します．</li>
<li>T comb.repunit(int k) : $(10^k-1) / 9$ を返します．これは 1 が k 個連続する値です．k は非負の整数でないといけません．</li>
</ul>
<p>使わなさそうなの：変数<br></p>
<ul><li>int mem_fact : 階乗，階乗の逆数をどれだけメモリ確保して前計算しているか</li>
<li>T *factri : 前計算した階乗の値 factri[i] = i!</li>
<li>T *ifactri : 前計算した階乗の逆数値 factri[i] = 1/i!</li>
</ul>
<p>使わなさそうなの：関数<br></p>
<ul><li>Comb() : コンストラクタ（メモリ確保状況 mem_fact などを0に設定）</li>
<li>void expand_fact(int k) : 階乗と階乗の逆数の 0! から (k-1)! まで（もしくはそれ以上に）前計算をする．既にk以上が前計算されていれば何もしない</li>
</ul>

<HR>

<p>combination_mint は階乗とその逆数を前計算することで二項係数を高速に求めます．mint型で答えを返します．<br>構造体を使用しているので combination_mint comb; と最初に宣言して下さい．<br></p>
<ul><li>comb.init(int n, void **mem = &wmem) : 階乗とその逆数をを 0 乗から n-1 乗まで計算します．ワーキングメモリを使用します．</li>
<li>mint comb.fac[] : fac[i] に i の階乗を格納しています．</li>
<li>mint comb.ifac[] : ifac[i] に i の階乗の逆元を格納しています．</li>
<li>mint comb.C(int a, int b) : C(a,b) = $\frac{a!}{b!(a-b)!}$ を返します（bが負，a以上のときは0を返します）．aはnより小さい必要があります．</li>
<li>mint comb.P(int a, int b) : P(a,b) = $\frac{a!}{(a-b)!}$ を返します．aはnより小さい必要があります．</li>
<li>mint comb.H(int a, int b) : H(a,b) = C(a+b-1, b) を返します．a+b-1はnより小さい必要があります．</li>
</ul>

<pre><span style="color:#444444">  combination_mint comb<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">mint</span> res<span style="color:#000000;">;</span>

  comb.init<span style="color:#662222;">(</span><span style="color:#AA00AA;">101</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>     <span style="color:#888888;">// 100の階乗までを計算．以降 C(100,hoge) まで計算可能
</span>  res = comb.C<span style="color:#662222;">(</span><span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>            <span style="color:#888888;">// 10 = 5*4/2 = 5個から2個を選ぶ選び方
</span></span></pre>
<HR>

<ul><li>reduceFraction(a,b) : aとbをgcd(a,b)で割ります（分数a/bを約分します）．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> a = <span style="color:#AA00AA;">32</span>, b = <span style="color:#AA00AA;">24</span><span style="color:#000000;">;</span>
  reduceFraction<span style="color:#662222;">(</span>a,b<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wtF<span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;{a}/{b}\n&quot;</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>         <span style="color:#888888;">// 4/3 と表示
</span></span></pre>
<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> fibonacci_mod<span style="color:#662222;">(</span><span style="color:#0000FF;">ull</span> n, <span style="color:#0000FF;">int</span> md<span style="color:#662222;">)</span></span></span>, <span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> fib_mod<span style="color:#662222;">(</span><span style="color:#0000FF;">ull</span> n, <span style="color:#0000FF;">int</span> md<span style="color:#662222;">)</span></span></span> : フィボナッチ数の第 n 項を mod md （Fn mod md）で求めます．mdを省略するとmd = MDが指定されます．O(log n) 時間．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> Fibonacci_mod<span style="color:#662222;">(</span><span style="color:#0000FF;">ull</span> n<span style="color:#662222;">)</span></span></span> : Fn mod MD を返します（MD は define MD で定義したもの，定義してなければ10^9+7）</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">int</span> Fib_mod<span style="color:#662222;">(</span><span style="color:#0000FF;">ull</span> n<span style="color:#662222;">)</span></span></span> : Fn mod MD を返します．行列べき乗の要素に対応するものを前計算しておきます（たくさん呼び出す場合は多少 Fibonacci() より高速です）</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> i, f<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span> f<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span> = fib_mod<span style="color:#662222;">(</span>i<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>f<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                    <span style="color:#888888;">// 0 1 1 2 3 5 8 13 21 34
</span></span></pre>
<HR>

<ul><li>template&lt;class T&gt; inline int Cmod2(T n, T k) : C(n,k) mod 2 を返す．</li>
</ul>

<HR>

<ul><li>template&lt;class T1, class T2&gt; int LinearEquationMod2(int R, int C, T1 **A, T2 *b, void *mem = wmem) : mod2でAx=bの解の個数を求める．解が存在しなければ-1を返し，解が2^k個ならばkを返す．A,bは要素が全部0か1．行列AはR行C列のベクトルbはR次元．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> LinearEquation<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> R, <span style="color:#0000FF;">int</span> C, T **A, T *b, T *x, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 連立一次方程式 Ax=b の解を1つ求める．解が存在しなければ -1 を返し，存在する場合は解空間の次元（任意定数の個数，0以上の整数）を返す．実数の場合は，絶対値がこの値以下になったら 0 とみなすグローバル変数 <span id="code"><span style="color:#444444"><span style="color:#0000FF;">double</span> LinearEquation_EPS = <span style="color:#AA00AA;">1e-9</span><span style="color:#000000;">;</span></span></span> があるので書き換えても良い．T は Modint, Mint, modint, mint (ただし法は素数) や double, float あたりを想定．</li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">double</span> **a, *b, *x<span style="color:#000000;">;</span>
walloc2d<span style="color:#662222;">(</span>&amp;a, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
walloc1d<span style="color:#662222;">(</span>&amp;b, <span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
walloc1d<span style="color:#662222;">(</span>&amp;x, <span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

writerDigit_double<span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

a<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">3</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">4</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">5.5</span><span style="color:#000000;">;</span>
a<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">3</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">4</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">5.5</span><span style="color:#000000;">;</span>
a<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">2</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">2.5</span><span style="color:#000000;">;</span>

wt<span style="color:#662222;">(</span>LinearEquation<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">2</span>, a, b, x<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>x<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre>
0
0.5000 1.0000
</pre>
<p>と<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">double</span> **a, *b, *x<span style="color:#000000;">;</span>
walloc2d<span style="color:#662222;">(</span>&amp;a, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
walloc1d<span style="color:#662222;">(</span>&amp;b, <span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
walloc1d<span style="color:#662222;">(</span>&amp;x, <span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

a<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">3</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">4</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">5.5</span><span style="color:#000000;">;</span>
a<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">3</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">4</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">5.6</span><span style="color:#000000;">;</span>
a<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">2</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">2.5</span><span style="color:#000000;">;</span>

wt<span style="color:#662222;">(</span>LinearEquation<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">2</span>, a, b, x<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre>
-1
</pre>
<p>と<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">double</span> **a, *b, *x<span style="color:#000000;">;</span>
walloc2d<span style="color:#662222;">(</span>&amp;a, <span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
walloc1d<span style="color:#662222;">(</span>&amp;b, <span style="color:#AA00AA;">3</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
walloc1d<span style="color:#662222;">(</span>&amp;x, <span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>

writerDigit_double<span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
LinearEquation_EPS = <span style="color:#AA00AA;">0.5</span><span style="color:#000000;">;</span>

a<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">3</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">4</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">5.5</span><span style="color:#000000;">;</span>
a<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">3</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">4</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">5.6</span><span style="color:#000000;">;</span>
a<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">0</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">1</span><span style="color:#000000;">;</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">2</span><span style="color:#000000;">;</span> b<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span> = <span style="color:#AA00AA;">2.5</span><span style="color:#000000;">;</span>

wt<span style="color:#662222;">(</span>LinearEquation<span style="color:#662222;">(</span><span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">2</span>, a, b, x<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
wt<span style="color:#662222;">(</span>x<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>は<br></p>

<pre>
0
0.5000 1.0000
</pre>
<p>と出力されます（最後の例は，実装に依存する部分があり，将来的に多少変わる可能性もあります）．<br></p>

<HR>

<ul><li>Modint Determinant(int n, Modint **mat, void *mem = wmem) : n*nの行列matの行列式を返します</li>
<li>modint Determinant(int n, modint **mat, void *mem = wmem) : n*nの行列matの行列式を返します</li>
<li>Mint Determinant(int n, Mint **mat, void *mem = wmem) : n*nの行列matの行列式を返します</li>
<li>mint Determinant(int n, mint **mat, void *mem = wmem) : n*nの行列matの行列式を返します</li>
</ul>

<HR>


<ul><li>template&lt;class T&gt; int LIS_length(int n, T a[], void *mem = wmem) : 要素数nの配列aの最長増加部分列の長さを返す</li>
<li>template&lt;class T&gt; int weaklyLIS_length(int n, T a[], void *mem = wmem) : 要素数nの配列aの最長非減少部分列の長さを返す</li>
<li>template&lt;class T&gt; int LIS_ends(int n, T a[], S res[], void *mem = wmem) : a[k]を最後に使う最長増加部分列の長さをres[k]に入れ，最長増加部分列の長さ = max(res[k]) を返す</li>
<li>template&lt;class T&gt; int weaklyLIS_ends(int n, T a[], S res[], void *mem = wmem)</li>
</ul>

<pre><span style="color:#444444"><span style="color:#440000;font-weight:bold;">{</span>
  <span style="color:#0000FF;">int</span> N = <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> len, res<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  len = LIS_ends<span style="color:#662222;">(</span>N, A, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>len, <span style="color:#00AA22;">&quot;:&quot;</span>, res<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>             <span style="color:#888888;">// 3 : 1 1 2 3 2 1 3 2 3 1
</span>  len = weaklyLIS_ends<span style="color:#662222;">(</span>N, A, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>len, <span style="color:#00AA22;">&quot;:&quot;</span>, res<span style="color:#662222;">(</span>N<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>             <span style="color:#888888;">// 5 : 1 1 2 3 3 2 4 4 5 3
</span><span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">int</span> coordcomp<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n, <span style="color:#4444FF;">const</span> T arr<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, S res<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 座標圧縮．arrの各要素の大きさの順番を維持したまま小さな非負整数に変換したものをresに格納．異なる要素の数を戻り値として返す．coordcomp()の代わりにcoord_comp()も可能．$O(n \log n)$ 時間．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> coordcomp<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n, T arr<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 上において，resに結果を格納する代わりにarrに上書きする．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S1, <span style="color:#0088FF;">class</span> S2&gt; <span style="color:#0000FF;">int</span> coordcomp<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n1, <span style="color:#4444FF;">const</span> T arr1<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> n2, <span style="color:#4444FF;">const</span> T arr2<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, S1 res1<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, S2 res2<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 座標圧縮．2つの配列を連結してから処理する．異なる要素の数を戻り値として返す．coordcomp()の代わりにcoord_comp()も可能．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> coordcomp<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n1, T arr1<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> n2, T arr2<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S1, <span style="color:#0088FF;">class</span> S2, <span style="color:#0088FF;">class</span> S3&gt; <span style="color:#0000FF;">int</span> coordcomp<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n1, <span style="color:#4444FF;">const</span> T arr1<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> n2, <span style="color:#4444FF;">const</span> T arr2<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> n3, <span style="color:#4444FF;">const</span> T arr3<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, S1 res1<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, S2 res2<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, S3 res3<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 座標圧縮．3つの配列を連結してから処理する．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">int</span> coordcomp<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> n1, T1 arr1<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> n2, T arr2<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> n3, T arr3<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span></li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> n<span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> C<span style="color:#441111;">[</span><span style="color:#AA00AA;">5</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1000</span>, <span style="color:#AA00AA;">100</span>, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">100</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  
  n = coordcomp<span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span>, C<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>n<span style="color:#662222;">)</span><span style="color:#000000;">;</span>       <span style="color:#888888;">// 4
</span>  wt<span style="color:#662222;">(</span>C<span style="color:#662222;">(</span><span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>    <span style="color:#888888;">// 3 2 0 1 2
</span>  
  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">5</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">100</span>, <span style="color:#AA00AA;">4</span>, <span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">4</span>, <span style="color:#AA00AA;">100</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> B<span style="color:#441111;">[</span><span style="color:#AA00AA;">4</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">8</span>, <span style="color:#AA00AA;">2</span>, <span style="color:#AA00AA;">1200</span>, <span style="color:#AA00AA;">8</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> rA<span style="color:#441111;">[</span><span style="color:#AA00AA;">5</span><span style="color:#441111;">]</span>, rB<span style="color:#441111;">[</span><span style="color:#AA00AA;">4</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>

  n = coordcomp<span style="color:#662222;">(</span><span style="color:#AA00AA;">5</span>, A, <span style="color:#AA00AA;">4</span>, B, rA, rB<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>n<span style="color:#662222;">)</span><span style="color:#000000;">;</span>       <span style="color:#888888;">// 5
</span>  wt<span style="color:#662222;">(</span>A<span style="color:#662222;">(</span><span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>    <span style="color:#888888;">// 100 4 8 4 100
</span>  wt<span style="color:#662222;">(</span>B<span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>    <span style="color:#888888;">// 8 2 1200 8
</span>  wt<span style="color:#662222;">(</span>rA<span style="color:#662222;">(</span><span style="color:#AA00AA;">5</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 3 1 2 1 3
</span>  wt<span style="color:#662222;">(</span>rB<span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 2 0 4 2
</span></span></pre>
<HR>

<p>次元圧縮．多次元のグリッドでのBFSなどに．<br>構造体で，[x]次元のものは dimcomp[x] c; で定義したとする．2次元～5次元まで．<br></p>
<p>2次元 dimcomp2 c; で定義．<br></p>
<ul><li>dimcomp2(){} : コンストラクタ．</li>
<li>dimcomp2(int b) : コンストラクタ．c.set(b); と同じ．</li>
<li>dimcomp2(int a, int b) : コンストラクタ．c.set(a,b); と同じ．</li>
<li>inline void c.set(int b) : (x,y) で y は 0 以上 b 未満を動くと設定する．（(x,y) は x*b+y に対応させることにする）</li>
<li>inline void c.set(int a, int b) : (x,y) で x は 0 以上 a　未満を，y は 0 以上 b 未満を動くと設定する．実は a は使ってないが．</li>
<li>inline int c.mask(int a, int b) : (a,b) に対応する値を返す．</li>
<li>inline int operator()(int a, int b) : c.mask(a,b) と同じ．</li>
<li>inline void para(int mask, int &amp;a, int &amp;b) : mask に対応する座標を a, b に代入する．</li>
<li>inline void operator()(int mask, int &amp;a, int &amp;b) : c.para(mask, a, b) と同じ．</li>
</ul>
<p>3次元 dimcomp3 c; で定義．<br></p>
<ul><li>dimcomp3(){} : コンストラクタ．</li>
<li>dimcomp3(int b, int c) : コンストラクタ．c.set(b,c); と同じ．</li>
<li>dimcomp3(int a, int b, int c) : コンストラクタ．c.set(a,b,c); と同じ．</li>
<li>inline void c.set(int b, int c) : (x,y,z) で y は 0 以上 b 未満を，z は 0 以上 c 未満を動くと設定する．（(x,y,z) は x*b*c+y*c+z に対応させることにする）</li>
<li>inline void c.set(int a, int b, int c)</li>
<li>inline int c.mask(int a, int b, int c)</li>
<li>inline int operator()(int a, int b, int c)</li>
<li>inline void para(int mask, int &amp;a, int &amp;b, int &amp;c)</li>
<li>inline void operator()(int mask, int &amp;a, int &amp;b, int &amp;c)</li>
</ul>
<p>4次元 dimcomp4 c; で定義．<br></p>
<ul><li>3次元までから推して知るべし</li>
</ul>
<p>5次元 dimcomp5 c; で定義．<br></p>
<ul><li>3次元までから推して知るべし</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> dx, dy, mask<span style="color:#000000;">;</span>
  dimcomp2 c<span style="color:#662222;">(</span><span style="color:#AA00AA;">20</span>,<span style="color:#AA00AA;">15</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>    <span style="color:#888888;">// size = 20 x 15 (dimcomp2 c(15) でもほぼ同じ)
</span>  dx = <span style="color:#AA00AA;">3</span><span style="color:#000000;">;</span> dy = <span style="color:#AA00AA;">9</span><span style="color:#000000;">;</span>
  mask = c<span style="color:#662222;">(</span>dx,dy<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>mask<span style="color:#662222;">)</span><span style="color:#000000;">;</span>             <span style="color:#888888;">// 3 * 15 + 9 = 54
</span>  mask = c<span style="color:#662222;">(</span>dx+<span style="color:#AA00AA;">1</span>, dy<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>mask<span style="color:#662222;">)</span><span style="color:#000000;">;</span>             <span style="color:#888888;">// 4 * 15 + 9 = 69
</span>  c<span style="color:#662222;">(</span>mask,dx,dy<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>dx,dy<span style="color:#662222;">)</span><span style="color:#000000;">;</span>            <span style="color:#888888;">// dx = 4, dy = 9
</span></span></pre>
<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> Unique<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> &amp;N, T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> sorted=<span style="color:#AA00AA;">0</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 要素数Nの配列Aの重複する要素を削除する．要素数，配列は書き換えられる．勝手にソートする．既にソート済みならsorted=1にするとソートしなくなり速くなる．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T, <span style="color:#0088FF;">class</span> S&gt; <span style="color:#0000FF;">void</span> Unique<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> &amp;N, T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, S B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> sorted=<span style="color:#AA00AA;">0</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 上と同じ．A[i]はB[i]個あると思って，要素の数もカウントする．実際は個数じゃないのでB[i]は整数値じゃなくても良い．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">int</span> N = <span style="color:#AA00AA;">7</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">7</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">7</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    Unique<span style="color:#662222;">(</span>N,A<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    <span style="color:#888888;">// N = 3, A = {1, 4, 7}
</span>  <span style="color:#440000;font-weight:bold;">}</span>
  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">int</span> N = <span style="color:#AA00AA;">7</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">7</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">7</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> B<span style="color:#441111;">[</span><span style="color:#AA00AA;">7</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">2</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    Unique<span style="color:#662222;">(</span>N,A,B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    <span style="color:#888888;">// N = 3
</span>    <span style="color:#888888;">// A = {1, 4, 7}
</span>    <span style="color:#888888;">// B = {6, 6, 1}
</span>  <span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<HR>


<p>twoMultisets構造体．<br>格納するデータの型をTとして twoMultisets&lt;T&gt; s; で定義します．格納している要素数を N と書くことにします．<br>中身は2つのmultisetからなっていて，小さい方のいくつかと大きい方のいくつかを格納しています．<br>K番目の値を知りたい場合は，小さい方K個と大きい方N-K個を格納するようにする，などと適当に要素を移動させてクエリに答えます．<br>Kが固定，Kが常にN/2，Kが単調に動く，などの場合に効率的にクエリに答えることができると予想されます．<br>和を求めることもできますが，和も T 型で格納できる必要があります．<br>名前の由来は twopointers っぽい動き方しているような気がしたから．<br></p>
<ul><li>void s.clear() : 中身を空にします</li>
<li>void s.insert(T x) : x を 1 個挿入します</li>
<li>int s.erase(T x) : x を 1 個削除します．削除したら 1 を，その要素が存在しなくて削除できなかったら 0 を返します</li>
<li>int s.size() : 要素数 N を返します</li>
<li>T s.allsum() : 中身の全ての要素の和を返します</li>
<li>T s.Kth(int K) : 小さい方から K+1 番目（0番目から数えるとK番目）の要素の値を返す（0 &le; K &lt; N である必要がある）</li>
<li>T s.Ksum(int K) : 小さい方から K 個の要素の和を返す（0 &le; K &le; N である必要がある）</li>
<li>T s.rKth(int K) : 大きい方から K+1 番目（0番目から数えるとK番目）の要素の値を返す（0 &le; K &lt; N である必要がある）</li>
<li>T s.rKsum(int K) : 大きい方から K 個の要素の和を返す（0 &le; K &le; N である必要がある）</li>
<li>T s.getMin() : 要素の中で最小値を返します（空の場合は何を返すか不明です）</li>
<li>T s.getMin(T x) : 要素の中で最小値を返します（空の場合は x を返します）</li>
<li>T s.getMax() : 要素の中で最大値を返します（空の場合は何を返すか不明です）</li>
<li>T s.getMax(T x) : 要素の中で最大値を返します（空の場合は x を返します）</li>
</ul>
<p>使わないもの<br></p>
<ul><li>twoMultisets() : コンストラクタ．clear() 呼び出すだけ</li>
<li>void s.assign(int K) : 小さい方の要素を格納するmultisetのサイズがKになるように調整する</li>
<li>multiset&lt;T&gt; s.a : 小さい方の要素を格納するmultiset</li>
<li>multiset&lt;T&gt; s.b : 大きい方の要素を格納するmultiset（常に任意のaの要素より任意のbの要素の方が大きいか等しい，が成り立つように管理されている）</li>
<li>T s.sa : 小さい方の要素を格納するmultisetに含まれる要素の和</li>
<li>T s.sb : 大きい方の要素を格納するmultisetに含まれる要素の和</li>
</ul>

<HR>


<p>HashMap構造体．<br>内部ハッシュ（開番地法）でC++のunordered_map的なものを作ります（高速かつ簡単に性能が劣化するケースが作れないようにしたいと思っていますがそうなってるかは謎）．<br>HashMap&lt;KEY,VAL&gt; hs; で定義したとすると，KEY型の key を使って VAL型の変数 hs[key] を使用できます．<br>現在 KEY は int, unsigned, ll, ull, pair&lt;int,int&gt; のみに対応．<br>hs[key] と書いた瞬間（書き込まなくても）hs[key]の要素が作られ，全体を初期化しない限り消せません．逆に一度作ってしまえば以降はずっと同じアドレスを指します（要素数が増えてもリハッシュしたりもしません）．<br>hs[key] の要素の初期値は不定です．<br></p>
<ul><li>void hs.init(int nn) : 最大nn要素ぐらいを使うとして初期化（中身を削除）します．（現在は配列サイズは 1.5 * nn 以上の最小の2の冪数ぐらいに設定しています）．nn要素以上使うと急激に遅くなったり無限ループになったりします．配列の初期化でなぞるのでO(nn)時間掛けます．</li>
<li>void hs.init(int nn, SVAL ini) : こっちで初期化すると，作られていない要素にアクセスした際に，勝手にiniで初期化されるようにします．</li>
<li>inline bool hs.exist(const KEY a) : hs[a] が既に作られていれば true，そうでなければ false を返します．</li>
<li>template&lt;class S&gt; inline bool exist(const KEY a, S &res) : hs[a] が既に作られていれば res に代入し true を返す．そうでなければ false を返します．</li>
</ul>
<p>使わないもの<br></p>
<ul><li>HashMap() : コンストラクタ</li>
<li>~HashMap() : デストラクタ．メモリ解放します．</li>
<li>void hs.expand(int nn) : 内部の配列のサイズがnn未満だったらnnに拡張します．</li>
<li>void hs.free() : メモリ解放します．</li>
<li>int hs.getHash(const T a) : ハッシュ関数の値を取得します．T = int, unsigned, ll, ull, pair&lt;int,int&gt; でそれぞれ定義されています．</li>
</ul>
<p>参考：<a href="http://rsujskf.s602.xrea.com/?yukicoder_1293">yukicoder No.1293 2種類の道路</a><br>参考：<a href="http://rsujskf.s602.xrea.com/?codeforces_684_div1_b">Codeforces Round #684 DIV1 B問題 - Graph Subset Problem</a><br></p>

<HR>


<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">ll</span> inversion_range<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> mn, <span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> mx, <span style="color:#0000FF;">void</span> *mem=wmem<span style="color:#662222;">)</span></span></span> : 要素数Nの配列A[]の転倒数を求めます．Fenwick Treeを使うやつ．配列A[]の要素の最小値はmn以上，最大値はmx以下でなければなりません．時間計算量は $O(N \log (mx-mn) + (mx-mn))$ 程度で，$mx-mn \approx N$ ならば以下のinversionより高速なはずです．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">ll</span> inversion<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem=wmem<span style="color:#662222;">)</span></span></span> : 要素数Nの配列A[]の転倒数を求めます．マージソートしながら数えるやつ．時間計算量は $O(N \log N)$ です．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">ll</span> inversion<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">vector</span>&lt;T&gt; &amp;A, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">ll</span> inversion<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">string</span> &amp;A, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">ll</span> inversion<span style="color:#662222;">(</span><span style="color:#4444FF;">const</span> <span style="color:#0000FF;">int</span> N, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#4444FF;">const</span> T B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem=wmem<span style="color:#662222;">)</span></span></span> : 要素数Nの配列A[]，B[]について，Aの隣接要素をswapさせてBに一致させるときの最小のswap数を返します．不可能なら-1を返します．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">int</span> d<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">4</span>, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">5</span>, <span style="color:#AA00AA;">9</span>, <span style="color:#AA00AA;">2</span>, <span style="color:#AA00AA;">6</span>, <span style="color:#AA00AA;">5</span>, <span style="color:#AA00AA;">4</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> inv<span style="color:#000000;">;</span>
    inv = inversion_range<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>, d, <span style="color:#AA00AA;">1</span>, <span style="color:#AA00AA;">9</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span>inv<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 14
</span>  <span style="color:#440000;font-weight:bold;">}</span>
  <span style="color:#440000;font-weight:bold;">{</span>
    <span style="color:#0000FF;">double</span> d<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1e3</span>, <span style="color:#AA00AA;">1e1</span>, <span style="color:#AA00AA;">1e4</span>, <span style="color:#AA00AA;">1e1</span>, <span style="color:#AA00AA;">1e5</span>, <span style="color:#AA00AA;">1e9</span>, <span style="color:#AA00AA;">1e2</span>, <span style="color:#AA00AA;">1e6</span>, <span style="color:#AA00AA;">1e5</span>, <span style="color:#AA00AA;">1e4</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> inv<span style="color:#000000;">;</span>
    inv = inversion<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span>, d<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    wt<span style="color:#662222;">(</span>inv<span style="color:#662222;">)</span><span style="color:#000000;">;</span> <span style="color:#888888;">// 14
</span>  <span style="color:#440000;font-weight:bold;">}</span>
</span></pre>
<HR>

<ul><li>template&lt;class T, class S&gt; void ZetaTransform(int N, T A[], S res[]) : 高速ゼータ変換します．resがNULLのときは結果を配列Aに上書きします．時間計算量は $O(N \log N)$．</li>
<li>template&lt;class T&gt; void ZetaTransform(int N, T A[]) : 高速ゼータ変換します．結果を配列Aに上書きします．</li>
<li>template&lt;class T, class S&gt; void MoebiusTransform(int N, T A[], S res[]) : 高速メビウス変換します．resがNULLのときは結果を配列Aに上書きします．時間計算量は $O(N \log N)$．型Sは型Tの値を表せる必要があります（結果がSに収まるからってのは駄目）．</li>
<li>template&lt;class T&gt; void MoebiusTransform(int N, T A[]) : 高速メビウス変換します．結果を配列Aに上書きします．</li>
</ul>
<p>非負整数 x, y を2進数で書いたとき，xの1の桁がyの1の桁に包含されているとき，xはyに含まれると呼ぶことにする．<br>ZetaTransform は res[i] は jがiに包含されている整数を動くとき A[j] の和が代入されます．<br>メビウス変換はゼータ変換の逆変換です．<br></p>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">6</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">5</span>,<span style="color:#AA00AA;">9</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">8</span><span style="color:#440000;font-weight:bold;">}</span>, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">6</span><span style="color:#441111;">]</span>, C<span style="color:#441111;">[</span><span style="color:#AA00AA;">6</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  ZetaTransform<span style="color:#662222;">(</span><span style="color:#AA00AA;">6</span>, A, B<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  MoebiusTransform<span style="color:#662222;">(</span><span style="color:#AA00AA;">6</span>, B, C<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">6</span><span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%d %d%d%d %02d %02d %02d\n&quot;</span>, i, <span style="color:#662222;">(</span>i&gt;&gt;<span style="color:#AA00AA;">2</span><span style="color:#662222;">)</span>%<span style="color:#AA00AA;">2</span>, <span style="color:#662222;">(</span>i&gt;&gt;<span style="color:#AA00AA;">1</span><span style="color:#662222;">)</span>%<span style="color:#AA00AA;">2</span>, i%<span style="color:#AA00AA;">2</span>, A<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>, B<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>, C<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">// 0 000 02 02 02
</span><span style="color:#888888;">// 1 001 05 07 05
</span><span style="color:#888888;">// 2 010 09 11 09
</span><span style="color:#888888;">// 3 011 04 20 04
</span><span style="color:#888888;">// 4 100 01 03 01
</span><span style="color:#888888;">// 5 101 08 16 08
</span></span></pre>
<p>res[i] は jがiに包含されている整数を動くとき A[j] の最小値 | 最大値を求めるのは以下の関数です．<br>小さい方から2個，3個求めるものもあります．この場合は，要素数が足りない場合は，numeric_limits&lt;S&gt;::max();が代入されます．<br></p>
<ul><li>template&lt;class T, class S&gt; void ZetaTransform_min(int N, T A[], S res[])</li>
<li>template&lt;class T&gt; void ZetaTransform_min(int N, T A[]) : 結果はAに上書き</li>
<li>template&lt;class T, class S&gt; void ZetaTransform_min(int N, T A[], S r1[], S r2[])</li>
<li>template&lt;class T, class S&gt; void ZetaTransform_min(int N, T A[], S r1[], S r2[], S r3[]) : r1に最小値，r2に小さい方から2番目，r3に小さい方から3番目が代入されます．</li>
<li>template&lt;class T, class S&gt; void ZetaTransform_max(int N, T A[], S res[])</li>
<li>template&lt;class T, class S&gt; void ZetaTransform_max(int N, T A[]) : 結果はAに上書き</li>
</ul>
<p>また，逆に，res[i] に i を包含する j についての A[j] の和<br>$\displaystyle res[i] = \sum_{j \in i} A[j]$<br>を求める高速ゼータ変換，その逆変換のメビウス変換は以下の通り．<br></p>
<ul><li>template&lt;class T, class S&gt; void ZetaTransform2(int N, T A[], S res[])</li>
<li>template&lt;class T&gt; void ZetaTransform2(int N, T A[])</li>
<li>template&lt;class T, class S&gt; void MoebiusTransform2(int N, T A[], S res[])</li>
<li>template&lt;class T&gt; void MoebiusTransform2(int N, T A[])</li>
</ul>

<HR>

<ul><li>int runLength(int N, T A[], T val[] = NULL, int len[] = NULL) : 長さNの配列Aをランレングス圧縮します．要素 val[i] が len[i] 個続くという感じに求めます．配列 val, len の要素数を返します．val, len が不要な場合は NULL を指定します（内部的にはval, len の引数の型は void * 型になっていてキャストせず NULL で通りますが，NULLでない場合に型が間違っていても通るので注意）．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> N = <span style="color:#AA00AA;">10</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">1</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 0が2個 - 1が3個 - 0が2個 - 3が1個 - 2が1個 - 1が1個
</span>  <span style="color:#0000FF;">int</span> e, val<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, len<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>

  e = runLength<span style="color:#662222;">(</span>N,A,val,len<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>e<span style="color:#662222;">)</span><span style="color:#000000;">;</span>                         <span style="color:#888888;">// 6 と表示されます
</span>  wt<span style="color:#662222;">(</span>val<span style="color:#662222;">(</span>e<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                    <span style="color:#888888;">// 0 1 0 3 2 1
</span>  wt<span style="color:#662222;">(</span>len<span style="color:#662222;">(</span>e<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                    <span style="color:#888888;">// 2 3 2 1 1 1
</span></span></pre>
<HR>

<ul><li>template&lt;class T&gt; T popFirst(multiset&lt;T&gt; &a), template&lt;class T&gt; T popFirst(set&lt;T&gt; &a) : aの最初の要素を削除し，その要素の値を返す</li>
<li>template&lt;class T&gt; T getFirst(multiset&lt;T&gt; &a), template&lt;class T&gt; T getFirst(set&lt;T&gt; &a) : aの最初の要素の値を返す</li>
<li>template&lt;class T&gt; T popLast(multiset&lt;T&gt; &a), template&lt;class T&gt; T popLast(set&lt;T&gt; &a) : aの最後の要素を削除し，その要素の値を返す</li>
<li>template&lt;class T&gt; T getLast(multiset&lt;T&gt; &a), template&lt;class T&gt; T getLast(set&lt;T&gt; &a) : aの最後の要素の値を返す</li>
<li>template&lt;class T, class S&gt; T getClosest(multiset&lt;T&gt; &a, S v), template&lt;class T&gt; T getClosest(set&lt;T&gt; &a, S v) : aの要素の内でvに一番近い要素を返す．前後に同じ距離の要素があるなら小さい方を返す．</li>
<li>template&lt;class T, class S&gt; T getClosestL(multiset&lt;T&gt; &a, S v), template&lt;class T&gt; T getClosestL(set&lt;T&gt; &a, S v) : aの要素の内でvに一番近い要素を返す．前後に同じ距離の要素があるなら大きい方を返す．</li>
<li>template&lt;class T, class S&gt; T getClosest(int N, T A[], S v) : 配列Aはソート済みとする．</li>
<li>template&lt;class T, class S&gt; T getClosestL(int N, T A[], S v)</li>
</ul>
<p>いずれの関数も，空のmultiset, setを引数に取ってはいけません．<br></p>

<HR>

<ul><li>template&lt;class T&gt; inline int isLeapYear(const T y) : y年がうるう年のときに1，そうじゃないときに0を返す．T = int, ll あたりを想定．</li>
<li>inline int numOfDaysInMonth(const int m) : うるう年じゃない年のm月の日数を返す</li>
<li>template&lt;class T&gt; inline int numOfDaysInMonth(const T y, const int m) : y年m月の日数を返す</li>
<li>template&lt;class T&gt; inline int dayOfWeek(T y, int m, int d) : 曜日を返す．0は月曜，1は火曜，…，6が日曜．ツェラーの公式を用いる．</li>
<li>inline const char* dayOfWeekStr(int w) : 0～6の曜日に対応する文字列を返す．0～6までは "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" に対応．</li>
<li>template&lt;class T&gt; inline const char* dayOfWeekStr(T y, int m, int d) : 曜日に対応する文字列を返す</li>
<li>template&lt;class T&gt; inline void prevDay(T &y, int &m, int &d) : y年m月d日の1日前の日付に y, m, d を変更する</li>
<li>template&lt;class T&gt; inline void nextDay(T &y, int &m, int &d) : y年m月d日の1日後の日付に y, m, d を変更する</li>
<li>inline ll dayIndex(ll y, int m, int d) : 1年1月1日を1日目として，y年m月d日が何日目かを返す</li>
<li>template&lt;class S, class T&gt; void dayFromIndex(S ind, T &y, int &m, int &d) : 1年1月1日を1日目として，ind 日目の日付 y 年 m 月 d 日を返す（y, m, d に代入する）</li>
</ul>
<p>基本的にグレゴリオ暦を仮定<br></p>

<HR>

<ul><li>inline int isVowel(const char c) : 母音のとき1，そうじゃないときに0を返す（母音はaiueoでyは含まない）</li>
</ul>

<HR>

<ul><li>template&lt;class T, class S&gt; int KMP(T A[], int As, T B[], int Bs, S res[], int *fail = (int*)wmem) : KMP法．AsはAの配列の長さ，BsはBの配列の長さ．Aの連続する部分列として何個Bがあるかを返す．res[i]=1はA[i]から始まる連続する部分文字列がBであるという意味（配列resの長さは配列Aの長さと同じ）．failは内部で利用するが，例えば，Bs-fail[Bs]は配列Bの周期になっているなどの利用価値がある．配列Bの周期がpであるとはB[i]=B[i-p]が全ての p &le; i &lt; Bs で成り立つこと（pはBsの約数でなくても良い）．</li>
<li>template&lt;class T&gt; int KMP(T A[], int As, T B[], int Bs, int res[] = NULL, int *fail = (int*)wmem) : resを省略するとき用．KMP(A,As,B,Bs) で呼び出し可能．</li>
<li>template&lt;class T1, class T2&gt; int isSubsequence(int As, const T1 A[], int Bs, const T2 B[]) : 配列Bが配列Aの部分列ならば1，そうでなければ0を返す．</li>
<li>int isSubsequence(string A, string B)</li>
<li>int isSubsequence_r(string &amp;A, string &amp;B)</li>
<li>int isSubstring(string A, string B, void *mem = wmem) : 文字列Bが文字列Aの部分文字列ならば1，そうでなければ0を返す．内部ではKMP法を利用．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> R, <span style="color:#0088FF;">class</span> T&gt; R cntSubsequence<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> As, <span style="color:#4444FF;">const</span> T A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> Bs, <span style="color:#4444FF;">const</span> T B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 部分列の数を数え上げる．配列AのからBs個の要素を選びそのままつなげるとBになるような要素の選び方のパターン数を返す．最悪O(As*Bs)時間ぐらい．より正確に，xに登場するkの数をnx(k)と書くと，Σはkに対する和として O((As+Bs) log (As+Bs) + ΣnA(k)*nB(k)) 時間．cntSubsequence&lt;Modint&gt;(n,a,m,b) のように呼び出す．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> R, <span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2&gt; R cntSubsequence<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> As, <span style="color:#4444FF;">const</span> T1 A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> Bs, <span style="color:#4444FF;">const</span> T2 B<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span></li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> R&gt; R cntSubsequence<span style="color:#662222;">(</span><span style="color:#0000FF;">string</span> A, <span style="color:#0000FF;">string</span> B, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span></li>
<li>template&lt;class T&gt; inline int isPalindrome(const int N, const T A[]) : 長さNの配列Aが回文（A[i]==A[N-1-i]）ならば1を，そうでないなら0を返す．</li>
<li>template&lt;class T&gt; int longestSuffixPrefix(int As, T A[], int Bs, T B[], void *mem = wmem) : KMP法で「配列Aのsuffix = 配列Bのprefix」となる最大の長さを返す．</li>
<li>string strReplace(string str, string bef, string aft, void *mem = wmem) : str に現れる部分文字列 bef を前から順番に aft に置き換えてできる文字列を返す．置き換え後の文字は bef にマッチしない．KMP法を使用．</li>
<li>string strReplace(string str, vector&lt;string&gt; bef, vector&lt;string&gt; aft, void *mem = wmem) : str に現れる部分文字列 bef[k] を前から順番に aft[k] に置き換えてできる文字列を返す．置き換え後の文字は bef にマッチしない．KMP法を使用．</li>
<li>template&lt;class T&gt; void smallestSubsequenceLengthK(int N, T A[], int K, T res[], void *mem = wmem) : 配列A[]の長さKの部分列で辞書順最小のものを求める．O(N) 時間．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">1</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> B<span style="color:#441111;">[</span><span style="color:#AA00AA;">4</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">1</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> res<span style="color:#441111;">[</span><span style="color:#AA00AA;">10</span><span style="color:#441111;">]</span>, cnt<span style="color:#000000;">;</span>

  cnt = KMP<span style="color:#662222;">(</span>A, <span style="color:#AA00AA;">10</span>, B, <span style="color:#AA00AA;">4</span>, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>cnt<span style="color:#662222;">)</span><span style="color:#000000;">;</span>      <span style="color:#888888;">// 3
</span>  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">(</span><span style="color:#AA00AA;">10</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 1 0 0 1 0 0 1 0 0 0
</span></span></pre>
<HR>

<ul><li>template&lt;class T&gt; void SuffixArray(T *s, int N, int K, int *SA, int *LCP = NULL, void *mem = wmem) : 配列sのSuffixArrayを求める．sの長さはNで，sの各要素は1以上K-1以下である必要がある．LCPも必要であれば求めることができる．末尾に0を付加して計算するため，配列s，SA，LCPはN+1要素以上メモリが確保されていないといけない．時間計算量は $O(N+K)$．Kが大きかったり，0以下の要素を含む場合などは先に座標圧縮を行う．</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">char</span> S<span style="color:#441111;">[</span><span style="color:#AA00AA;">12</span><span style="color:#441111;">]</span> = <span style="color:#00AA22;">&quot;abracadabra&quot;</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> SA<span style="color:#441111;">[</span><span style="color:#AA00AA;">12</span><span style="color:#441111;">]</span>, LCP<span style="color:#441111;">[</span><span style="color:#AA00AA;">12</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  SuffixArray<span style="color:#662222;">(</span>S, <span style="color:#AA00AA;">11</span>, <span style="color:#AA00AA;">128</span>, SA, LCP<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">12</span><span style="color:#662222;">)</span> <span style="color:#000000;font-weight:bold;">printf</span><span style="color:#662222;">(</span><span style="color:#00AA22;">&quot;%4d %4d %4d %s\n&quot;</span>, i, SA<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>, LCP<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>, S+SA<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  <span style="color:#888888;">/*
   0   11   -1
   1   10    0 a
   2    7    1 abra
   3    0    4 abracadabra
   4    3    1 acadabra
   5    5    1 adabra
   6    8    0 bra
   7    1    3 bracadabra
   8    4    0 cadabra
   9    6    0 dabra
  10    9    0 ra
  11    2    2 racadabra
  */</span>
</span></pre>
<HR>

<p>Arr1d 構造体．<br>累積和を計算しておけば連続する部分列の和を計算できたりするような，1回準備したら（配列の中身を変更しなければ）簡単に答えられるようなクエリに対応するための型です．<br>（計算状況リセットしてから）最初の1回のみ，連続部分列の和を取得しようとしたときに累積和を計算するような感じ．<br>以下は，Arr1d&lt;T&gt; a;を想定．<br></p>
<p>[特殊な話]<br>int n; Arr1d&lt;ll&gt; a;<br>rd(n, a(n));<br>と読み込むことができます．<br>rd(a(n));で読み込んだときには，読み込む直前に a.malloc(n); が走って勝手にメモリ確保と配列サイズが指定されます．<br>a[0], a[1], ..., a[n-1] で普通に要素にアクセスできます．<br></p>
<p>[コンストラクタ・メモリ関係・初期化など]<br></p>
<ul><li>Add1d() : コンストラクタ．変数の初期がぐらいしかしません．</li>
<li>Add1d(int nn) : コンストラクタ．長さnnの配列としてメモリ確保もします．</li>
<li>~Add1d() : デストラクタ．メモリの開放などをします．</li>
<li>void a.constructor(), void a.constructor(int nn) : コンストラクタと同じ内容を強制的に呼び出す．</li>
<li>void a.destructor(), void a.free() : デストラクタと同じ内容を強制的に呼び出す．</li>
<li>void a.reset() : リセット．全ての機能において前計算をしていない状況にします．配列の中身をいじったら呼び出すと良いです．</li>
<li>void a.malloc(int nn) : n個のデータの領域を確保し（すでにn以上のメモリを確保している場合は何もしません），配列長をnnに変更します．リセットされます．</li>
<li>void a.setN(int nn) : mallocと同じです．</li>
<li>void a.setN(int nn, T val) : setNした後に，配列の全要素をvalで初期化します．</li>
<li>template&lt;class S&gt; void a.set(vector&lt;S&gt; &amp;a) : それにします．メモリも自動で確保します．リセットされます．</li>
<li>template&lt;class S&gt; void a.set_c(vector&lt;S&gt; a) : それにします．メモリも自動で確保します．リセットされます．</li>
<li>template&lt;class S&gt; void a.set(int nn, S a[]) : それにします．メモリも自動で確保します．リセットされます．</li>
</ul>
<p>[累積和関係]<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2&gt; T a.getSum<span style="color:#662222;">(</span>T1 i, T2 j<span style="color:#662222;">)</span></span></span> : a[i]+a[i+1]+...+a[j] を返します．正確にはインデックスが max(i,0) から min(j,N-1) までの和を返します．i &gt; j の場合は 0 が返ります．前計算O(n)，各クエリO(1)．</li>
<li>void a.setSum() : 基本的に使わない．累積和を強制的に（再）計算します．</li>
</ul>
<p>[縦横に連続する数]<br></p>
<ul><li>int a.ConstLenLeft(int st, T val) : a[st]から左に向かってvalが何個連続しているかを返します．a[st] = a[st-1] = val, a[st-2] != val なら 2，a[st] != val なら 0を返します．stは0以上n未満である必要があります．前計算O(n)，各クエリO(1)．</li>
<li>int a.ConstLenLeft(int st) : ConstLenLeft(st, a[st]) と同じです．</li>
<li>int a.ConstLenLeftCyclic(int st, T val) : 配列aがサイクリック（a[-1] = a[n-1]）として ConstLenLeft(st, val) を返します．stは負やn以上でも mod n で扱われます．答えが無限になる場合は int_inf を返します．</li>
<li>int a.ConstLenLeftCyclic(int st)</li>
<li>int a.ConstLenRight(int st, T val) : a[st]から右に向かってvalが何個連続しているかを返します．</li>
<li>int a.ConstLenRight(int st)</li>
<li>int a.ConstLenRightCyclic(int st, T val)</li>
<li>int a.ConstLenRightCyclic(int st)</li>
<li>void a.setConstLenLeft() : 基本的に使わない．ConstLenLeft() 系の強制的に前計算をします．</li>
<li>void a.setConstLenRight() : 基本的に使わない．ConstLenRight() 系の強制的に前計算をします．</li>
</ul>
<p>[ヒストグラム（密な場合）]<br></p>
<ul><li>int a.dHist(T x) : 配列a[]の中にxが登場する回数を返す．前計算 O(max(a)-min(a))，各クエリ O(1)．</li>
<li>int a.dHist(T x, T y) : 配列a[]の中に x 以上 y 以下の値が登場する回数を返す．</li>
<li>void a.setDHist() : 基本的に使わない．</li>
</ul>
<p>[ヒストグラム（疎な場合）]<br></p>
<ul><li>int a.sHist(T x) : 配列a[]の中にxが登場する回数を返す．前計算 O(n log n)，各クエリ O(log n)．</li>
<li>int a.sHist(T x, T y) : 配列a[]の中に x 以上 y 以下の値が登場する回数を返す．</li>
<li>void a.setSHist() : 基本的に使わない．</li>
</ul>
<p>[左右の次の大小関係の要素を探す]<br></p>
<ul><li>int a.PrevLE(int i) : j &lt; i かつ a[j] &le; a[i] なる最大のjを返す．存在しなければ-1を返す．</li>
<li>int a.PrevLT(int i) : j &lt; i かつ a[j] &lt; a[i] なる最大のjを返す．存在しなければ-1を返す．</li>
<li>int a.PrevGE(int i) : j &lt; i かつ a[j] &ge; a[i] なる最大のjを返す．存在しなければ-1を返す．</li>
<li>int a.PrevGT(int i) : j &lt; i かつ a[j] &gt; a[i] なる最大のjを返す．存在しなければ-1を返す．</li>
<li>int a.NextLE(int i) : i &lt; j かつ a[j] &le; a[i] なる最小のjを返す．存在しなければnを返す．</li>
<li>int a.NextLT(int i) : i &lt; j かつ a[j] &lt; a[i] なる最小のjを返す．存在しなければnを返す．</li>
<li>int a.NextGE(int i) : i &lt; j かつ a[j] &ge; a[i] なる最小のjを返す．存在しなければnを返す．</li>
<li>int a.NextGT(int i) : i &lt; j かつ a[j] &gt; a[i] なる最小のjを返す．存在しなければnを返す．</li>
<li>void a.setPrevLE(void *mem = wmem) など : 基本的に使わない．</li>
</ul>
<p>[その他]<br></p>
<ul><li>void a.sort(void) : 配列をソートします．リセットされます．</li>
</ul>
<p>[基本的に使わない情報]<br></p>
<ul><li>int a.n : 配列長</li>
<li>int a.mem : 配列のメモリを確保している長さ</li>
<li>T *a.d : 生配列</li>
</ul>

<HR>

<p>Arr2d 構造体．<br>以下は，<span id="code"><span style="color:#444444"><span style="color:#0000FF;">Arr2d</span>&lt;T&gt; a<span style="color:#000000;">;</span></span></span> を想定．<br></p>
<p>[特殊な話]<br></p>

<pre><span style="color:#444444"><span style="color:#0000FF;">int</span> n1, n2<span style="color:#000000;">;</span> <span style="color:#0000FF;">Arr2d</span>&lt;<span style="color:#0000FF;">ll</span>&gt; a<span style="color:#000000;">;</span>
rd<span style="color:#662222;">(</span>n1, n2, a<span style="color:#662222;">(</span>n1,n2<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
</span></pre>
<p>と読み込むことができます．<br><span id="code"><span style="color:#444444">rd<span style="color:#662222;">(</span>a<span style="color:#662222;">(</span>n1,n2<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> で読み込んだときには，読み込む直前に <span id="code"><span style="color:#444444">a.<span style="color:#000000;font-weight:bold;">malloc</span><span style="color:#662222;">(</span>n1,n2<span style="color:#662222;">)</span><span style="color:#000000;">;</span></span></span> が走って勝手にメモリ確保と配列サイズが指定されます．<br>a[0][0], ..., a[n1-1][n2-1] で普通に要素にアクセスできます．<br></p>
<p>[コンストラクタ・メモリ関係・初期化など]<br></p>
<ul><li>Add2d() : コンストラクタ．変数の初期がぐらいしかしません．</li>
<li>Add2d(int nn1, int nn2) : コンストラクタ．</li>
<li>~Add2d() : デストラクタ．メモリの開放などをします．</li>
<li>void a.constructor(), void a.constructor(int nn1, int nn2) : コンストラクタと同じ内容を強制的に呼び出す．</li>
<li>void a.destructor(), void a.free() : デストラクタと同じ内容を強制的に呼び出す．</li>
<li>void a.reset() : リセット．全ての機能において前計算をしていない状況にします．配列の中身をいじったら呼び出すと良いです．</li>
<li>void a.malloc(int nn1, int nn2) : n個のデータの領域を確保し（すでにn以上のメモリを確保している場合は何もしません），配列長をnnに変更します．リセットされます．</li>
<li>void a.setN(int nn1, int nn2) : mallocと同じです．</li>
<li>void a.setN(int nn1, int nn2, T val) : setNした後に，配列の全要素をvalで初期化します．</li>
<li>template&lt;class S&gt; void a.set(vector&lt;vector&lt;S&gt;&gt; &amp; a) : それにします．メモリも自動で確保します．リセットされます．</li>
<li>template&lt;class S&gt; void a.set_c(vector&lt;vector&lt;S&gt;&gt; a) : それにします．メモリも自動で確保します．リセットされます．</li>
<li>template&lt;class S&gt; void a.set(int nn1, int nn2, S **a) : それにします．メモリも自動で確保します．リセットされます．</li>
</ul>
<p>[累積和]<br></p>
<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2, <span style="color:#0088FF;">class</span> T3, <span style="color:#0088FF;">class</span> T4&gt; T getSum<span style="color:#662222;">(</span>T1 r1, T2 c1, T3 r2, T4 c2<span style="color:#662222;">)</span></span></span> : 長方形領域の和を返す．厳密には g[i][j] (max(0, r1) &le; i &le; min(n1-1, r2) かつ max(0, c1) &le; j &le; min(n2-1, c2)) の和を返す．ただし，r1 &gt; r2 または c1 &gt; c2 の場合は 0 を返す．</li>
<li><span id="code"><span style="color:#444444">T a.getSumBorder<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> r1, <span style="color:#0000FF;">int</span> c1, <span style="color:#0000FF;">int</span> r2, <span style="color:#0000FF;">int</span> c2<span style="color:#662222;">)</span></span></span> : 長方形領域の周の要素の和を返す（インデックスが範囲外の場合うまく動かない）．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">void</span> a.setSum<span style="color:#662222;">(</span><span style="color:#662222;">)</span></span></span> : 基本的に使わない．</li>
</ul>
<p>[斜め累積和]<br></p>
<ul><li>T a.getSum45(int r1, int c1, int r2, int c2) : g[r1][c1], g[r2][c2] を対角になるような斜め45度傾いた長方形領域の要素の和を返す．はみ出る部分は0として扱う．<b>O((n1+n2)^2)の計算，メモリを使用するので，縦長・横長の場合には注意</b>．(r,c)→(c-r,c+r)に座標変換して処理する感じ．</li>
<li>T a.getSum45Border(int r1, int c1, int r2, int c2) : 上の長方形領域の周の要素の和を返す．</li>
<li>void a.setSum45() : 基本的に使わない．</li>
</ul>
<p>[縦横に連続する数]<br></p>
<ul><li>int a.ConstLenLeft(int i, int j, T val) : a[i][j]から左（a[i][j-1]方向）に向かってvalが何個連続しているかを返します．前計算O(n1*n2)，各クエリO(1)．</li>
<li>int a.ConstLenLeft(int i, int j) : ConstLenLeft(i, j, a[i][j]) と同じです．</li>
<li>int a.ConstLenRight(int i, int j, T val) : a[i][j]から右（a[i][j+1]方向）に向かってvalが何個連続しているかを返します．</li>
<li>int a.ConstLenRight(int i, int j)</li>
<li>int a.ConstLenUp(int i, int j, T val) : a[i][j]から上（a[i-1][j]方向）に向かってvalが何個連続しているかを返します．</li>
<li>int a.ConstLenUp(int i, int j)</li>
<li>int a.ConstLenDown(int i, int j, T val) : a[i][j]から下（a[i+1][j]方向）に向かってvalが何個連続しているかを返します．</li>
<li>int a.ConstLenDown(int i, int j)</li>
<li>void a.setConstLenLeft() : 基本的に使わない．ConstLenLeft() 系の強制的に前計算をします．</li>
<li>void a.setConstLenRight() : 基本的に使わない．</li>
<li>void a.setConstLenUp() : 基本的に使わない．</li>
<li>void a.setConstLenDown() : 基本的に使わない．</li>
</ul>
<p>[基本的に使わない情報]<br></p>
<ul><li>int a.n1, a.n2 : 配列長</li>
<li>int a.mem1, a.mem2 : 配列のメモリを確保している長さ</li>
<li>T **a.d : 生配列</li>
</ul>

<HR>

<p>Grid1d構造体．<br>Grid1d&lt;int&gt; g; などで定義し，g.malloc(n); でメモリを確保する．メモリ解放するときは g.free(); ．<br>すると，g[i]が使えるようになり，それぞれint型．<br>g[i] にデータを代入して，g.setSum()，g.setDir() 等で累積和などのテーブルを作成して，利用する．<br>データを変更した場合は，g.setSum() などを再度呼び出せば良い．<br>行の数，列の数を変更する場合は，現状，g.free()→g.malloc(n)とやり直すしかない．<br>以下は，Grid1d&lt;T&gt; g;を想定．<br></p>
<ul><li>void g.malloc(const int n) : n固のデータ領域を確保（g[0]からg[n-1]まで使える）</li>
<li>void g.free(void) : メモリ解放（以下の機能で確保したメモリも全て解放）</li>
</ul>
<p>累積和関係<br></p>
<ul><li>void g.setSum(void) : 累積和のテーブルを作成（以下の機能を使う前に呼び出す）</li>
<li>inline T g.getSum(const int a, const int b) : g[i] (a &le; i &le; b) の和を返す．ただし，a &gt; b の場合は正しく動かない</li>
<li>T *g.d_s : g.d_s[i] には g.d[0]+...+g.d[i-1] が入っている．</li>
</ul>
<p>縦横に連続する数<br></p>
<ul><li>void g.setDir(void) : 以下の up, dw, lf, rg をセットする．g[i]と同じ値が左右に何個続くかを求める</li>
<li>void g.setDirMatch(const T v) : 以下の up, dw, lf, rg をセットする．g[i]がvとなるようなセルが上下左右に何個続くかを求める</li>
<li>int *lf : lf[i] は g[i], g[i-1], ..., g[i-k+1] が全て条件を満たすような最大のkが入っている（自分のマスから左方向に連続して何マスが条件を満たすか）</li>
<li>int *rg : rg[i] は g[i], g[i+1], ..., g[i+k-1] が全て条件を満たすような最大のkが入っている（自分のマスから右方向に連続して何マスが条件を満たすか）</li>
<li>int *up : rgと同じ．</li>
<li>int *dw : lfと同じ．</li>
</ul>

<HR>

<p>Grid2d構造体．<br>Grid2d&lt;int&gt; g; などで定義し，g.malloc(r,c); でメモリを確保する．メモリ解放するときは g.free(); ．<br>すると，g[i][j]が使えるようになり，それぞれint型．<br>g[i][j] にデータを代入して，g.setSum()，g.setDir() 等で累積和などのテーブルを作成して，利用する．<br>データを変更した場合は，g.setSum() などを再度呼び出せば良い．<br>行の数，列の数を変更する場合は，現状，g.free()→g.malloc(r,c)とやり直すしかない．<br>以下は，Grid2d&lt;T&gt; g;を想定．<br></p>
<ul><li>void g.malloc(const int r, const int c) : r行c列のデータ領域を確保（g[0][0]からg[r-1][c-1]まで使える）</li>
<li>void g.free(void) : メモリ解放（以下の機能で確保したメモリも全て解放）</li>
</ul>
<p>累積和関係<br></p>
<ul><li>void g.setSum(void) : 累積和のテーブルを作成（以下の機能を使う前に呼び出す）</li>
<li>inline T g.getSum(const int r1, const int c1, const int r2, const int c2) : g[i][j] (r1 &le; i &le; r2, c1 &le; j &le; c2) の和を返す．ただし，r1 &gt; r2 または c1 &gt; c2 の場合は正しく動かない</li>
<li>T **g.d_s : g.d_s[i][j] には g.d[0][0]+...+g.d[i-1][j-1] が入っている．</li>
</ul>
<p>縦横に連続する数<br></p>
<ul><li>void g.setDir(void) : 以下の up, dw, lf, rg をセットする．g[i][j]と同じ値が上下左右に何個続くかを求める</li>
<li>void g.setDirMatch(const T v) : 以下の up, dw, lf, rg をセットする．g[i][j]がvとなるようなセルが上下左右に何個続くかを求める</li>
<li>int **up : up[i][j] は g[i][j], g[i-1][j], ..., g[i-k+1][j] が全て条件を満たすような最大のkが入っている（自分のマスから上方向に連続して何マスが条件を満たすか）</li>
<li>int **dw : dw[i][j] は g[i][j], g[i+1][j], ..., g[i+k-1][j] が全て条件を満たすような最大のkが入っている（自分のマスから下方向に連続して何マスが条件を満たすか）</li>
<li>int **lf : lf[i][j] は g[i][j], g[i][j-1], ..., g[i][j-k+1] が全て条件を満たすような最大のkが入っている（自分のマスから左方向に連続して何マスが条件を満たすか）</li>
<li>int **rg : rg[i][j] は g[i][j], g[i][j+1], ..., g[i][j+k-1] が全て条件を満たすような最大のkが入っている（自分のマスから右方向に連続して何マスが条件を満たすか）</li>
</ul>
<p>その他<br></p>
<ul><li>template&lt;class S&gt; inline void g.getDist4(int sr, int sc, S **res, void *mem = wmem) : 上下左右の4方向に進めるとして，(sr,sc) から各マス (i,j) への最短移動コストを res[i][j] に代入する．ただし，コストは始点終点を含む全ての通ったマスの g[i][j] の和で，g[i][j] の値が負なら通行不能とする．res[i][j]が負なら辿り着けない．</li>
<li>template&lt;class S&gt; inline void g.getDist4_BFS(int sr, int sc, S **res, void *mem = wmem) : getDist4()とほぼ同様だが g[i][j] の値がマイナスなら通行不可，そうでなければ全てコスト1とする（通るマスの数の最小化）．</li>
</ul>

<HR>


<p>FFTを用いて畳み込みを行います．<br>誤差がそれなりにのるので使用する際には注意．<br></p>
<ul><li>void convolution(double A[], int As, double B[], int Bs, double res[], int Rs, void *mem = wmem) : res[k] = A[0]*B[k] + A[1]*B[k-1] + ... + A[k]*B[0] を k = 0, 1, ..., Rs-1 まで計算します．AsとBsは配列A, Bの長さです．</li>
<li>void convolution(double A[], int As, double res[], int Rs, void *mem = wmem) : res[k] = A[0]*A[k] + A[1]*A[k-1] + ... + A[k]*A[0] を k = 0, 1, ..., Rs-1 まで計算します．Asは配列Aの長さです．</li>
</ul>
<p>FFTを用いて畳み込みを行います．<br>mod の値は 2冪+1 でなければならないなどの条件が存在します．<br>root には mod の原始根のうちの1つを指定してください．defineしたMDが素数の場合，その原始根は MD_PRIMITIVE_ROOT で勝手にdefineされます．<br></p>
<ul><li>void convolution(mint A[], int As, mint B[], int Bs, mint res[], int Rs, mint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
<li>void convolution(mint A[], int As, mint res[], int Rs, mint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
<li>void convolution(Mint A[], int As, Mint B[], int Bs, Mint res[], int Rs, Mint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
<li>void convolution(Mint A[], int As, Mint res[], int Rs, Mint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
<li>void convolution(modint A[], int As, modint B[], int Bs, modint res[], int Rs, modint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
<li>void convolution(modint A[], int As, modint res[], int Rs, modint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
<li>void convolution(Modint A[], int As, Modint B[], int Bs, Modint res[], int Rs, Modint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
<li>void convolution(Modint A[], int As, Modint res[], int Rs, Modint root = MD_PRIMITYVE_ROOT, void *mem = wmem)</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">double</span> a<span style="color:#441111;">[</span><span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span><span style="color:#440000;font-weight:bold;">}</span>, b<span style="color:#441111;">[</span><span style="color:#AA00AA;">3</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span><span style="color:#440000;font-weight:bold;">}</span>, c<span style="color:#441111;">[</span><span style="color:#AA00AA;">6</span><span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  convolution<span style="color:#662222;">(</span>a, <span style="color:#AA00AA;">3</span>, b, <span style="color:#AA00AA;">3</span>, c, <span style="color:#AA00AA;">6</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>c<span style="color:#662222;">(</span><span style="color:#AA00AA;">6</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 0.999999999999999 3.999999999999999 10.000000000000000 12.000000000000000 9.000000000000000 0.000000000000001
</span>  convolution<span style="color:#662222;">(</span>a, <span style="color:#AA00AA;">3</span>, c, <span style="color:#AA00AA;">6</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>c<span style="color:#662222;">(</span><span style="color:#AA00AA;">6</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 0.999999999999999 3.999999999999999 10.000000000000000 12.000000000000000 9.000000000000000 0.000000000000001
</span></span></pre>
<p>FFT単体を行う関数は以下の通りです（上手く使いまわしてFFTの回数を減らす場合はこちら）．配列の長さは2の冪でなければいけません．<br>fft_pnt構造体は struct fft_pnt{ double x, y; } で x + yi という複素数を表すもので +-* の3種の演算子が定義されています．<br>FFT，逆変換ともに定数倍を考慮していません．<strong>配列の長さ n</strong>でFFTして畳み込みを計算する場合は，FFTして，要素ごとに掛け算して，逆変換した後，<strong>各要素を 1/n 倍する必要があります</strong>．<br></p>
<ul><li>void fft(int n, fft_pnt x[], void *mem = wmem)</li>
<li>void fftinv(int n, fft_pnt x[], void *mem = wmem)</li>
<li>void fft(int n, mint x[], mint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
<li>void fftinv(int n, mint x[], mint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
<li>void fft(int n, Mint x[], Mint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
<li>void fftinv(int n, Mint x[], Mint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
<li>void fft(int n, modint x[], modint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
<li>void fftinv(int n, modint x[], modint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
<li>void fft(int n, Modint x[], Modint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
<li>void fftinv(int n, Modint x[], Modint root = MD_PRIMITIVE_ROOT, void *mem = wmem)</li>
</ul>
<p>参考：<a href="http://rsujskf.s602.xrea.com/?tlx_toki_17_h">TOKI Regular Open Contest #17 H問目 - Guitar Gift</a><br></p>

<HR>

<p>高速Walsh-Hadamrd変換を用いたxor convomution（xor畳み込み）．<br>$\displaystyle R[k] = \sum_{k = i \oplus j} A[i] B[j]$<br>となる配列を求めます（$\oplus$ はbitwise xor）．<br>配列の型は現在 Modint, modint, Mint, mint, double ぐらいのみを想定．<br></p>
<ul><li>template&lt;class T1, class T2, class T3&gt; void xorConvolution(int As, T1 A[], int Bs, T2 B[], int Rs, T3 R[], void *mem = wmem)</li>
</ul>
<p>高速Walsh-Hadamrd変換自体は以下の通り．<br><strong>配列のサイズは2の冪である必要があります．xor畳み込みをする場合，自力で最後に各要素を配列サイズnで割る必要があります．</strong><br>配列は上書きします．<br></p>
<ul><li>template&lt;class T&gt; void HadamardTransform(int N, T A[])</li>
</ul>

<HR>

<p>高速ゼータ変換を用いたand convolution（and畳み込み）とor convolution（or畳み込み）．<br>$\displaystyle R[k] = \sum_{k = i\ \mathrm{and}\ j} A[i] B[j]$<br>$\displaystyle R[k] = \sum_{k = i\ \mathrm{or}\ j} A[i] B[j]$<br>となる配列を求めます．<br>配列の型は現在 Modint, modint, Mint, mint, double ぐらいのみを想定．<br></p>
<ul><li>template&lt;class T1, class T2, class T3&gt; void andConvolution(int As, T1 A[], int Bs, T2 B[], int Rs, T3 R[], void *mem = wmem)</li>
<li>template&lt;class T1, class T2, class T3&gt; void orConvolution(int As, T1 A[], int Bs, T2 B[], int Rs, T3 R[], void *mem = wmem)</li>
</ul>
<p>and convolutionの方は，ZetaTransform2()を行い，要素ごとにかけた後，MoebiusTransform2()を行えば得られますが，要素数が2の冪でないときに注意．<br>or convolutionの方は，ZetaTransform()を行い，要素ごとにかけた後，MoebiusTransform()を行えば得られますが，要素数が2の冪でないときに注意．<br></p>

<HR>


<p>グラフの隣接リスト（隣接配列？）のようなものを作ります．<br>時間ごとにイベントを処理する場合などの整理などにも多分便利．<br></p>
<ul><li>template&lt;class S&gt; void wAdjEdge(const int N, const int M, const int *A, const S *B, int **res_sz, S ***res_B, void **mem = &wmem)</li>
<li>template&lt;class S, class T&gt; void wAdjEdge(const int N, const int M, const int *A, const S *B, const T *C, int **res_sz, S ***res_B, T ***res_C, void **mem = &wmem)</li>
<li>template&lt;class S, class T, class U&gt; void wAdjEdge(const int N, const int M, const int *A, const S *B, const T *C, const U *D, int **res_sz, S ***res_B, T ***res_C, U ***res_D, void **mem = &wmem)</li>
<li>template&lt;class S, class T, class U, class V&gt; void wAdjEdge(const int N, const int M, int *A, const S *B, const T *C, const U *D, const V *E, int **res_sz, S ***res_B, T ***res_C, U ***res_D, V ***res_E, void **mem = &wmem)</li>
</ul>

<pre><span style="color:#444444">    <span style="color:#0000FF;">int</span> A<span style="color:#441111;">[</span><span style="color:#AA00AA;">5</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">1</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">0</span><span style="color:#440000;font-weight:bold;">}</span>, B<span style="color:#441111;">[</span><span style="color:#AA00AA;">5</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">10</span>,<span style="color:#AA00AA;">30</span>,<span style="color:#AA00AA;">30</span>,<span style="color:#AA00AA;">30</span>,<span style="color:#AA00AA;">50</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
    <span style="color:#0000FF;">int</span> *es, **edge<span style="color:#000000;">;</span>
    wAdjEdge<span style="color:#662222;">(</span><span style="color:#AA00AA;">4</span>, <span style="color:#AA00AA;">5</span>, A, B, &amp;es, &amp;edge<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
    <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,<span style="color:#AA00AA;">4</span><span style="color:#662222;">)</span> wt<span style="color:#662222;">(</span>i, <span style="color:#00AA22;">':'</span>, es<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span>, <span style="color:#00AA22;">':'</span>, edge<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">(</span>es<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
<span style="color:#888888;">//  0 : 1 : 50
</span><span style="color:#888888;">//  1 : 2 : 10 30
</span><span style="color:#888888;">//  2 : 0 :
</span><span style="color:#888888;">//  3 : 2 : 30 30
</span></span></pre>
<HR>

<p>ハンガリアン法．n &le; m と仮定．<br>mat[0][c[0]] + mat[1][c[1]] + ... + mat[n-1][c[n-1]] の最小値を求める．ただし，c[i]は互いに異なる（c[i]は0以上m未満）．<br>それを達成する配列cはmatch[]に代入して返す．matchにNULLにしておくと最小値だけ返す．<br></p>
<ul><li>template&lt;class T&gt; T Hungarian(T **mat, int n, int m, int match[] = NULL, void *mem = wmem)</li>
</ul>

<HR>

<p>多項式補間（ラグランジュ補間）．<br>f(x[i]) = y[i] （i=0,1,...,n-1）となる n-1 次以下の多項式 f を考える．<br></p>
<ul><li>template&lt;class T&gt; T polationVal(int n, T x[], T y[], T t) : f(t) の値を返す．$O(n^2)$ 時間ぐらい．</li>
<li>template&lt;class T&gt; T polationVal(int n, T y[], T t, void *mem = wmem) : f(t) の値を返す．ただし x[i] = i とする．（T型の演算が $O(1)$ だと思って）$O(n)$ 時間ぐらい．</li>
<li>template&lt;class T&gt; Polynomial&lt;T&gt; polationPoly(int n, T x[], T y[]) : fを返す．$O(n^2)$ 時間ぐらい．</li>
</ul>

<HR>

<ul><li>vector&lt;string&gt; Explode(const string &amp;str, const string &amp;d) : str を d で区切って返します</li>
<li>string Implode(const vector&lt;string&gt; &amp;v, const string &amp;d) : v を d で連結します</li>
</ul>
<p>効率的な実装にはなっていない（遅い）です．<br>Explode("hoge,piyo,,123,", ",") は {"hoge", "piyo", "", "123", ""} を返します．<br>Explode("hoge,,,piyo,,123,", ",,") は {"hoge", ",piyo", "123,"} を返します．<br>v = {"hoge", "piyo", "", "123", ""} のとき Implode(v, "-") は "hoge-piyo--123-" を返します．<br></p>

<HR>

<ul><li>template&lt;class S&gt; S InnerProd(int n, S a[]) : a[0] + a[1] + ... + a[n-1] を返す．</li>
<li>template&lt;class S, class T&gt; S InnerProd(int n, S a[], T b[]) : a[0]*b[0] + a[1]*b[1] + ... + a[n-1]*b[n-1] を返す．標準的な内積．</li>
<li>template&lt;class S, class T, class U&gt; S InnerProd(int n, S a[], T b[], U c[]) : a[0]*b[0]*c[0] + ... + a[n-1]*b[n-1]*c[n-1] を返す．</li>
<li>template&lt;class S, class T, class U, class V&gt; S InnerProd(int n, S a[], T b[], U c[], V d[]) : a[0]*b[0]*c[0]*d[0] + ... + a[n-1]*b[n-1]*c[n-1]*d[n-1] を返す．</li>
<li>ll crossProd(ll x1, ll y1, ll x2, ll y2) : x1 * y2 - x2 * y1 を返す．平行四辺形の符号付き面積．外積（クロス積）の符号付き長さ．</li>
<li>int LineIntersection_size(ll x1, ll y1, ll x2, ll y2, ll x3, ll y3, ll x4, ll y4, int p1 = 1, int p2 = 1, int p3 = 1, int p4 = 1) : (x1,y1), (x2,y2) を通る 線1 と (x3,y3), (x4,y4) を通る 線2 が交わるかどうかを返す．交わらないならば0，交わるならば1，無限個の共有点を持つなら2を返す．<strong>現状，半直線の場合は未対応（今は例えばp1=2ならp2=2でなければならない）．(x1,y1) = (x2,y2) の場合なども未対応．</strong>pk = 0 ならば (xk, yk) は端点を含まない，pk = 1 ならば (xk, yk) は端点を含む，pk = 2 ならば線は (xk, yk) 方向には無限に伸びていることを意味する．例えば p1 = p2 = 2 ならば 線1 は両無限に続く直線． p1 = p2 = 1 ならば 線1 は端点を含む線分．きちんとverifyしてない．かなり怪しい．</li>
</ul>

<HR>

<p>二次元幾何．まだだいぶ怪しいです（作りかけだと思ったほうが良い）．<br><span id="code"><span style="color:#444444">Point2d&lt;T,S,F&gt; p<span style="color:#000000;">;</span></span></span> で定義したとします．<br>Tは座標の型，Sは座標の二乗以上のオーダーになる場合の型，Fは整数計算で収まらない場合の型です．<br>標準的には，できるだけ整数で計算する場合は Point2d&lt;int,ll,double&gt; p; で，そうじゃない場合は Point2d&lt;double,double,double&gt; p; で．<br></p>
<p>これ以内の差ならば同じとみなす（場合がある）定数を型ごとに指定できます．<br>（現状の）標準では，double型，long double型は1e-10，float型は1e-4になっています．<br>{Point2dEPS&lt;double&gt; tmp; tmp.set(1e-13);} で 1e-13 になります．<br></p>
<p>rd(), wt() に対応（単にx,yを並べて出力）してると思います．<br>s = sum(a(n)) は未対応です．s = sum[i,0,n](a[i]); はできます．<br></p>
<p>コンストラクタ系<br></p>
<ul><li>Point2d() : 点(0,0)</li>
<li>Point2d(T a) : 点(a,0)</li>
<li>Point2d(T a, T b) : 点(a,b)</li>
<li>void p.set(T a, T b) : 点(a,b)にセットします</li>
</ul>
<p>オペレータ（メンバ関数）<br></p>
<ul><li>Point2d&lt;T,S,F&gt; &amp;operator+=(Point2d&lt;T,S,F&gt; a)</li>
<li>Point2d&lt;T,S,F&gt; &amp;operator-=(Point2d&lt;T,S,F&gt; a)</li>
<li>Point2d&lt;T,S,F&gt; operator+(Point2d&lt;T,S,F&gt; a)</li>
<li>Point2d&lt;T,S,F&gt; operator-(Point2d&lt;T,S,F&gt; a)</li>
</ul>
<p>オペレータ（その他）<br></p>
<ul><li>template&lt;class T, class S, class F&gt; inline Point2d&lt;T,S,F&gt; operator*(T a, Point2d&lt;T,S,F&gt; b)</li>
</ul>
<p>メンバ関数<br></p>
<ul><li>inline F p.dist(void) : 原点から点pまでの（ユークリッド）距離を返す</li>
<li>inline F p.dist(Point2d&lt;T,S,F&gt; a) : 点aからpまでの（ユークリッド）距離を返す</li>
<li>inline S p.dist2(void) : 原点から点pまでの距離の2乗を返す</li>
<li>inline S p.dist2(Point2d&lt;T,S,F&gt; a) : 点aからpまでの距離の2乗を返す</li>
<li>inline F p.arg(void) : 偏角（だいたいatan2(y,x)）を返す．(-pi, pi] で返すはず．原点の場合は0を返すはず．</li>
<li>inline F p.arg(Point2d&lt;T,S,F&gt; a) : 偏角のaから差分を返す．大体 p.arg() - a.arg() mod 2*pi を (-pi, pi] で返す．</li>
</ul>
<p>その他関連関数<br></p>
<ul><li>template&lt;class T, class S, class F&gt; S InnerProd(Point2d&lt;T,S,F&gt; a, Point2d&lt;T,S,F&gt; b) : 内積を返す</li>
<li>template&lt;class T, class S, class F&gt; S CrossProd(Point2d&lt;T,S,F&gt; a, Point2d&lt;T,S,F&gt; b) : 三角形の符号付き面積の2倍を返す</li>
<li>template&lt;class T, class S, class F&gt; S CrossProd(Point2d&lt;T,S,F&gt; c, Point2d&lt;T,S,F&gt; a, Point2d&lt;T,S,F&gt; b) : 三角形の符号付き面積の2倍を返す</li>
<li>template&lt;class T, class S, class F&gt; void xysortA(int N, Point2d&lt;T,S,F&gt; A[]) : 要素数Nの配列Aをソートする．ソートの順番はx座標の小さい順．x座標が同じ点はy座標が小さいものが先にくる．</li>
<li>template&lt;class T, class S, class F, class D&gt; void xysortA(int N, Point2d&lt;T,S,F&gt; A[], D ind[], void *mem = wmem) : (A[i], ind[i]) のペアを xysortA の基準でソートする．</li>
<li>template&lt;class T, class S, class F&gt; void argsortA(int N, Point2d&lt;T,S,F&gt; A[], void *mem = wmem) : 偏角順にソートする．大体atan2(y,x)が小さい順になる．</li>
<li>template&lt;class T, class S, class F, class D&gt; void argsortA(int N, Point2d&lt;T,S,F&gt; A[], D ind[], void *mem = wmem) : (A[i], ind[i]) のペアを argsortA の基準でソートする．</li>
<li>template&lt;class T, class S, class F&gt; int CCW(Point2d&lt;T,S,F&gt; a, Point2d&lt;T,S,F&gt; b, Point2d&lt;T,S,F&gt; c) : 点の進行方向を調べる．a → b の線分に対して，cが反時計回りの方向にある場合1 [三角形の符号付き面積の符号]，a → b の線分に対して，cが時計回りの方向にある場合-1 [三角形の符号付き面積の符号]，c, a, b の順番で一直線上にある場合2，a, b, c の順番で一直線上にある場合-2，a, c, b の順番で一直線上にある場合0を返す．</li>
<li>template&lt;class T, class S, class F&gt; int CCW(Point2d&lt;T,S,F&gt; b, Point2d&lt;T,S,F&gt; c) : CCW(a,b,c) で a が原点の場合．</li>
<li>template&lt;class T, class S, class F&gt; int ConvexHull(int N, Point2d&lt;T,S,F&gt; A[], Point2d&lt;T,S,F&gt; res[], void *mem = wmem) : 凸包を返す．戻り値は凸包に含まれる点の数．res[0],res[1],...,res[s]の順番に反時計回りに凸包の頂点が代入される．ただしres[0]=res[s]．<strong>結果に関わらず配列resは要素数N+1以上のサイズにすること</strong>．凸包の頂点数は最小にする．つまり，一直線上に並ぶ点の端以外は答えに含めない．</li>
<li>template&lt;class T, class S, class F&gt; int ConvexHull_sorted(int N, Point2d&lt;T,S,F&gt; A[], Point2d&lt;T,S,F&gt; res[]) : xysort済みの場合はこちら．</li>
<li>template&lt;class T, class S, class F&gt; S PolygonArea2(int N, Point2d<T,S,F> A[]) : 自己交差のない多角形の面積の2倍を求める．時計回りの場合は面積は負となる．</li>
</ul>

<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> S, <span style="color:#0088FF;">class</span> T&gt; <span style="color:#4444FF;">inline</span> T RoundUp<span style="color:#662222;">(</span>T a, S b<span style="color:#662222;">)</span></span></span> : a以上の最小のbの倍数を返す．a, bは整数．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> S, <span style="color:#0088FF;">class</span> T&gt; <span style="color:#4444FF;">inline</span> T RoundDown<span style="color:#662222;">(</span>T a, S b<span style="color:#662222;">)</span></span></span> : a以下の最大のbの倍数を返す．a, bは整数．</li>
</ul>

<HR>

<ul><li>template&lt;class T&gt; T TSP_cycle(int n, T **dist, void *mem = wmem) : ノード数nのグラフで全ての頂点をちょうど1回ずつ通る閉路の最短路を求めます．ただし，ノードiからノードjに移動する距離はdist[i][j]です．時間O(n^2 2^n)，空間O(n 2^n) のDP．<a href="http://rsujskf.s602.xrea.com/?atcoder_beginner_contest_180_e">AtCoder Beginner Contest 180 E問題 - Traveling Salesman among Aerial Cities</a> も参考に．</li>
<li>template&lt;class T&gt; T TSP_path(int n, T **dist, void *mem = wmem) : どこから出発してどこで終わっても良い場合のTSP．参考：<a href="http://rsujskf.s602.xrea.com/?atcoder_beginner_contest_190_e">AtCoder Beginner Contest 190 E問題 - Magical Ornament</a>．</li>
<li>template&lt;class T&gt; T TSP_path_s(int n, T **dist, int s = 0, void *mem = wmem) : sから出発してどこで終わっても良い場合のTSP．参考：<a href="http://rsujskf.s602.xrea.com/?atcoder_past202005-open_m">第三回 アルゴリズム実技検定 M問題 - 行商計画問題</a>．</li>
<li>int graph_minColor(int N, int **mat, void *mem = wmem) : 無向グラフに対して彩色数（chromatic number，隣り合うノードは違う色に塗るとして最小色数）を返す．O(N 2^N) 時間ぐらい．メモリ結構（O(log N N^2)ぐらい？）使うかも．mat[i][i]は見ない，mat[i][j]=mat[j][i]でなければならない．適当なmodで計算して0かどうか判定するので間違える可能性あり．参考：<a href="http://rsujskf.s602.xrea.com/?atcoder_beginner_contest_187_f">AtCoder Beginner Contest 187 F問題 - Close Group</a>．</li>
<li>template&lt;class T&gt; inline T knightDistance(T x, T y) : 無限に広いチェス盤で (0,0) から (x,y) にナイトの駒が移動するのに必要な最小移動回数を返します．</li>
<li>ll floor_sum(ll n, ll m, ll a, ll b) : $\displaystyle \sum_{k=0}^{n-1} \left\lfloor \frac{ak+b}{m} \right\rfloor$ を返します．AtCoder Libraryの関数をほぼ同じですが，mが0でなければ a, b, m が負などでも動きます．ただし，m が小さい，n, a, b が大きいとオーバーフローするので注意．O(log m) 時間程度．</li>
<li>ll floor_sum2(ll a, ll k) : $\displaystyle \sum_{i=1}^{k} \left\lfloor \frac{a}{i} \right\rfloor$ を返します．O(min(sqrt(a), k)) 時間程度．</li>
<li>ll floor_sum2(ll a) : $\displaystyle \sum_{i=1}^{a} \left\lfloor \frac{a}{i} \right\rfloor = \sum_{i=1}^{\infty} \left\lfloor \frac{a}{i} \right\rfloor$ を返します．O(sqrt(a)) 時間程度．</li>
<li>int xorMin(int X, int N, int A[], int bt = 31) : Aはソート済みを仮定します．min(X^A[0], X^A[1], ..., X^A[N-1]) を返します．X, A[i] は 2^bt 未満です．O(bt log N) 時間ぐらい．</li>
<li>ll xorMin(ll X, int N, ll A[], int bt = 63)</li>
<li>int xorMax(int X, int N, int A[], int bt = 31)</li>
<li>ll xorMax(ll X, int N, ll A[], int bt = 63)</li>
<li>int isValidBracket1(int N, char S[]) : Sが (, ) のみからなる文字列で括弧の対応関係が取れている場合に1，その他の場合に0を返します</li>
<li>int isValidBracket2(int N, char S[], void *mem = wmem) : Sが (, ), [, ], {, }, &lt;, &gt; のみからなる文字列で括弧の対応関係が取れている場合に1，その他の場合に0を返します</li>
</ul>

<HR>

<p>配列の部分集合の和．<br>全て O(2^n) 時間ぐらい．ソートする場合は列挙しながらマージソートします．<br>重複を取り除く場合などで答えが少ないなら O(n*答えの数) 時間ぐらいになります．ただし，その場合はビットセットを利用したDPなどのほうが高速になる場合が多いです．<br></p>
<ul><li>template&lt;class T, class S&gt; int subsetSum(int n, T a[], S res[]) : 長さnの配列a[]の各部分集合の和を求めてresに格納する．res[mask] は mask の下からiビット目が1ならばa[i]を含んでいる．戻り値は配列resの要素数 = 2^n．</li>
<li>template&lt;class T, class S&gt; int subsetSumS(int n, T a[], S res[], void *mem = wmem) : 結果をソートして返します</li>
<li>template&lt;class T, class S, class U&gt; int subsetSumS(int n, T a[], S res[], U lim, void *mem = wmem) : a[]の値は非負のみと仮定して，答えがlim以下になるもののみ列挙します</li>
<li>template&lt;class T, class S&gt; int subsetSumSD(int n, T a[], S res[], void *mem = wmem) : 結果をソートして重複要素を削除して返します</li>
<li>template&lt;class T, class S, class U&gt; int subsetSumSD(int n, T a[], S res[], U lim, void *mem = wmem)</li>
</ul>

<pre><span style="color:#444444">  <span style="color:#0000FF;">int</span> n = <span style="color:#AA00AA;">4</span>, a<span style="color:#441111;">[</span><span style="color:#AA00AA;">4</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#AA00AA;">3</span>,<span style="color:#AA00AA;">0</span>,<span style="color:#AA00AA;">4</span>,<span style="color:#AA00AA;">3</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>
  <span style="color:#0000FF;">int</span> sz, res<span style="color:#441111;">[</span><span style="color:#AA00AA;">16</span><span style="color:#441111;">]</span> = <span style="color:#440000;font-weight:bold;">{</span><span style="color:#440000;font-weight:bold;">}</span><span style="color:#000000;">;</span>

  <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>mask,<span style="color:#AA00AA;">1</span>&lt;&lt;n<span style="color:#662222;">)</span> <span style="color:#0088FF;">rep</span><span style="color:#662222;">(</span>i,n<span style="color:#662222;">)</span> <span style="color:#0088FF;">if</span><span style="color:#662222;">(</span>mask&amp;<span style="color:#AA00AA;">1</span>&lt;&lt;i<span style="color:#662222;">)</span> res<span style="color:#441111;">[</span>mask<span style="color:#441111;">]</span> += a<span style="color:#441111;">[</span>i<span style="color:#441111;">]</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">(</span><span style="color:#662222;">(</span><span style="color:#AA00AA;">1</span>&lt;&lt;n<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                  <span style="color:#888888;">// 0 3 0 3 4 7 4 7 3 6 3 6 7 10 7 10
</span>
  sz = subsetSum<span style="color:#662222;">(</span>n, a, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                      <span style="color:#888888;">// 0 3 0 3 4 7 4 7 3 6 3 6 7 10 7 10
</span>  sz = subsetSumS<span style="color:#662222;">(</span>n, a, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                      <span style="color:#888888;">// 0 0 3 3 3 3 4 4 6 6 7 7 7 7 10 10
</span>  sz = subsetSumS<span style="color:#662222;">(</span>n, a, res, <span style="color:#AA00AA;">6</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                      <span style="color:#888888;">// 0 0 3 3 3 3 4 4 6 6
</span>  sz = subsetSumSD<span style="color:#662222;">(</span>n, a, res<span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                      <span style="color:#888888;">// 0 3 4 6 7 10
</span>  sz = subsetSumSD<span style="color:#662222;">(</span>n, a, res, <span style="color:#AA00AA;">6</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>
  wt<span style="color:#662222;">(</span>res<span style="color:#662222;">(</span>sz<span style="color:#662222;">)</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>                      <span style="color:#888888;">// 0 3 4 6
</span></span></pre>
<HR>

<ul><li>template&lt;class T, class S&gt; void maxSubsetDP(int N, T cost[], S res[], void *mem = wmem) : 集合をちょうどk個の空でない部分集合に分割する際のコストの最大値を最小化するDP．k=1,2,...,Nに対して，res[k-1]には 2**N-1 = (i1 | i2 | ... | ik) = (i1 + i2 + ... + ik) の条件で非負整数の組 (i1, i2, ..., ik) が動くとき max(cost[i1], ..., cost[ik]) の最小値が代入される．O(n*3^n)時間．</li>
</ul>

<HR>

<p>部分和問題（subset sum）を解く系列の関数群（ナップザックも作りたいね）．<br>入力のサイズなどから使用メモリが mem_lim を超えなさそうで，一番高速っぽいアルゴリズムを選択します．<br></p>
<ul><li>template&lt;class T&gt; T opt01SubsetSum(int N, T A[], T t, T notfound = -1, int mem_lim = sizeof(memarr)/2, void *mem = wmem) : 配列A[]のいくつかの要素の和で表せる数値の中で，t以下で最も大きいものを返します（同じ要素は1度しか使えない）．存在しない場合は notfound を返します．負の数も大丈夫です．</li>
<li>template&lt;class T&gt; T opt01SubsetSumF(int N, int F, T A[], T t, T notfound = -1, int mem_lim = sizeof(memarr)/2, void *mem = wmem) : 配列A[]のちょうどF個の要素の和で表せる数値の中で，t以下で最も大きいものを返します（同じ要素は1度しか使えない）．存在しない場合は notfound を返します．負の数も大丈夫です．</li>
</ul>
<p>以下は内部で呼び出すことを想定していますが，アルゴリズムを指定したい場合は直接呼び出して良いです．また，使用するアルゴリズムを選択する部分が重くて駄目な場合なども．<br></p>
<ul><li>template&lt;class T&gt; T opt01SubsetSum_brute(int N, T A[], T t, T notfound = -1) : 愚直な全探索．メモリ使わないのが唯一の利点か．</li>
<li>template&lt;class T&gt; T opt01SubsetSum_mim(int N, T A[], T t, T notfound = -1, void *mem = wmem) : 半分全列挙．O(2^N/2)のつもり．</li>
<li>template&lt;class T&gt; T opt01SubsetSum_sdp(int N, T A[], T t, T notfound = -1, void *mem = wmem) : シンプルなDP．要素が全部非負ならO(Nt)ぐらいのつもり（負の要素があるともう少し悪い）．ビットを使って高速化などしてない．</li>
<li>template&lt;class T&gt; T opt01SubsetSumF_brute(int N, int F, T A[], T t, T notfound = -1) : 愚直な全探索．</li>
<li>template&lt;class T&gt; T opt01SubsetSumF_mim(int N, int F, T A[], T t, T notfound = -1, void *mem = wmem) : 半分全列挙．O(2^N/2)のつもり．</li>
<li>template&lt;class T&gt; T opt01SubsetSumF_sdp(int N, int F, T A[], T t, T notfound = -1, void *mem = wmem) : シンプルなDP．要素が全部非負ならO(N^2 t)ぐらいのつもり（負の要素があるともう少し悪い）．ビットを使って高速化などしてない．</li>
</ul>

<HR>

<ul><li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T1, <span style="color:#0088FF;">class</span> T2, <span style="color:#0088FF;">class</span> T3&gt; <span style="color:#0000FF;">int</span> LexicographicGE<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, T1 A<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">int</span> sz, T2 available_num<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, T3 res<span style="color:#441111;">[</span><span style="color:#441111;">]</span>, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 辞書順でAと等しいかそれより大きい配列のうち辞書順で最小の配列で，availlable_numの要素のみからなる，要素数Nの配列res[]を求め，1を戻り値として返します．ただし，存在しないならresはavailable_numの要素のみからなる辞書順で最小（全て最小値）の配列にセットし戻り値として0を返します．A={4,2,6,1}, available_num={-1,3,4}の場合res={4,3,-1,-1}になります．O((N + sz) log sz)時間ぐらい．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> cntArrayNecessaryElement<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> K, T **res<span style="color:#662222;">)</span></span></span> : 長さ i の配列で，各要素は 0 から K-1 の K 種類のどれかで，0 から j-1 までの j 種類の要素については少なくても1回は含まれるような配列の個数を res[i][j] (i=0,1,...,N で j=0,1,...,K) に代入します． T は Modint などを想定．$O(NK)$ 時間です．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> cntArrayNecessaryElement_walloc<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> K, T ***res, <span style="color:#0000FF;">void</span> **mem = &amp;wmem<span style="color:#662222;">)</span></span></span> : res のメモリを mem から確保した後に，<span id="code"><span style="color:#444444">cntArrayNecessaryElement<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> K, T **res<span style="color:#662222;">)</span></span></span> を呼び出して計算します．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> cntArrayNecessaryElement<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> K, T **res, T **cnt1, T **cnt2, <span style="color:#0000FF;">void</span> *mem = wmem<span style="color:#662222;">)</span></span></span> : 上と同様に，長さ i の配列で，各要素は 0 から K-1 の K 種類のどれかで，0 から j-1 までの j 種類の要素については少なくても1回は含まれるような配列を考えます．res[i][j] にはそのような配列の個数を代入します．cnt1[i][j] には条件を満たす配列を全部書き出したときに 0 から j-1 までの各要素が何回出てくるかを代入します（j=0のときは0）．cnt2[i][j] には条件を満たす配列を全部書き出したときに j から K-1 までの各要素が何回出てくるかを代入します（j=Kのときは0）．</li>
<li><span id="code"><span style="color:#444444"><span style="color:#0000FF;">template</span>&lt;<span style="color:#0088FF;">class</span> T&gt; <span style="color:#0000FF;">void</span> cntArrayNecessaryElement_walloc<span style="color:#662222;">(</span><span style="color:#0000FF;">int</span> N, <span style="color:#0000FF;">int</span> K, T ***res, T ***cnt1, T ***cnt2, <span style="color:#0000FF;">void</span> **mem = &amp;wmem<span style="color:#662222;">)</span></span></span></li>
</ul>

<pre><span style="color:#444444"><span style="color:#0000FF;">Modint</span> **res, **cnt1, **cnt2<span style="color:#000000;">;</span>
cntArrayNecessaryElement_walloc<span style="color:#662222;">(</span><span style="color:#AA00AA;">2</span>,<span style="color:#AA00AA;">3</span>,&amp;res,&amp;cnt1,&amp;cnt2<span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 0, 1, 2 のみからなる長さ2の配列
</span>wt<span style="color:#662222;">(</span>res<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>   <span style="color:#888888;">// 5   ({0,0}, {0,1}, {0,2}, {1,0}, {2,0} の5個：0を必ず含むもの)
</span>wt<span style="color:#662222;">(</span>cnt1<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 6   (↑に出てくる0の個数)
</span>wt<span style="color:#662222;">(</span>cnt2<span style="color:#441111;">[</span><span style="color:#AA00AA;">2</span><span style="color:#441111;">]</span><span style="color:#441111;">[</span><span style="color:#AA00AA;">1</span><span style="color:#441111;">]</span><span style="color:#662222;">)</span><span style="color:#000000;">;</span>  <span style="color:#888888;">// 2   (↑に出てくる1の個数や2の個数)
</span></span></pre>
<HR>

<p>ローリングハッシュ．<br>配列 A[0], A[1], ..., A[N-1] をハッシュ関数値 $\sum r^k A[k] \bmod p$ に対応させます．<br>p は $2^{61}-1$ で固定，r は $3^k$ (gcd(k,p-1) = 1) の中からランダムに選ばれます（配列の値の範囲（幅）が2^61以上とかだと危険です．衝突の危険も少しあります）．<br>128ビット整数（__uint128_t 型）を使用しますので，32ビット環境などでは動きません．<br></p>
<p>struct rollingHash {ll len; ull hs;} は配列の長さ len とハッシュ関数値 hs を表す構造体です．<br>以下 rollingHash h; で定義したとします．<br></p>
<p>配列から rollingHash を取得するには，以下の関数を利用します．<br></p>
<ul><li>template&lt;class T&gt; rollingHash calcRollingHash(int N, T A[])</li>
</ul>
<p>rollingHash 構造体で使える機能は以下のとおりです．<br></p>
<ul><li>template&lt;class T&gt; void h.set(int N, T A[]) : 配列 A で上書きします</li>
<li>template&lt;class S, class T&gt; void h.change(ll ind, S bef, T aft) : A[ind] を bef から aft に書き換えてハッシュ値に反映します（配列の内容を保存してないので bef も必要です）</li>
<li>void h.push_front(rollingHash a) : 配列の最初に a を挿入します（len, hs を書き換えます）</li>
<li>void h.push_back(rollingHash a) : 配列の最後に a を挿入します</li>
<li>void h.pop_front(rollingHash a) : 配列の最初が a だとして，その部分を削除します</li>
<li>void h.pop_back(rollingHash a) : 配列の最後が a だとして，その部分を削除します</li>
<li>bool h.operator==(const rollingHash a) : len, hs の両方が等しい場合に true</li>
<li>bool h.operator!=(const rollingHash a)</li>
</ul>
<p>配列に対して，その連続する部分列の rollingHash を取得するには，rollingHashSubarrays 構造体を利用します．<br>rollingHashSubarrays はハッシュ値の累積和を記憶しておきます．<br>以下 rollingHashSubarrays arr; で定義したとします．<br></p>
<ul><li>template&lt;class T&gt; void arr.set(int N, T A[]) : 中身を配列 A の内容で上書きします</li>
<li>rollingHash arr.get_len(int s, int len) : 最初のインデックスが s ，長さ len の連続部分列 A[s], A[s+1], ..., A[s+len-1] のハッシュ値を返します</li>
<li>rollingHash arr.get(int a, int b) : arr_len(a, b - a + 1). A[a], A[a+1], ..., A[b] のハッシュ値．</li>
</ul>
<p>r^k を計算する必要があるとき，|k| がある程度より小さい場合は，適当に前計算したものを利用します．<br>大きい場合（2*10^6ぐらいを超える場合）はバイナリ法で計算します．<br>配列の長さが 2^63 以上，あるいは，それに近い場合は動かないと思います．<br></p>
<p>その他の情報など：<br></p>
<ul><li>#define ROLLING_HASH_MOD (2305843009213693951ULL) : 2^61 - 1</li>
<li>int ROLLING_HASH_MEM : グローバル変数．現在の ROLLING_HASH_PW, ROLLING_HASH_IPW の配列サイズ</li>
<li>ull ROLLING_HASH_BASE : r = 3^k</li>
<li>ull ROLLING_HASH_IBASE : r^(-1)</li>
<li>ull *ROLLING_HASH_PW : ROLLING_HASH_PW[i] = r^i</li>
<li>ull *ROLLING_HASH_IPW : ROLLING_HASH_IPW[i] = r^(-i)</li>
</ul>
<p>参考：<a href="http://rsujskf.s602.xrea.com/?codeforces_educationalround101_e">Educational Codeforces Round 101 E問題 - A Bit Similar</a><br></p>


<h2>ほぼ使わないもの（内部的に使っているもの）</h2>
<ul><li><span id="code"><span style="color:#444444">cLtraits_identity&lt;hoge&gt;::type x<span style="color:#000000;">;</span></span></span> で hoge 型の変数が作られます．</li>
<li><span id="code"><span style="color:#444444">cLtraits_try_make_signed&lt;hoge&gt;::type x<span style="color:#000000;">;</span></span></span> で hoge の符号付き型が存在したらその型，そうでなければhoge型の変数xを宣言します（hogeがullだとll型，hogeがdoubleだとdouble型）．</li>
<li><span id="code"><span style="color:#444444">cLtraits_try_make_unsigned&lt;hoge&gt;::type x<span style="color:#000000;">;</span></span></span> で hoge の符号無し型が存在したらその型，そうでなければhoge型の変数xを宣言します（hogeがllだとull型，hogeがdoubleだとdouble型）．</li>
<li><span id="code"><span style="color:#444444">cLtraits_common_type&lt;S,T&gt;::type x<span style="color:#000000;">;</span></span></span> で </MYCODE_INLINE>common_type<S,T></MYCODE_INLINE> が符号無し整数なら符号付きに変えた型になります．</li>
</ul>





<h1 id="joig980">更新履歴</h2>
<ul><li><b>20241019-1</b>:<br>【機能追加っぽいの】<br>kthPalindromicNumber64(), reverseNumber(), isPalindromicNumber() を追加．<br>TwoPointers()[][][] を追加（尺取法）．<br>【バグ修正っぽいの】<br>変数宣言時のコンストラクタの引数に &gt;?= などがあると<a href="https://x.com/non_archimedean/status/1815369769110978622">バグる</a>のを修正．<br>wt(), sum(), min() などの中でラムダ式 auto f = [](){}; を配列と思って sum(f(2)); を sum(f[0],f[1]); に展開して<a href="https://x.com/non_archimedean/status/1840190452349423783">バグってた</a>のを展開しないようにしたはず．<br>std::min(), std::max() とmin(), max() の前に std:: があるとcLay独自の min(), max() でなく C++ 標準の min(), max() を使用するようにした．<br>wt(min(a(3))+1); で a の型が無視され wt の中身が int 型と解釈され，状況によって<a href="https://x.com/non_archimedean/status/1846167977865236938">エラーになる</a>のを修正（cLtraits系などを検出するようにした）．<br>【ドキュメントの修正】<br>三項演算子の併用で，reader(), writer() が単独で文にならない場合の挙動を追記．<br>min(), max() についていくらか追記．<br></li>
<li><b>20240714-1</b>:<br>【バグ修正っぽいの】<br>if(), for(), while() など制御文の () の内部とか，関数の引数とかで &lt;?=, &gt;?=, **=, %%=, /+= が使えない，うまく展開されないのを修正．<br>Point2dのInnerProd()が動かないバグを修正（配列の方のInnerProdが邪魔してた）．<br>配列外アクセスを一部修正．<br></li>
<li><b>20240420-1</b>:<br>【機能追加っぽいの】<br>Timer2 構造体を追加．<br>【バグ修正っぽいの】<br>powmod(), PowMod() にて a^0 mod 1 が 0 を返すように修正（1を返していた）．<br><a href="https://twitter.com/non_archimedean/status/1776152574032224277">min(0,sum[i,0,0](0));</a> などが動かないのを応急処置．int a[3]; sum(a(3)); のような感じで配列の展開の形にされてたのが原因．応急処置なのでまだ動かないことがあるはず．<br>【その他っぽいの】<br>#ifdef, #endif, #else があっても動くように．</li>
<li><b>20240104-1</b>:<br>【バグ修正っぽいの】<br>weightedUnionFind で重みの型が int 以外のとき<a href="https://twitter.com/non_archimedean/status/1742150522982031631">動かなかった</a>のを修正．<br>int i = 1 &gt= 2; のように変数宣言の初期化の際に = があると<a href="https://twitter.com/non_archimedean/status/1732016194394185957">動かなかった</a>の修正．<br>max[i,0,5](式); などで式の部分に &lt; &gt; があるとパースミスって<a href="https://twitter.com/laycrs/status/1732365604752122281">動かなかった</a>のを修正．<br>【その他っぽいの】<br>UnionFind 系でコンストラクタの mode に不正な値いれて呼び出したとき assert で落ちるようにした．<br>string a; wt(a.substr(1,2)); などができるように：引数を string &amp;a から const string &amp;a にした．<br>↑のついでに，vector, set, multiset などを引数に取るときにも const T &amp; の形にした．</li>
<li><b>20231120-1</b>:<br>【機能追加っぽいの】<br>startWith(), endWith() を追加．<br>MergeTech() を追加．<br>WildEQ() を追加．<br>【バグ修正っぽいの】<br>inversion_range(), inversion() の引数に const をつけた．ついでに，引数が vector や string のinversion() を追加．</li>
<li><b>20231031-1</b>:<br>【機能追加っぽいの】<br>VLL で vector&lt;long long&gt; になるように．ついでに，VVLL, VVVLL まで追加．<br>変数宣言時に入力する @ で vector に対応した気がする． VI @a(10); とか．<br>Count() において vector 版を追加．string 版を参照渡しにした．<br>Slice() を追加．<br>PalindromeCost() を追加．<br>BIT_Ith() を追加（BIT_ith()の使い勝手が悪いので…）．<br>【バグ修正っぽいの】<br>for(int a, b; hoge; hoge) のように for の中で2個以上変数宣言したときに<a href="https://twitter.com/non_archimedean/status/1717441752435740737">バグってた</a>のを修正．<br>【その他っぽいの】<br>arrCountVal() を Count() でも呼び出せるようにした．<br></li>
<li><b>20231016-1</b>:<br>【機能追加っぽいの】<br>@を使用して変数宣言時に入力を読み込む機能で int @(A,B,ll C)[10]; などで順番に読み込む方法を追加．<br>【バグ修正っぽいの】<br>構造化束縛の構文（pair&lt;int,int&gt; f(int x){return {x,2*x};} があって auto [a,b] = f(10); みたいなのや，for(auto &amp;[a,b] : s){hoge;} みたいなの）が動くようになったと思う．<br>template の &lt;&gt; が2回出てくる場合などに困るので，hoge &lt; hoge &gt; hoge &lt; hoge &gt; hoge が &amp;&amp; に展開されないように．<br><a href="https://twitter.com/non_archimedean/status/1710623182863175838">ありがとうございます</a>．</li>
<li><b>20221230-1</b>:<br>【その他っぽいの】<br>fib_mod() を <a href="https://twitter.com/saito_ta/status/1602947036198096897">tailsさんの方法</a> を取り入れたりしながら高速化（Fib_mod(), Fibonacci_mod()を追加）．</li>
<li><b>20221122-1</b>:<br>【バグ修正っぽいの】<br>sortA_index() の引数が配列3個以上の場合に動かなかったのを修正．<br>【ドキュメントの修正】<br>wtF の引数で式を使えない旨を書いた．</li>
<li><b>20220506-1</b>:<br>【機能追加っぽいの】<br>sortA() 系統を高速化（？）した．従来の sortA() は sortI() に名称変更．<br>coordcomp() で上書きするのと新しく配列を作るので関数を分け，一部の引数の型を変更．<br>cntSubsequence() の引数の一部にconstをつけた．<br>cntSubsequence() のstring版を追加．<br>Unique() の引数にワーキングメモリを取るようにした（sortA()を利用するようになった）．<br>cLtraits_try_make_unsigned 追加．</li>
<li><b>20220312-1</b>:<br>【機能追加っぽいの】<br>Arr2d 構造体の累積和 getSum() の引数が配列の範囲外の場合も動くよう（仕様を確定）にした．<br>Distinct() の vector 版を追加．<br>graph構造体の maxIndependenceSet() がまだバグってたので修正．<br>isSorted() を追加．<br>【バグ修正っぽいの】<br>arr2bit_int(), arr2bit_ll() の string 版で余分な template が入っていたのを修正．<br>if文の条件式や変数宣言時の右辺などで sum(), XOR() などが使われているときの処理を変更．今まで XOR など働かものがあった．</li>
<li><b>20220116-1</b>:<br>【機能追加っぽいの】<br>arr2bit_int(), arr2bit_ll() を追加．<br>cntArrayForDistinct(), cntArrayForDistinct_walloc() を追加．<br>toLower(), toUpper() を追加．</li>
<li><b>20211231-1</b>:<br>【機能追加っぽいの】<br>writer で vector, set, multiset, pair をそのまま出力できるように．<br>LinearEquation() を追加．<br>【バグ修正っぽいの】<br>Arr1d の getSum() の仕様を修正（範囲外は0とみなす，i &gt; jの場合0を返す，引数の型を限定しない）．<br>arrCountVal(), arrCountValSeqMax() の引数に const をつけた．</li>
<li><b>20211229-1</b>:<br>【機能追加っぽいの】<br>arrMerge(), arrMergeD() を追加．<br>opt01SubsetSum(), opt01SubsetSumF(), opt01SubsetSum_brute(), opt01SubsetSum_mim(), opt01SubsetSum_sdp(), opt01SubsetSumF_brute(), opt01SubsetSumF_mim(), opt01SubsetSumF_sdp() を追加．<br>@[a,b]で2つに展開する機能（arraylike sentence）を追加．<br>【バグ修正っぽいの】<br>ラムダ式書くと，その中身でrepなどの構文的な機能が働かないのを暫定修正（ラムダ式の引数，for(auto a:b）の形式で定義された変数が変数と認識されないバグがまだあるはず）．</li>
<li><b>20211024-1</b>:<br>【機能追加っぽいの】<br>sortA_index() を追加．<br>unionFind系列にコンストラクタを追加．<br>DigitHist() を追加．<br>STR2int(), STR2ll() を追加．<br>Arr1d構造体の set() において型が違っても受け付けるようにした．また，vectorについてはコピーして渡す set_c() を追加．<br>Arr2d構造体の set() において型が違っても受け付けるようにした．また，vectorについてはコピーして渡す set_c() を追加．<br>【バグ修正っぽいの】<br>rollbackUnionFind に comp() がなかったのを修正．<br>Memoizeにおいて f_clear() の引数が壊れていたのを修正．</li>
<li><b>20210926-1</b>:<br>【バグ修正っぽいの】<br>関数の戻り値が ll とかcLayの機能で省略形になっている場合，Memoizeがバグるのを修正．<br>//working_memory=500m とかでワーキングメモリのサイズを指定できなくなってたのを修正（20210913-1でコメント関係の修正をした際にバグらせてた）．</li>
<li><b>20210917-1</b>:<br>【機能追加っぽいの】<br>Modint, modint, Mint, mint に対する Determinant() を追加．<br>ビット演算系の畳込み xorConvolution(), andConvolution(), orConvolution() を追加．<br>それに伴い，高速Walsh-Hadamrd変換の関数HadamardTransform()，包含関係が逆のゼータ変換がらみ ZetaTransform2(), MoebiusTransform2() を追加．<br>【バグ修正っぽいの】<br>int Mex(int N, T A[], int sorted=0, void *mem = wmem) がバグってたのを修正．</li>
<li><b>20210913-1</b>:<br>【機能追加っぽいの】<br>関数を自動的にメモ化するMemoizeを追加．<br>プログラム全体がメイン関数のみの場合で，唐突のブロックもない場合は，メイン関数を表す {} を省略可能にした．<br>変数制限と同時に読み込む@に対して，読み込んだ直後にインクリメント，デクリメントと，配列に対応．<br>【バグ修正っぽいの】<br>wt(1LL); とかで 1LL が int 型だと判定されて動かないのを暫定修正．<br>wt((ll)(4-2)); のように，キャストの()の後にカッコの式が続くと配列の出力に展開されてたのを暫定修正．<br>コメントを変な入れ方をするとバグるのを暫定修正．int /*hoge*/ @N; rep /*hoge*/ (i,N); とか．</li>
<li><b>20210904-1</b>:<br>【機能追加っぽいの】<br>invDigit_r(int sz, T d[]) を追加．<br>LexicographicGE() を追加．<br>チェック付き入力 cReader_ll(), cReader_eof() を追加．<br>cntPrime(), sumPrime() を追加．<br>rangeTree2d_pf 構造体を追加．<br>Iroot_f(), Iroot_c(), Iroot_s(), Iroot() を追加．<br>【バグ修正っぽいの】<br>rangeTree2d&lt;S,T1,T2&gt; で S が Modint などのように比較演算子が定義されてなくても動くように修正．<br>rep(i,10) rep_perm(d,10) hoge; とか if(hoge) rep_dist(i,j,0,0) hoge; とか rep や if に続けてブロックに囲まず rep_perm や rep_dist を書くとバグってたのを修正．</li>
<li><b>20210816-1</b>:<br>【機能追加っぽいの】<br>rep_dist を追加．</li>
<li><b>20210814-1</b>:<br>【機能追加っぽいの】<br>polationVal(n, y, t) において，割り算の回数を削減．ただしワーキングメモリが必要になった．<br>cpp_int を型名として認識するようにし，cpp_int が出てきたら include, using namespace を勝手に設定するように．<br>cntSubsequence() を追加．<br>【バグ修正っぽいの】<br>rangeTree2d 構造体の add() の戻り値を int から void に<a href="https://twitter.com/saito_ta/status/1425719322559746049">修正</a>．<br>graph 構造体の anUndirectedCycle() がグラフが連結でない場合にサイクルを発見できないことがあるのを<a href="https://twitter.com/laycrs/status/1426181798334124037">修正</a>．</li>
<li><b>20210708-1</b>:<br>【機能追加っぽいの】<br>prodDigits() を追加．<br>maxSubarrayDistinct() を追加．<br>maxSubsetDP() を追加．<br>weightedUnionFind 構造体を追加．<br>gwaph 構造体，および，wgraph 構造体に Rerooting() を追加．<br>EulerPhi() を追加．<br>minFactorList(), maxFactorList(), FactorList(), FactorMList(), EulerPhiList() を追加．<br>LinearEquationMod2() を追加．<br>【バグ修正っぽいの】<br>Point2d を rd() で読み込んだときに warning が出ないように応急処置．<br>template&lt;class T&gt; template&lt;class S&gt; void func(T a, S, b) などとtemplateを複数並べるとバグってたのを修正．</li>
<li><b>20210703-1</b>:<br>【機能追加っぽいの】<br>isPrime(), Factor(), Divisor() 関連をミラーラビン，ポラードローを利用した方法に変更．ワーキングメモリを使用するようになり引数が一部変更．<br>Arr1d 構造体，Arr2d 構造体で setN() で要素を初期化するバージョンを追加．<br>string 版の isSubsequence(), isSubsequence_r() を追加．配列版の isSubsequence() の引数をちょい変更（A[], B[] が違う型でも良くした，constをつけた）．<br>Comb 構造体に，Catalan(n, m, k)，Catalan_s(n, m, k)，H_s() を追加．<br>sum[]() などで条件を満たすもののみ処理@，中身が空の場合の値の設定<code>$</code>を追加．<br>maxflow 構造体でmalloc, wallocにメモリ確保しながら init もするバージョンを追加．<br>配列版の getClosest(), getClosestL() を追加．<br>BIT_parity(), BIT_parity_pm() を追加．<br>Point2d 構造体をとりあえず追加．<br>arrErase() で1要素を消す場合は，消した要素の値を返すようにした．<br>PowMod() を追加．<br>Polynomial 構造体にコンストラクタ Polynomial(T a) と Polynomial<T>&amp; operator=(const T a) を追加．ついでにPolynomialを一部コードを書き直した．<br>【バグ修正っぽいの】<br>個数も扱う Unique() の引数でワーキングメモリを指定できるように．<br>AND[](), OR[](), XOR[]() が狂ってるのを修正．<br>文の中や関数の引数で pair&lt;int,int&gt;(1,1) のようなことを書くと int,int のカンマで区切られて2つの式になったり引数が壊れたりするのを修正．</li>
<li><b>20210607-1</b>:<br>【機能追加っぽいの】<br>2つの配列を一致させる最小隣接swap数を求める inversion() を追加．<br>RoundUp(), RoundDown() を追加．<br>HashMap 構造体に init(int nn, SVAL ini) を追加．<br>swapV() を追加．<br>cntSubarrayFreq(), cntSubarrayDistinct() を追加．<br>sumsetSum() 系のワーキングメモリの確保を微調整し，nが大きい，答えが少ない，場合にも一応使えるように．<br>DijkstraHeap に malloc(), walloc() するときについでに init() するバージョンを追加．<br>vec2arr() 系列を追加．<br>Rot90() を追加．<br>Arr2d 構造体に累積和 getSum(), getSumBorder()，斜め累積和 getSum45(), getSum45Border() を追加．</li>
<li><b>20210524-1</b>:<br>【機能追加っぽいの】<br>set, multiset に対する getClosest() を追加．<br>XOR(), OR(), AND(), XOR[](), OR[](), AND[]() などを追加．<br>segtree_Change_Sum を追加．<br>coordcomp() に3つ配列バージョンを追加．<br>unionFind 構造体に comp() を追加．<br>VVI，VVVI，VSがそれぞれvector&lt;VI&gt;，vector&lt;VVI&gt;，vector&lt;string&gt; に置き換えられるように．<br>arrCountVal() の string 版，arrCountValSeqMax() の配列版，string版を追加．<br>【バグ修正っぽいの】<br>graph 構造体の anUndirectedCycle() で res=NULL を指定した場合にバグるのを修正．<br>Comb 構造体の Multinomial(int sz, int a[]) が常に1を返すバグを修正．<br>【その他っぽいの】<br>fenwick, fenwick_xor の range(a,b) で範囲外(indexが0未満，N以上)の部分は0として計算するようにした．<br>#pragma GCC optimize("unroll-loops"), #pragma GCC optimize("inline") を追加するようにした．</li>
<li><b>20210405-1</b>:<br>【機能追加っぽいの】<br>Arr2d 構造体を取り敢えず最低限の機能で追加．<br>【バグ修正っぽいの】<br>graph 構造体の bipartite() が<a href="https://twitter.com/functionalzacni/status/1378587611703300107">バグってた</a>のを修正．</li>
<li><b>20210404-1</b>:<br>【機能追加っぽいの】<br>cLtraits_identity, cLtraits_try_make_signed, cLtraits_common_type を追加．<br>isValidBracket1(), isValidBracket2() を追加．<br>【バグ修正っぽいの】<br>graph構造体の maxIndependenceSet(), countIndependenceSet() がバグってたのを修正．<br>Arr1d構造体の setPrevLE() などの戻り値の方が間違えてたのを修正（int→void）．<br>template&lt;typename T&gt; ... の中身で T が型だと判定するようにした．<br>using T = int; で T を型として認識するように，template&lt;T&gt; using T = vector&lt;T&gt; などで T&lt;hoge&gt; を型として認識するようにした．<br>hoge&lt;hoge&gt;::type, hoge&lt;hoge&gt;::type::type, ...  を型として認識するようにした．<br>結果の型を指定せずに sum[](), sum[][]() などを入れ子にした場合の挙動をマシにしたつもり．sum(), max() 系もバグったりするのを修正，挙動を修正．<br>・ull i = 3; int j = -5; で min(i,j) や min(j,i) が ll 型の-5になるように（一番でかい型の符号付きにします）．</li>
</ul>
<p>これ以前の更新履歴は<a href="http://rsujskf.s602.xrea.com/?cLay_log&datdate=1623057098">こちら</a>．<br></p>

</body>
</html>
